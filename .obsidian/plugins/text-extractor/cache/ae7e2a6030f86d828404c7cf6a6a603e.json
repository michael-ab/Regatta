{"path":".obsidian/plugins/text-extractor/cache/ae7e2a6030f86d828404c7cf6a6a603e.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 06 Hash Tables CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Project #1 is due Fri Sept 27th @ 11:59pm Homework #2 is due Mon Sept 30th @ 11:59pm 2 CMU 15-445/645 (Fall 2019) Query Planning Operator Execution Access Methods Buffer Pool Manager Disk Manager C O U R S E S TAT U S We are now going to talk about how to support the DBMS's execution engine to read/write data from pages. Two types of data structures: → Hash Tables → Trees 3 CMU 15-445/645 (Fall 2019) D ATA S T R U C T U R E S Internal Meta-data Core Data Storage Temporary Data Structures Table Indexes 4 CMU 15-445/645 (Fall 2019) D E S I G N D E C I S I O N S Data Organization → How we layout data structure in memory/pages and what information to store to support efficient access. Concurrency → How to enable multiple threads to access the data structure at the same time without causing problems. 5 CMU 15-445/645 (Fall 2019) H A S H TA B L E S A hash table implements an unordered associative array that maps keys to values. It uses a hash function to compute an offset into the array for a given key, from which the desired value can be found. Space Complexity: O(n) Operation Complexity: → Average: O(1) → Worst: O(n) 6 Money cares about constants! CMU 15-445/645 (Fall 2019) S TAT I C H A S H TA B L E Allocate a giant array that has one slot for every element you need to store. To find an entry, mod the key by the number of elements to find the offset in the array. 7 hash(key) ⋮ 0 1 2 n abc def xyz Ø CMU 15-445/645 (Fall 2019) S TAT I C H A S H TA B L E Allocate a giant array that has one slot for every element you need to store. To find an entry, mod the key by the number of elements to find the offset in the array. 7 hash(key) ⋮ 0 1 2 n abcdefghi defghijk xyz123 CMU 15-445/645 (Fall 2019) A S S U M P T I O N S You know the number of elements ahead of time. Each key is unique. Perfect hash function. → If key1≠key2, then hash(key1)≠hash(key2) 8 hash(key) ⋮ 0 1 2 n abcdefghi defghijk xyz123 CMU 15-445/645 (Fall 2019) H A S H TA B L E Design Decision #1: Hash Function → How to map a large key space into a smaller domain. → Trade-off between being fast vs. collision rate. Design Decision #2: Hashing Scheme → How to handle key collisions after hashing. → Trade-off between allocating a large hash table vs. additional instructions to find/insert keys. 9 CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A Hash Functions Static Hashing Schemes Dynamic Hashing Schemes 10 CMU 15-445/645 (Fall 2019) H A S H F U N C T I O N S For any input key, return an integer representation of that key. We do not want to use a cryptographic hash function for DBMS hash tables. We want something that is fast and has a low collision rate. 11 CMU 15-445/645 (Fall 2019) H A S H F U N C T I O N S CRC-64 (1975) → Used in networking for error detection. MurmurHash (2008) → Designed to a fast, general purpose hash function. Google CityHash (2011) → Designed to be faster for short keys (<64 bytes). Facebook XXHash (2012) → From the creator of zstd compression. Google FarmHash (2014) → Newer version of CityHash with better collision rates. 12 CMU 15-445/645 (Fall 2019) H A S H F U N C T I O N B E N C H M A R K 13 0 1000 2000 3000 4000 1 2 3 4 5 6 7 8Throughput (MB/sec) Key Size (bytes) crc64 std::hash MurmurHash3 CityHash FarmHash XXHash3 Source: Fredrik Widlund Intel Core i7-8700K @ 3.70GHz CMU 15-445/645 (Fall 2019) H A S H F U N C T I O N B E N C H M A R K 14 0 7000 14000 21000 28000 1 51 101 151 201 251Throughput (MB/sec) Key Size (bytes) crc64 std::hash MurmurHash3 CityHash FarmHash XXHash3 Source: Fredrik Widlund Intel Core i7-8700K @ 3.70GHz 32 64 128 192 CMU 15-445/645 (Fall 2019) S TAT I C H A S H I N G S C H E M E S Approach #1: Linear Probe Hashing Approach #2: Robin Hood Hashing Approach #3: Cuckoo Hashing 15 CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G Single giant table of slots. Resolve collisions by linearly searching for the next free slot in the table. → To determine whether an element is present, hash to a location in the index and scan for it. → Have to store the key in the index to know when to stop scanning. → Insertions and deletions are generalizations of lookups. 16 CMU 15-445/645 (Fall 2019) <key>|<value> L I N E A R P R O B E H A S H I N G 17 A B C D hash(key) | valA E F CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G 17 A B C D hash(key) | valA | valB E F CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G 17 A B C D hash(key) | valA | valB | valC E F CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G 17 A B C D hash(key) | valA | valB | valC | valDE F CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G 17 A B C D hash(key) | valA | valB | valC | valDE | valEF CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G 17 A B C D hash(key) | valA | valB | valC | valDE | valEF | valF CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S 18 A B C D hash(key) | valA | valB | valC E F | valD | valE | valF Delete CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S 18 A B C D hash(key) | valA | valB E F | valD | valE | valF Delete CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S 18 A B C D hash(key) | valA | valB E F | valD | valE | valF Find CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S Approach #1: Tombstone 18 A B C D hash(key) | valA | valB E F | valD | valE | valF Find CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S Approach #1: Tombstone Approach #2: Movement 18 A B C D hash(key) | valA | valB E F | valD | valE | valF Find CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S Approach #1: Tombstone Approach #2: Movement 18 A B C D hash(key) | valA | valB E F | valD | valE | valF Find CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S Approach #1: Tombstone Approach #2: Movement 18 A B C D hash(key) | valA | valB E F | valD | valE | valF Find CMU 15-445/645 (Fall 2019) L I N E A R P R O B E H A S H I N G D E L E T E S Approach #1: Tombstone Approach #2: Movement 18 A B C D hash(key) | valA | valB E F | valD | valE | valF Find CMU 15-445/645 (Fall 2019) N O N - U N I Q U E K E Y S Choice #1: Separate Linked List → Store values in separate storage area for each key. Choice #2: Redundant Keys → Store duplicate keys entries together in the hash table. 19 XYZ ABC value1 value2 value3 Value Lists value1 value2 XYZ|value1 ABC|value1 XYZ|value2 XYZ|value3 ABC|value2 CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G Variant of linear probe hashing that steals slots from \"rich\" keys and give them to \"poor\" keys. → Each key tracks the number of positions they are from where its optimal position in the table. → On insert, a key takes the slot of another key if the first key is farther away from its optimal position than the second key. 20 CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G 21 A B C D hash(key) | val [0]A E # of \"Jumps\" From First Position F CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G 21 A B C D hash(key) | val [0]A | val [0]B E F CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G 21 A B C D hash(key) | val [0]A | val [0]B | val [1]C E F A[0] == C[0] CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G 21 A B C D hash(key) | val [0]A | val [0]B | val [1]C | val [1]DE F C[1] > D[0] CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G 21 A B C D hash(key) | val [0]A | val [0]B | val [1]C | val [1]DE A[0] == E[0] C[1] == E[1] D[1] < E[2] F CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G 21 A B C D hash(key) | val [0]A | val [0]B | val [1]C E | val [2]E A[0] == E[0] C[1] == E[1] D[1] < E[2] F | val [2]D CMU 15-445/645 (Fall 2019) R O B I N H O O D H A S H I N G 21 A B C D hash(key) | val [0]A | val [0]B | val [1]C E | val [2]E F | val [2]D | val [1]F D[2] > F[0] CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G Use multiple hash tables with different hash function seeds. → On insert, check every table and pick anyone that has a free slot. → If no table has a free slot, evict the element from one of them and then re-hash it find a new location. Look-ups and deletions are always O(1) because only one location per hash table is checked. 22 CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) A|val CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) Insert B hash1(B) hash2(B) A|val CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) Insert B hash1(B) hash2(B) B|val A|val CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) Insert B hash1(B) hash2(B) Insert C hash1(C) hash2(C) B|val A|val CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) Insert B hash1(B) hash2(B) Insert C hash1(C) hash2(C) A|val C|val CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) Insert B hash1(B) hash2(B) Insert C hash1(C) hash2(C) hash1(B) C|val B|val CMU 15-445/645 (Fall 2019) C U C KO O H A S H I N G 23 Hash Table #1 ⋮ Hash Table #2 ⋮ Insert A hash1(A) hash2(A) Insert B hash1(B) hash2(B) Insert C hash1(C) hash2(C) hash1(B) hash2(A) A|val C|val B|val CMU 15-445/645 (Fall 2019) O B S E R VAT I O N The previous hash tables require the DBMS to know the number of elements it wants to store. → Otherwise it has rebuild the table if it needs to grow/shrink in size. Dynamic hash tables resize themselves on demand. → Chained Hashing → Extendible Hashing → Linear Hashing 24 CMU 15-445/645 (Fall 2019) C H A I N E D H A S H I N G Maintain a linked list of buckets for each slot in the hash table. Resolve collisions by placing all elements with the same hash key into the same bucket. → To determine whether an element is present, hash to its bucket and scan for it. → Insertions and deletions are generalizations of lookups. 25 CMU 15-445/645 (Fall 2019) C H A I N E D H A S H I N G 26 Ø hash(key) ⋮ ⋮ Buckets CMU 15-445/645 (Fall 2019) C H A I N E D H A S H I N G 26 Ø hash(key) ⋮ ⋮ Buckets CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G Chained-hashing approach where we split buckets instead of letting the linked list grow forever. Multiple slot locations can point to the same bucket chain. Reshuffling bucket entries on split and increase the number of bits to examine. → Data movement is localized to just the split chain. 28 CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 0 1 … 0 0 … 1 0 … 1 1 … local local local 00010… 01110… 1 10101… 10011… 2 11010… 2 CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 0 1 … 0 0 … 1 0 … 1 1 … local local local 00010… 01110… 1 10101… 10011… 2 11010… 2 hash(A) = 01110… Find A CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 0 1 … 0 0 … 1 0 … 1 1 … local local local 00010… 01110… 1 10101… 10011… 2 11010… 2 hash(A) = 01110… Find A hash(B) = 10111… Insert B 10111… CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 0 1 … 0 0 … 1 0 … 1 1 … local local local 00010… 01110… 1 10101… 10011… 2 11010… 2 hash(A) = 01110… Find A hash(B) = 10111… Insert B hash(C) = 10100… Insert C 10111… CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 0 1 … 0 0 … 1 0 … 1 1 … local local local 00010… 01110… 1 10101… 10011… 2 11010… 2 hash(A) = 01110… Find A hash(B) = 10111… Insert B hash(C) = 10100… Insert C 10111… CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 0 1 … 0 0 … 1 0 … 1 1 … local local local 00010… 01110… 1 10101… 10011… 2 11010… 2 hash(A) = 01110… Find A hash(B) = 10111… Insert B hash(C) = 10100… Insert C 3 10111… CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 local local local 00010… 01110… 1 10101… 10011… 2 11010… 2 hash(A) = 01110… Find A hash(B) = 10111… Insert B hash(C) = 10100… Insert C 0 1 0 … 0 0 0 … 1 0 0 … 1 1 0 … 0 1 1 … 0 0 1 … 1 0 1 … 1 1 1 … 3 10111… CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 00010… 01110… 1 11010… 2 hash(A) = 01110… Find A hash(B) = 10111… Insert B hash(C) = 10100… Insert C 0 1 0 … 0 0 0 … 1 0 0 … 1 1 0 … 0 1 1 … 0 0 1 … 1 0 1 … 1 1 1 … 3 10011… 3 10101… 10111… 3 CMU 15-445/645 (Fall 2019) E X T E N D I B L E H A S H I N G 29 global 2 00010… 01110… 1 11010… 2 hash(A) = 01110… Find A hash(B) = 10111… Insert B hash(C) = 10100… Insert C 0 1 0 … 0 0 0 … 1 0 0 … 1 1 0 … 0 1 1 … 0 0 1 … 1 0 1 … 1 1 1 … 3 10011… 3 10101… 10111… 3 10100… CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G The hash table maintains a pointer that tracks the next bucket to split. → When any bucket overflows, split the bucket at the pointer location. Use multiple hashes to find the right bucket for a given key. Can use different overflow criterion: → Space Utilization → Average Length of Overflow Chains 30 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 5 9 13 6 7 11 20 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 20 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 20 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 17 20 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 1717 20 Overflow! CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 1717 4 hash2(key) = key % 2n 20 Overflow! CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 1717 4 20hash2(key) = key % 2n CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 17 hash1(20) = 20%4=0 Find 20 17 4 20hash2(key) = key % 2n CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 17 hash1(20) = 20%4=0 Find 20 17 4 20hash2(key) = key % 2n hash2(20) = 20%8=4 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 17 hash1(20) = 20%4=0 Find 20 17 4 20hash2(key) = key % 2n hash2(20) = 20%8=4 hash1(9) = 9%4=1 Find 9 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G 31 1 0 2 3 8 hash1(6) = 6%4=2 Find 6 5 9 13 6 7 11 Split Pointer hash1(key) = key % n hash1(17) = 17%4=1 Insert 17 hash1(20) = 20%4=0 Find 20 17 4 20hash2(key) = key % 2n hash2(20) = 20%8=4 hash1(9) = 9%4=1 Find 9 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G Splitting buckets based on the split pointer will eventually get to all overflowed buckets. → When the pointer reaches the last slot, delete the first hash function and move back to beginning. The pointer can also move backwards when buckets are empty. 32 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G D E L E T E S 33 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 17 4 20hash2(key) = key % 2n hash1(20) = 20%4=0 Delete 20 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G D E L E T E S 33 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 17 4 20hash2(key) = key % 2n hash1(20) = 20%4=0 Delete 20 hash2(20) = 20%8=4 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G D E L E T E S 33 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 17 4 20hash2(key) = key % 2n hash1(20) = 20%4=0 Delete 20 hash2(20) = 20%8=4 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G D E L E T E S 33 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 17 4 hash2(key) = key % 2n hash1(20) = 20%4=0 Delete 20 hash2(20) = 20%8=4 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G D E L E T E S 33 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 17 4 hash2(key) = key % 2n hash1(20) = 20%4=0 Delete 20 hash2(20) = 20%8=4 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G D E L E T E S 33 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 17 hash1(20) = 20%4=0 Delete 20 hash2(20) = 20%8=4 CMU 15-445/645 (Fall 2019) L I N E A R H A S H I N G D E L E T E S 33 1 0 2 3 8 5 9 13 6 7 11 Split Pointer hash1(key) = key % n 17 hash1(20) = 20%4=0 Delete 20 hash2(20) = 20%8=4 hash1(21) = 21%4=1 Insert 21 Overflow! 21 CMU 15-445/645 (Fall 2019) C O N C L U S I O N Fast data structures that support O(1) look-ups that are used all throughout the DBMS internals. → Trade-off between speed and flexibility. Hash tables are usually not what you want to use for a table index… 34 CMU 15-445/645 (Fall 2019) N E X T C L A S S B+Trees → aka \"The Greatest Data Structure of All Time!\" 35","libVersion":"0.2.2","langs":""}