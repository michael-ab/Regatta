{"path":".obsidian/plugins/text-extractor/cache/0a7b7379d7b4ab977bd6d23761f252f8.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 21 Database Recovery CMU 15-445/645 (Fall 2019) C R A S H R E C O V E R Y Recovery algorithms are techniques to ensure database consistency, transaction atomicity, and durability despite failures. Recovery algorithms have two parts: → Actions during normal txn processing to ensure that the DBMS can recover from a failure. → Actions after a failure to recover the database to a state that ensures atomicity, consistency, and durability. 2 Today CMU 15-445/645 (Fall 2019) A R I E S Algorithms for Recovery and Isolation Exploiting Semantics Developed at IBM Research in early 1990s for the DB2 DBMS. Not all systems implement ARIES exactly as defined in this paper but they're close enough. 3 CMU 15-445/645 (Fall 2019) A R I E S M A I N I D E A S Write-Ahead Logging: → Any change is recorded in log on stable storage before the database change is written to disk. → Must use STEAL + NO-FORCE buffer pool policies. Repeating History During Redo: → On restart, retrace actions and restore database to exact state before crash. Logging Changes During Undo: → Record undo actions to log to ensure action is not repeated in the event of repeated failures. 4 CMU 15-445/645 (Fall 2019) Log Sequence Numbers Normal Commit & Abort Operations Fuzzy Checkpointing Recovery Algorithm 5 CMU 15-445/645 (Fall 2019) WA L R E C O R D S We need to extend our log record format from last class to include additional info. Every log record now includes a globally unique log sequence number (LSN). Various components in the system keep track of LSNs that pertain to them… 6 CMU 15-445/645 (Fall 2019) LO G S E Q U E N C E N U M B E R S 7 Name Where Definition flushedLSN Memory Last LSN in log on disk pageLSN pagex Newest update to pagex recLSN pagex Oldest update to pagex since it was last flushed lastLSN Ti Latest record of txn Ti MasterRecord Disk LSN of latest checkpoint CMU 15-445/645 (Fall 2019) W R I T I N G LO G R E C O R D S Each data page contains a pageLSN. → The LSN of the most recent update to that page. System keeps track of flushedLSN. → The max LSN flushed so far. Before page x can be written to disk, we must flush log at least to the point where: → pageLSNx ≤ flushedLSN 8 CMU 15-445/645 (Fall 2019) WAL (Tail) Buffer Pool 001:<T1 BEGIN> 002:<T1, A, 1, 2> 003:<T1 COMMIT> 004:<T2 BEGIN> 005:<T2, A, 2, 3> 006:<T3 BEGIN> 007:<CHECKPOINT> 008:<T2 COMMIT> 009:<T3, A, 3, 4> 010:<T4 BEGIN> 011:<T4, X, 5, 6> 012:<T4, Y, 9, 7> 013:<T3, B, 4, 2> 014:<T3 COMMIT> 015:<T4, B, 2, 3> 016:<T4, C, 1, 2> W R I T I N G LO G R E C O R D S 9 WAL Database 017:<T5 BEGIN> 018:<T5, A, 9, 8> 019:<T5, B, 5, 1> 020:<T5 COMMIT> ⋮ MasterRecord flushedLSN pageLSN recLSN A=9 B=5 C=2 pageLSN recLSN A=9 B=5 C=2 ? Log Sequence Numbers Log Sequence Numbers ? Safe to unpin because pageLSN ≤ flushedLSN Not safe to unpin because pageLSN > flushedLSN CMU 15-445/645 (Fall 2019) W R I T I N G LO G R E C O R D S All log records have an LSN. Update the pageLSN every time a txn modifies a record in the page. Update the flushedLSN in memory every time the DBMS writes out the WAL buffer to disk. 10 CMU 15-445/645 (Fall 2019) N O R M A L E X E C U T I O N Each txn invokes a sequence of reads and writes, followed by commit or abort. Assumptions in this lecture: → All log records fit within a single page. → Disk writes are atomic. → Single-versioned tuples with Strict 2PL. → STEAL + NO-FORCE buffer management with WAL. 11 CMU 15-445/645 (Fall 2019) T R A N S A C T I O N C O M M I T Write COMMIT record to log. All log records up to txn’s COMMIT record are flushed to disk. → Note that log flushes are sequential, synchronous writes to disk. → Many log records per log page. When the commit succeeds, write a special TXN- END record to log. → This does not need to be flushed immediately. 12 CMU 15-445/645 (Fall 2019) WAL (Tail) Buffer Pool 001:<T1 BEGIN> 002:<T1, A, 1, 2> 003:<T1 COMMIT> 004:<T2 BEGIN> 005:<T2, A, 2, 3> 006:<T3 BEGIN> 007:<CHECKPOINT> 008:<T2 COMMIT> 009:<T3, A, 3, 4> 010:<T3, B, 4, 2> 011:<T3, COMMIT> 012:<T4 BEGIN> 013:<T4, A, 9, 8> 014:<T4, B, 5, 1> 015:<T4 COMMIT> T R A N S A C T I O N C O M M I T 13 WAL Database MasterRecord flushedLSN pageLSN recLSN A=9 B=5 C=2 pageLSN recLSN A=9 B=5 C=2 012:<T4 BEGIN> 013:<T4, A, 9, 8> 014:<T4, B, 5, 1> 015:<T4 COMMIT> ⋮ 099:<T4 TXN-END> flushedLSN = 015 We can trim the in-memory log up to flushedLSN CMU 15-445/645 (Fall 2019) T R A N S A C T I O N A B O R T Aborting a txn is actually a special case of the ARIES undo operation applied to only one transaction. We need to add another field to our log records: → prevLSN: The previous LSN for the txn. → This maintains a linked-list for each txn that makes it easy to walk through its records. 15 CMU 15-445/645 (Fall 2019) WAL (Tail) T R A N S A C T I O N A B O R T 16 WAL Database Buffer Pool MasterRecord flushedLSN pageLSN recLSN A=9 B=5 C=2 pageLSN recLSN A=9 B=5 C=2 012|nil:<T4 BEGIN> 013|012:<T4, A, 9, 8> 014|013:<T4, B, 5, 1> 015|014:<T4 ABORT> ??? 099|098:<T4 TXN-END> LSN | prevLSN Important: Need to record what steps we took to undo the txn. CMU 15-445/645 (Fall 2019) C O M P E N S AT I O N LO G R E C O R D S A CLR describes the actions taken to undo the actions of a previous update record. It has all the fields of an update log record plus the undoNext pointer (the next-to-be-undone LSN). CLRs are added to log like any other record. 17 CMU 15-445/645 (Fall 2019) T R A N S A C T I O N A B O R T C L R E X A M P L E 18TIME LSN prevLSN TxnId Type Object Before After UndoNext 001 nil T1 BEGIN - - - - 002 001 T1 UPDATE A 30 40 - ⋮ 011 002 T1 ABORT - - - - CMU 15-445/645 (Fall 2019) LSN prevLSN TxnId Type Object Before After UndoNext 001 nil T1 BEGIN - - - - 002 001 T1 UPDATE A 30 40 - ⋮ 011 002 T1 ABORT - - - - ⋮ 026 011 T1 CLR-002 A 40 30 001 T R A N S A C T I O N A B O R T C L R E X A M P L E 19TIME The LSN of the next log record to be undone. CMU 15-445/645 (Fall 2019) LSN prevLSN TxnId Type Object Before After UndoNext 001 nil T1 BEGIN - - - - 002 001 T1 UPDATE A 30 40 - ⋮ 011 002 T1 ABORT - - - - ⋮ 026 011 T1 CLR-002 A 40 30 001 027 026 T1 TXN-END - - - nil T R A N S A C T I O N A B O R T C L R E X A M P L E 20TIME CMU 15-445/645 (Fall 2019) A B O R T A LG O R I T H M First write an ABORT record to log for the txn. Then play back the txn's updates in reverse order. For each update record: → Write a CLR entry to the log. → Restore old value. At end, write a TXN-END log record. Notice: CLRs never need to be undone. 21 CMU 15-445/645 (Fall 2019) Log Sequence Numbers Normal Commit & Abort Operations Fuzzy Checkpointing Recovery Algorithm 22 CMU 15-445/645 (Fall 2019) N O N - F U Z Z Y C H E C K P O I N T S The DBMS halts everything when it takes a checkpoint to ensure a consistent snapshot: → Halt the start of any new txns. → Wait until all active txns finish executing. → Flushes dirty pages on disk. This is obviously bad… 23 CMU 15-445/645 (Fall 2019) S L I G H T LY B E T T E R C H E C K P O I N T S Pause modifying txns while the DBMS takes the checkpoint. → Prevent queries from acquiring write latch on table/index pages. → Don't have to wait until all txns finish before taking the checkpoint. We must record internal state as of the beginning of the checkpoint. → Active Transaction Table (ATT) → Dirty Page Table (DPT) 24 Page #1 Page #2 Page #3CheckpointTransactionPage #3 Page #1 Page #1 Page #2 Page #3 CMU 15-445/645 (Fall 2019) A C T I V E T R A N S A C T I O N TA B L E One entry per currently active txn. → txnId: Unique txn identifier. → status: The current \"mode\" of the txn. → lastLSN: Most recent LSN created by txn. Entry removed when txn commits or aborts. Txn Status Codes: → R → Running → C → Committing → U → Candidate for Undo 25 CMU 15-445/645 (Fall 2019) D I R T Y PA G E TA B L E Keep track of which pages in the buffer pool contain changes from uncommitted transactions. One entry per dirty page in the buffer pool: → recLSN: The LSN of the log record that first caused the page to be dirty. 26 CMU 15-445/645 (Fall 2019) S L I G H T LY B E T T E R C H E C K P O I N T S At the first checkpoint, T2 is still running and there are two dirty pages (P11, P22). At the second checkpoint, T3 is active and there are two dirty pages (P11, P33). This still is not ideal because the DBMS must stall txns during checkpoint… 27 WAL <T1 BEGIN> <T2 BEGIN> <T1, A→P11, 100, 120> <T1 COMMIT> <T2, C→P22, 100, 120> <CHECKPOINT ATT={T2}, DPT={P11,P22}> <T3 START> <T2, A→P11, 120, 130> <T2 COMMIT> <T3, B→P33, 200, 400> <CHECKPOINT ATT={T3}, DPT={P11,P33}> <T3, B→P33, 400, 600> CMU 15-445/645 (Fall 2019) F U Z Z Y C H E C K P O I N T S A fuzzy checkpoint is where the DBMS allows active txns to continue the run while the system flushes dirty pages to disk. New log records to track checkpoint boundaries: → CHECKPOINT-BEGIN: Indicates start of checkpoint → CHECKPOINT-END: Contains ATT + DPT. 28 CMU 15-445/645 (Fall 2019) F U Z Z Y C H E C K P O I N T S The LSN of the CHECKPOINT-BEGIN record is written to the database's MasterRecord entry on disk when the checkpoint successfully completes. Any txn that starts after the checkpoint is excluded from the ATT in the CHECKPOINT-END record. 29 WAL <T1 BEGIN> <T2 BEGIN> <T1, A→P11, 100, 120> <T1 COMMIT> <T2, C→P22, 100, 120> <CHECKPOINT-BEGIN> <T3 START> <T2, A→P11, 120, 130> <CHECKPOINT-END ATT={T2}, DPT={P11}> <T2 COMMIT> <T3, B→P33, 200, 400> <CHECKPOINT-BEGIN> <T3, B→P33, 10, 12> <CHECKPOINT-END ATT={T3}, DPT={P33}> CMU 15-445/645 (Fall 2019) A R I E S R E C O V E R Y P H A S E S Phase #1 – Analysis → Read WAL from last checkpoint to identify dirty pages in the buffer pool and active txns at the time of the crash. Phase #2 – Redo → Repeat all actions starting from an appropriate point in the log (even txns that will abort). Phase #3 – Undo → Reverse the actions of txns that did not commit before the crash. 30 CMU 15-445/645 (Fall 2019) A R I E S O V E R V I E W Start from last BEGIN-CHECKPOINT found via MasterRecord. Analysis: Figure out which txns committed or failed since checkpoint. Redo: Repeat all actions. Undo: Reverse effects of failed txns. 31 CRASH! Oldest log record of txn active at crash Smallest recLSN in DPT after AnalysisTIME A 1 R 2 U 3 Start of last checkpoint WAL CMU 15-445/645 (Fall 2019) A N A LY S I S P H A S E Scan log forward from last successful checkpoint. If you find a TXN-END record, remove its corresponding txn from ATT. All other records: → Add txn to ATT with status UNDO. → On commit, change txn status to COMMIT. For UPDATE records: → If page P not in DPT, add P to DPT, set its recLSN=LSN. 32 CMU 15-445/645 (Fall 2019) A N A LY S I S P H A S E At end of the Analysis Phase: → ATT tells the DBMS which txns were active at time of crash. → DPT tells the DBMS which dirty pages might not have made it to disk. 33 CMU 15-445/645 (Fall 2019) A N A LY S I S P H A S E E X A M P L E 34 WAL 010:<CHECKPOINT-BEGIN> ⋮ 020:<T96, A→P33, 10, 15> ⋮ 030:<CHECKPOINT-END ATT={T96,T97}, DPT={P20,P33}> ⋮ 040:<T96 COMMIT> ⋮ 050:<T96 TXN-END> ⋮ CRASH! LSN ATT DPT 010 020 (T96,U) (P33,020) 030 (T96,U), (T97,U) (P33,020), (P20,022) 040 (T96,C), (T97,U) (P33,020), (P20,022) 050 (T97,U) (P33,020), (P20,022) Modify A in page P33 (TxnId, Status) (PageId, RecLSN) CMU 15-445/645 (Fall 2019) R E D O P H A S E The goal is to repeat history to reconstruct state at the moment of the crash: → Reapply all updates (even aborted txns!) and redo CLRs. There techniques that allow the DBMS to avoid unnecessary reads/writes, but we will ignore that in this lecture… 35 CMU 15-445/645 (Fall 2019) R E D O P H A S E Scan forward from the log record containing smallest recLSN in DPT. For each update log record or CLR with a given LSN, redo the action unless: → Affected page is not in DPT, or → Affected page is in DPT but that record's LSN is less than the page's recLSN. 36 CMU 15-445/645 (Fall 2019) R E D O P H A S E To redo an action: → Reapply logged action. → Set pageLSN to log record's LSN. → No additional logging, no forced flushes! At the end of Redo Phase, write TXN-END log records for all txns with status C and remove them from the ATT. 37 CMU 15-445/645 (Fall 2019) U N D O P H A S E Undo all txns that were active at the time of crash and therefore will never commit. → These are all the txns with U status in the ATT after the Analysis Phase. Process them in reverse LSN order using the lastLSN to speed up traversal. Write a CLR for every modification. 38 CMU 15-445/645 (Fall 2019) F U L L E X A M P L E 39 <CHECKPOINT-BEGIN> <CHECKPOINT-END> <T1, A→P5, 1, 2> <T2, B→P3, 2, 3> <T1 ABORT> <CLR: Undo T1 LSN 10> <T1 TXN-END> <T3, C→P1, 4, 5> <T2, D→P5, 6, 7> 00 05 10 20 30 40 45 50 60 prevLSNs LSN LOG X CRASH!TIME CMU 15-445/645 (Fall 2019) F U L L E X A M P L E 40 <CHECKPOINT-BEGIN>, <CHECKPOINT-END> <T1, A→P5, 1, 2> <T2, B→P3, 2, 3> <T1 ABORT> <CLR: Undo T1 LSN 10>, <T1 TXN-END> <T3, C→P1, 4, 5> <T2, D→P5, 6, 7> CRASH! RESTART! 00,05 10 20 30 40,45 50 60 DPT ATT TxnId Status lastLSN T2 U 60 T3 U 50 - - - PageId recLSN P1 50 P3 08 P5 10 flushedLSN LSN LOG X X <CLR: Undo T2 LSN 60, UndoNext 20> <CLR: Undo T3 LSN 50>, <T3 TXN-END> CRASH! RESTART! 70 80,85 Flush dirty pages + WAL to disk! CMU 15-445/645 (Fall 2019) F U L L E X A M P L E 41 <CHECKPOINT-BEGIN>, <CHECKPOINT-END> <T1, A→P5, 1, 2> <T2, B→P3, 2, 3> <T1 ABORT> <CLR: Undo T1 LSN 10>, <T1 TXN-END> <T3, C→P1, 4, 5> <T2, D→P5, 6, 7> CRASH! RESTART! 00,05 10 20 30 40,45 50 60 DPT ATT TxnId Status lastLSN T2 U 70 - - - - - - PageId recLSN P1 50 P3 08 P5 10 flushedLSN LSN LOG X X <CLR: Undo T2 LSN 60, UndoNext 20> <CLR: Undo T3 LSN 50>, <T3 TXN-END> CRASH! RESTART! 70 80,85 90,95 <CLR: Undo T2 LSN 20>, <T2 TXN-END> CMU 15-445/645 (Fall 2019) A D D I T I O N A L C R A S H I S S U E S ( 1 ) What does the DBMS do if it crashes during recovery in the Analysis Phase? → Nothing. Just run recovery again. What does the DBMS do if it crashes during recovery in the Redo Phase? → Again nothing. Redo everything again. 42 CMU 15-445/645 (Fall 2019) A D D I T I O N A L C R A S H I S S U E S ( 2 ) How can the DBMS improve performance during recovery in the Redo Phase? → Assume that it is not going to crash again and flush all changes to disk asynchronously in the background. How can the DBMS improve performance during recovery in the Undo Phase? → Lazily rollback changes before new txns access pages. → Rewrite the application to avoid long-running txns. 43 CMU 15-445/645 (Fall 2019) C O N C L U S I O N Mains ideas of ARIES: → WAL with STEAL/NO-FORCE → Fuzzy Checkpoints (snapshot of dirty page ids) → Redo everything since the earliest dirty page → Undo txns that never commit → Write CLRs when undoing, to survive failures during restarts Log Sequence Numbers: → LSNs identify log records; linked into backwards chains per transaction via prevLSN. → pageLSN allows comparison of data page and log records. 44 CMU 15-445/645 (Fall 2019) N E X T C L A S S You now know how to build a single-node DBMS. So now we can talk about distributed databases! 45","libVersion":"0.2.2","langs":""}