{"path":".obsidian/plugins/text-extractor/cache/d2cd91a608f0e52fe18eb987b3f61839.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 16 Concurrency Control Theory CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Project #3 is due Sun Nov 17th @ 11:59pm. Homework #4 will be released next week. It is due Wed Nov 13th @ 11:59pm. 2 CMU 15-445/645 (Fall 2019) Query Planning Operator Execution Access Methods Buffer Pool Manager Disk Manager C O U R S E S TAT U S A DBMS's concurrency control and recovery components permeate throughout the design of its entire architecture. 3 CMU 15-445/645 (Fall 2019) Concurrency Control Recovery Query Planning Operator Execution Access Methods Buffer Pool Manager Disk Manager C O U R S E S TAT U S A DBMS's concurrency control and recovery components permeate throughout the design of its entire architecture. 3 CMU 15-445/645 (Fall 2019) M O T I VAT I O N We both change the same record in a table at the same time. How to avoid race condition? You transfer $100 between bank accounts but there is a power failure. What is the correct database state? 4 Lost Updates Concurrency Control Durability Recovery CMU 15-445/645 (Fall 2019) C O N C U R R E N C Y C O N T R O L & R E C O V E R Y Valuable properties of DBMSs. Based on concept of transactions with ACID properties. Let’s talk about transactions… 5 CMU 15-445/645 (Fall 2019) T R A N S A C T I O N S A transaction is the execution of a sequence of one or more operations (e.g., SQL queries) on a database to perform some higher-level function. It is the basic unit of change in a DBMS: → Partial transactions are not allowed! 6 CMU 15-445/645 (Fall 2019) T R A N S A C T I O N E X A M P L E Move $100 from Andy’ bank account to his promotor's account. Transaction: → Check whether Andy has $100. → Deduct $100 from his account. → Add $100 to his promotor account. 7 CMU 15-445/645 (Fall 2019) S T R AW M A N S Y S T E M Execute each txn one-by-one (i.e., serial order) as they arrive at the DBMS. → One and only one txn can be running at the same time in the DBMS. Before a txn starts, copy the entire database to a new file and make all changes to that file. → If the txn completes successfully, overwrite the original file with the new one. → If the txn fails, just remove the dirty copy. 8 CMU 15-445/645 (Fall 2019) P R O B L E M S TAT E M E N T A (potentially) better approach is to allow concurrent execution of independent transactions. Why do we want that? → Better utilization/throughput → Increased response times to users. But we also would like: → Correctness → Fairness 9 CMU 15-445/645 (Fall 2019) T R A N S A C T I O N S Hard to ensure correctness… → What happens if Andy only has $100 and tries to pay off two promotors at the same time? Hard to execute quickly… → What happens if Andy tries to pay off his gambling debts at the exact same time? 10 CMU 15-445/645 (Fall 2019) P R O B L E M S TAT E M E N T Arbitrary interleaving of operations can lead to: → Temporary Inconsistency (ok, unavoidable) → Permanent Inconsistency (bad!) We need formal correctness criteria to determine whether an interleaving is valid. 11 CMU 15-445/645 (Fall 2019) D E F I N I T I O N S A txn may carry out many operations on the data retrieved from the database However, the DBMS is only concerned about what data is read/written from/to the database. → Changes to the \"outside world\" are beyond the scope of the DBMS. 12 CMU 15-445/645 (Fall 2019) F O R M A L D E F I N I T I O N S Database: A fixed set of named data objects (e.g., A, B, C, …). → We do not need to define what these objects are now. Transaction: A sequence of read and write operations ( R(A), W(B), …) → DBMS’s abstract view of a user program 13 CMU 15-445/645 (Fall 2019) T R A N S A C T I O N S I N S Q L A new txn starts with the BEGIN command. The txn stops with either COMMIT or ABORT: → If commit, the DBMS either saves all the txn's changes or aborts it. → If abort, all changes are undone so that it’s like as if the txn never executed at all. Abort can be either self-inflicted or caused by the DBMS. 14 CMU 15-445/645 (Fall 2019) C O R R E C T N E S S C R I T E R I A : A C I D Atomicity: All actions in the txn happen, or none happen. Consistency: If each txn is consistent and the DB starts consistent, then it ends up consistent. Isolation: Execution of one txn is isolated from that of other txns. Durability: If a txn commits, its effects persist. 15 CMU 15-445/645 (Fall 2019) C O R R E C T N E S S C R I T E R I A : A C I D Atomicity: “all or nothing” Consistency: “it looks correct to me” Isolation: “as if alone” Durability: “survive failures” 16 CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A Atomicity Consistency Isolation Durability 17 CMU 15-445/645 (Fall 2019) AT O M I C I T Y O F T R A N S A C T I O N S Two possible outcomes of executing a txn: → Commit after completing all its actions. → Abort (or be aborted by the DBMS) after executing some actions. DBMS guarantees that txns are atomic. → From user’s point of view: txn always either executes all its actions, or executes no actions at all. 18A CMU 15-445/645 (Fall 2019) AT O M I C I T Y O F T R A N S A C T I O N S Scenario #1: → We take $100 out of Andy's account but then the DBMS aborts the txn before we transfer it. Scenario #2: → We take $100 out of Andy’s account but then there is a power failure before we transfer it. What should be the correct state of Andy’s account after both txns abort? 19A CMU 15-445/645 (Fall 2019) M E C H A N I S M S F O R E N S U R I N G AT O M I C I T Y Approach #1: Logging → DBMS logs all actions so that it can undo the actions of aborted transactions. → Maintain undo records both in memory and on disk. → Think of this like the black box in airplanes… Logging is used by almost every DBMS. → Audit Trail → Efficiency Reasons 20A CMU 15-445/645 (Fall 2019) M E C H A N I S M S F O R E N S U R I N G AT O M I C I T Y Approach #2: Shadow Paging → DBMS makes copies of pages and txns make changes to those copies. Only when the txn commits is the page made visible to others. → Originally from System R. Few systems do this: → CouchDB → LMDB (OpenLDAP) 21A CMU 15-445/645 (Fall 2019) M E C H A N I S M S F O R E N S U R I N G AT O M I C I T Y Approach #2: Shadow Paging → DBMS makes copies of pages and txns make changes to those copies. Only when the txn commits is the page made visible to others. → Originally from System R. Few systems do this: → CouchDB → LMDB (OpenLDAP) 21A CMU 15-445/645 (Fall 2019) C O N S I S T E N C Y The \"world\" represented by the database is logically correct. All questions asked about the data are given logically correct answers. Database Consistency Transaction Consistency 22C CMU 15-445/645 (Fall 2019) D ATA B A S E C O N S I S T E N C Y The database accurately models the real world and follows integrity constraints. Transactions in the future see the effects of transactions committed in the past inside of the database. 23C CMU 15-445/645 (Fall 2019) T R A N S A C T I O N C O N S I S T E N C Y If the database is consistent before the transaction starts (running alone), it will also be consistent after. Transaction consistency is the application’s responsibility. → We won’t discuss this further… 24C CMU 15-445/645 (Fall 2019) I S O L AT I O N O F T R A N S A C T I O N S Users submit txns, and each txn executes as if it was running by itself. → Easier programming model to reason about. But the DBMS achieves concurrency by interleaving the actions (reads/writes of DB objects) of txns. We need a way to interleave txns but still make it appear as if they ran one-at-a-time. 25I CMU 15-445/645 (Fall 2019) M E C H A N I S M S F O R E N S U R I N G I S O L AT I O N A concurrency control protocol is how the DBMS decides the proper interleaving of operations from multiple transactions. Two categories of protocols: → Pessimistic: Don’t let problems arise in the first place. → Optimistic: Assume conflicts are rare, deal with them after they happen. 26I CMU 15-445/645 (Fall 2019) E X A M P L E Assume at first A and B each have $1000. T1 transfers $100 from A’s account to B’s T2 credits both accounts with 6% interest. 27 BEGIN A=A-100 B=B+100 COMMIT T1 BEGIN A=A*1.06 B=B*1.06 COMMIT T2 I CMU 15-445/645 (Fall 2019) E X A M P L E Assume at first A and B each have $1000. What are the possible outcomes of running T1 and T2? 28 BEGIN A=A-100 B=B+100 COMMIT BEGIN A=A*1.06 B=B*1.06 COMMIT T1 T2 I CMU 15-445/645 (Fall 2019) E X A M P L E Assume at first A and B each have $1000. What are the possible outcomes of running T1 and T2? Many! But A+B should be: → $2000*1.06=$2120 There is no guarantee that T1 will execute before T2 or vice-versa, if both are submitted together. But the net effect must be equivalent to these two transactions running serially in some order. 29I CMU 15-445/645 (Fall 2019) E X A M P L E Legal outcomes: → A=954, B=1166 → A=960, B=1160 The outcome depends on whether T1 executes before T2 or vice versa. 30 A+B=$2120 A+B=$2120 I CMU 15-445/645 (Fall 2019) S E R I A L E X E C U T I O N E X A M P L E 31 ≡ A=954, B=1166 A=960, B=1160TIME BEGIN A=A-100 B=B+100 COMMIT T1 T2 BEGIN A=A*1.06 B=B*1.06 COMMIT BEGIN A=A-100 B=B+100 COMMIT T1 T2 BEGIN A=A*1.06 B=B*1.06 COMMIT Schedule Schedule I A+B=$2120 CMU 15-445/645 (Fall 2019) I N T E R L E AV I N G T R A N S A C T I O N S We interleave txns to maximize concurrency. → Slow disk/network I/O. → Multi-core CPUs. When one txn stalls because of a resource (e.g., page fault), another txn can continue executing and make forward progress. 32I CMU 15-445/645 (Fall 2019) I N T E R L E AV I N G E X A M P L E ( G O O D ) 33 BEGIN A=A-100 B=B+100 COMMIT T1 T2 BEGIN A=A*1.06 B=B*1.06 COMMITTIME Schedule A=954, B=1166 ≡ BEGIN A=A-100 B=B+100 COMMIT T1 T2 BEGIN A=A*1.06 B=B*1.06 COMMIT Schedule A=960, B=1160 I CMU 15-445/645 (Fall 2019) I N T E R L E AV I N G E X A M P L E ( G O O D ) 33 BEGIN A=A-100 B=B+100 COMMIT T1 T2 BEGIN A=A*1.06 B=B*1.06 COMMITTIME Schedule A=954, B=1166 ≡ BEGIN A=A-100 B=B+100 COMMIT T1 T2 BEGIN A=A*1.06 B=B*1.06 COMMIT Schedule A=960, B=1160 I A+B=$2120 CMU 15-445/645 (Fall 2019) I N T E R L E AV I N G E X A M P L E ( B A D ) 34 ≢ A=954, B=1166 or A=960, B=1160 BEGIN A=A-100 B=B+100 COMMIT BEGIN A=A*1.06 B=B*1.06 COMMIT The bank is missing $106!TIME Schedule T1 T2 A=954, B=1060 I A+B=$2014 CMU 15-445/645 (Fall 2019) I N T E R L E AV I N G E X A M P L E ( B A D ) 35 BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN A=A-100 B=B+100 COMMIT BEGIN A=A*1.06 B=B*1.06 COMMITTIME Schedule DBMS View T1 T2 T1 T2 A=954, B=1060 I A+B=$2014 CMU 15-445/645 (Fall 2019) C O R R E C T N E S S How do we judge whether a schedule is correct? If the schedule is equivalent to some serial execution. 36I CMU 15-445/645 (Fall 2019) F O R M A L P R O P E R T I E S O F S C H E D U L E S Serial Schedule → A schedule that does not interleave the actions of different transactions. Equivalent Schedules → For any database state, the effect of executing the first schedule is identical to the effect of executing the second schedule. → Doesn't matter what the arithmetic operations are! 37I CMU 15-445/645 (Fall 2019) F O R M A L P R O P E R T I E S O F S C H E D U L E S Serializable Schedule → A schedule that is equivalent to some serial execution of the transactions. If each transaction preserves consistency, every serializable schedule preserves consistency. 38I CMU 15-445/645 (Fall 2019) F O R M A L P R O P E R T I E S O F S C H E D U L E S Serializability is a less intuitive notion of correctness compared to txn initiation time or commit order, but it provides the DBMS with additional flexibility in scheduling operations. More flexibility means better parallelism. 39I CMU 15-445/645 (Fall 2019) C O N F L I C T I N G O P E R AT I O N S We need a formal notion of equivalence that can be implemented efficiently based on the notion of \"conflicting\" operations Two operations conflict if: → They are by different transactions, → They are on the same object and at least one of them is a write. 40I CMU 15-445/645 (Fall 2019) I N T E R L E AV E D E X E C U T I O N A N O M A L I E S Read-Write Conflicts (R-W) Write-Read Conflicts (W-R) Write-Write Conflicts (W-W) 41I CMU 15-445/645 (Fall 2019) R E A D -W R I T E C O N F L I C T S Unrepeatable Reads 42 BEGIN R(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT $10 $10 $19 $19 T1 T2 I CMU 15-445/645 (Fall 2019) W R I T E- R E A D C O N F L I C T S Reading Uncommitted Data (\"Dirty Reads\") 43 BEGIN R(A) W(A) ABORT T1 T2 BEGIN R(A) W(A) COMMIT $10 $12 $12 $14 I CMU 15-445/645 (Fall 2019) W R I T E-W R I T E C O N F L I C T S Overwriting Uncommitted Data 44 BEGIN W(A) W(B) COMMIT BEGIN W(A) W(B) COMMIT Andy $19 T1 T2 $10 Bieber I CMU 15-445/645 (Fall 2019) F O R M A L P R O P E R T I E S O F S C H E D U L E S Given these conflicts, we now can understand what it means for a schedule to be serializable. → This is to check whether schedules are correct. → This is not how to generate a correct schedule. There are different levels of serializability: → Conflict Serializability → View Serializability 45 Most DBMSs try to support this. No DBMS can do this. I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B L E S C H E D U L E S Two schedules are conflict equivalent iff: → They involve the same actions of the same transactions, and → Every pair of conflicting actions is ordered the same way. Schedule S is conflict serializable if: → S is conflict equivalent to some serial schedule. 46I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N Schedule S is conflict serializable if you are able to transform S into a serial schedule by swapping consecutive non-conflicting operations of different transactions. 47I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT R(B) R(A) W(A) W(B)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT W(A) R(A) R(B) W(B)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT W(A) R(A) R(B) W(B)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT W(A) R(A) R(B) W(B)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT W(A) R(A) R(B) W(B)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT R(A) R(B) W(B) W(A)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT R(A) R(B) W(B) W(A)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT R(B) W(A) R(A) W(B)TIME Schedule T1 T2 I CMU 15-445/645 (Fall 2019) C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 48 ≡ BEGIN R(A) W(A) COMMIT BEGIN R(B) W(B) COMMIT BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(A) W(A) R(B) W(B) COMMIT R(B) W(A) R(A) W(B)TIME Schedule T1 T2 Serial Schedule T1 T2 I CMU 15-445/645 (Fall 2019) Schedule T1 T2 Serial Schedule T1 T2 C O N F L I C T S E R I A L I Z A B I L I T Y I N T U I T I O N 49 BEGIN R(A) W(A) COMMIT BEGIN R(A) W(A) COMMIT BEGIN R(A) W(A) COMMIT BEGIN R(A) W(A) COMMIT≢TIME I CMU 15-445/645 (Fall 2019) S E R I A L I Z A B I L I T Y Swapping operations is easy when there are only two txns in the schedule. It's cumbersome when there are many txns. Are there any faster algorithms to figure this out other than transposing operations? 50I CMU 15-445/645 (Fall 2019) D E P E N D E N C Y G R A P H S One node per txn. Edge from Ti to Tj if: → An operation Oi of Ti conflicts with an operation Oj of Tj and → Oi appears earlier in the schedule than Oj. Also known as a precedence graph. A schedule is conflict serializable iff its dependency graph is acyclic. 51 Ti Tj Dependency Graph I CMU 15-445/645 (Fall 2019) E X A M P L E # 1 52 BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(A) W(A) R(B) W(B) COMMIT T1 T2 A Schedule T1 T2TIME Dependency Graph I CMU 15-445/645 (Fall 2019) E X A M P L E # 1 52 BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(A) W(A) R(B) W(B) COMMIT T1 T2 A B The cycle in the graph reveals the problem. The output of T1 depends on T2, and vice-versa. Schedule T1 T2TIME Dependency Graph I CMU 15-445/645 (Fall 2019) Dependency Graph E X A M P L E # 2 T H R E E S O M E 54 BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(B) W(B) COMMIT T1 T2 BEGIN R(A) W(A) COMMIT T3TIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph E X A M P L E # 2 T H R E E S O M E 54 BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(B) W(B) COMMIT T1 T2 BEGIN R(A) W(A) COMMIT T3 BTIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph E X A M P L E # 2 T H R E E S O M E 54 BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(B) W(B) COMMIT T1 T2 BEGIN R(A) W(A) COMMIT T3 B ATIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph E X A M P L E # 2 T H R E E S O M E 54 Is this equivalent to a serial execution? BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(B) W(B) COMMIT T1 T2 BEGIN R(A) W(A) COMMIT T3 B ATIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph E X A M P L E # 2 T H R E E S O M E 54 Is this equivalent to a serial execution? BEGIN R(A) W(A) R(B) W(B) COMMIT BEGIN R(B) W(B) COMMIT T1 T2 BEGIN R(A) W(A) COMMIT T3 B ATIME Schedule T1 T2 T3 I Yes (T2, T1, T3) → Notice that T3 should go after T2, although it starts before it! CMU 15-445/645 (Fall 2019) E X A M P L E # 3 I N C O N S I S T E N T A N A LY S I S 55 BEGIN R(A) A = A-10 W(A) R(B) B = B+10 W(B) COMMIT BEGIN R(A) sum = A R(B) sum += B ECHO sum COMMIT T1 T2TIME Schedule T1 T2 Dependency Graph I CMU 15-445/645 (Fall 2019) E X A M P L E # 3 I N C O N S I S T E N T A N A LY S I S 55 BEGIN R(A) A = A-10 W(A) R(B) B = B+10 W(B) COMMIT BEGIN R(A) sum = A R(B) sum += B ECHO sum COMMIT T1 T2TIME Schedule T1 T2 Dependency Graph I CMU 15-445/645 (Fall 2019) E X A M P L E # 3 I N C O N S I S T E N T A N A LY S I S 55 BEGIN R(A) A = A-10 W(A) R(B) B = B+10 W(B) COMMIT BEGIN R(A) sum = A R(B) sum += B ECHO sum COMMIT T1 T2TIME Schedule T1 T2 Dependency Graph I CMU 15-445/645 (Fall 2019) E X A M P L E # 3 I N C O N S I S T E N T A N A LY S I S 55 BEGIN R(A) A = A-10 W(A) R(B) B = B+10 W(B) COMMIT BEGIN R(A) sum = A R(B) sum += B ECHO sum COMMIT T1 T2TIME Schedule T1 T2 Dependency Graph A I CMU 15-445/645 (Fall 2019) E X A M P L E # 3 I N C O N S I S T E N T A N A LY S I S 55 BEGIN R(A) A = A-10 W(A) R(B) B = B+10 W(B) COMMIT BEGIN R(A) sum = A R(B) sum += B ECHO sum COMMIT T1 T2TIME Schedule T1 T2 Dependency Graph A B I CMU 15-445/645 (Fall 2019) E X A M P L E # 3 I N C O N S I S T E N T A N A LY S I S 55 BEGIN R(A) A = A-10 W(A) R(B) B = B+10 W(B) COMMIT BEGIN R(A) sum = A R(B) sum += B ECHO sum COMMIT T1 T2 Is it possible to modify only the application logic so that schedule produces a \"correct\" result but is still not conflict serializable?TIME Schedule T1 T2 Dependency Graph A B I CMU 15-445/645 (Fall 2019) E X A M P L E # 3 I N C O N S I S T E N T A N A LY S I S 55 BEGIN R(A) A = A-10 W(A) R(B) B = B+10 W(B) COMMIT BEGIN R(A) sum = A R(B) sum += B ECHO sum COMMIT T1 T2 Is it possible to modify only the application logic so that schedule produces a \"correct\" result but is still not conflict serializable?TIME Schedule T1 T2 Dependency Graph A Bif(A≥0): cnt++ if(B≥0): cnt++ ECHO cnt I CMU 15-445/645 (Fall 2019) V I E W S E R I A L I Z A B I L I T Y Alternative (weaker) notion of serializability. Schedules S1 and S2 are view equivalent if: → If T1 reads initial value of A in S1, then T1 also reads initial value of A in S2. → If T1 reads value of A written by T2 in S1, then T1 also reads value of A written by T2 in S2. → If T1 writes final value of A in S1, then T1 also writes final value of A in S2. 56I CMU 15-445/645 (Fall 2019) Dependency Graph V I E W S E R I A L I Z A B I L I T Y 57 BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT A T1 T2 T3TIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph V I E W S E R I A L I Z A B I L I T Y 57 BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT A A T1 T2 T3TIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph V I E W S E R I A L I Z A B I L I T Y 57 BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT A A A T1 T2 T3TIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph V I E W S E R I A L I Z A B I L I T Y 57 BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT A A A A T1 T2 T3TIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) Dependency Graph V I E W S E R I A L I Z A B I L I T Y 57 BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT A A AA A T1 T2 T3TIME Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) V I E W S E R I A L I Z A B I L I T Y 58 BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT ≡ VIEWTIME Schedule T1 T2 T3 Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) V I E W S E R I A L I Z A B I L I T Y 58 BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT BEGIN R(A) W(A) COMMIT BEGIN W(A) COMMIT BEGIN W(A) COMMIT ≡ VIEWTIME Schedule T1 T2 T3 Allows all conflict serializable schedules + \"blind writes\" Schedule T1 T2 T3 I CMU 15-445/645 (Fall 2019) S E R I A L I Z A B I L I T Y View Serializability allows for (slightly) more schedules than Conflict Serializability does. → But is difficult to enforce efficiently. Neither definition allows all schedules that you would consider \"serializable\". → This is because they don’t understand the meanings of the operations or the data (recall example #3) 59I CMU 15-445/645 (Fall 2019) S E R I A L I Z A B I L I T Y In practice, Conflict Serializability is what systems support because it can be enforced efficiently. To allow more concurrency, some special cases get handled separately at the application level. 60I CMU 15-445/645 (Fall 2019) All Schedules U N I V E R S E O F S C H E D U L E S 61 View Serializable Conflict Serializable Serial I CMU 15-445/645 (Fall 2019) T R A N S A C T I O N D U R A B I L I T Y All of the changes of committed transactions should be persistent. → No torn updates. → No changes from failed transactions. The DBMS can use either logging or shadow paging to ensure that all changes are durable. 62D CMU 15-445/645 (Fall 2019) A C I D P R O P E R T I E S Atomicity: All actions in the txn happen, or none happen. Consistency: If each txn is consistent and the DB starts consistent, then it ends up consistent. Isolation: Execution of one txn is isolated from that of other txns. Durability: If a txn commits, its effects persist. 63 CMU 15-445/645 (Fall 2019) C O N C L U S I O N Concurrency control and recovery are among the most important functions provided by a DBMS. Concurrency control is automatic → System automatically inserts lock/unlock requests and schedules actions of different txns. → Ensures that resulting execution is equivalent to executing the txns one after the other in some order. 64 CMU 15-445/645 (Fall 2019) C O N C L U S I O N Concurrency control and recovery are among the most important functions provided by a DBMS. Concurrency control is automatic → System automatically inserts lock/unlock requests and schedules actions of different txns. → Ensures that resulting execution is equivalent to executing the txns one after the other in some order. 64 CMU 15-445/645 (Fall 2019) C O N C L U S I O N Concurrency control and recovery are among the most important functions provided by a DBMS. Concurrency control is automatic → System automatically inserts lock/unlock requests and schedules actions of different txns. → Ensures that resulting execution is equivalent to executing the txns one after the other in some order. 64 CMU 15-445/645 (Fall 2019) P R O J E C T # 3 You will build a query execution engine in your DBMS. 65 R S R.id=S.id value>100 MAX(R.val) ⨝ s γ SELECT MAX(R.val) FROM R JOIN S ON R.id = S.id WHERE S.value > 100 AggregationExecutor HashJoinExecutor SeqScanExecutor SeqScanExecutor Next() Next() Next() CMU 15-445/645 (Fall 2019) P R O J E C T # 3 TA S K S Install Tables in Catalog Plan Node Executors → Insert → Sequential Scan → Hash Join → Hash Aggregation 66 https://15445.courses.cs.cmu.edu/fall2019/project2/ CMU 15-445/645 (Fall 2019) D E V E LO P M E N T H I N T S You do not need a working Linear Probe Hash Table to complete Tasks #1 and #2. Implement the insert executor first. You do not need to worry about transactions. Gradescope is for meant for grading, not debugging. Write your own local tests. 67 CMU 15-445/645 (Fall 2019) T H I N G S T O N O T E Do not change any file other than the ones that you submit to Gradescope. Rebase on top of the latest BusTub master branch. Post your questions on Piazza or come to TA office hours. 68 CMU 15-445/645 (Fall 2019) P L A G I A R I S M WA R N I N G Your project implementation must be your own work. → You may not copy source code from other groups or the web. → Do not publish your implementation on Github. Plagiarism will not be tolerated. See CMU's Policy on Academic Integrity for additional information. 69 CMU 15-445/645 (Fall 2019) N E X T C L A S S Two-Phase Locking Isolation Levels 70","libVersion":"0.2.2","langs":""}