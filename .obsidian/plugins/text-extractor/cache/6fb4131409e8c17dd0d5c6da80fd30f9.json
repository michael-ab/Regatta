{"path":".obsidian/plugins/text-extractor/cache/6fb4131409e8c17dd0d5c6da80fd30f9.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 05 Buffer Pools CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Homework #1 is due TODAY @ 11:59pm Project #1 is due Fri Sept 26th @ 11:59pm 2 CMU 15-445/645 (Fall 2019) D ATA B A S E W O R K LO A D S On-Line Transaction Processing (OLTP) → Fast operations that only read/update a small amount of data each time. On-Line Analytical Processing (OLAP) → Complex queries that read a lot of data to compute aggregates. Hybrid Transaction + Analytical Processing → OLTP + OLAP together on the same database instance 3 CMU 15-445/645 (Fall 2019) B I F U R C AT E D E N V I R O N M E N T 4 Extract Transform Load OLAP Data WarehouseOLTP Data Silos Analytical QueriesTransactions CMU 15-445/645 (Fall 2019) B I F U R C AT E D E N V I R O N M E N T 4 Extract Transform Load OLAP Data Warehouse Analytical Queries Transactions HTAP Database CMU 15-445/645 (Fall 2019) D ATA B A S E S T O R A G E Problem #1: How the DBMS represents the database in files on disk. Problem #2: How the DBMS manages its memory and move data back-and-forth from disk. 5 CMU 15-445/645 (Fall 2019) D ATA B A S E S T O R A G E Spatial Control: → Where to write pages on disk. → The goal is to keep pages that are used together often as physically close together as possible on disk. Temporal Control: → When to read pages into memory, and when to write them to disk. → The goal is minimize the number of stalls from having to read data from disk. 6 CMU 15-445/645 (Fall 2019) D I S K- O R I E N T E D D B M S 7 Disk MemoryDatabase File 1 HeaderDirectory 2 Header 3 Header … PagesBuffer Pool 2 Header 4 Header 5 Header Execution Engine Get page #2 Directory Pointer to page #2 CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A Buffer Pool Manager Replacement Policies Other Memory Pools 8 CMU 15-445/645 (Fall 2019) B U F F E R P O O L O R G A N I Z AT I O N Memory region organized as an array of fixed-size pages. An array entry is called a frame. When the DBMS requests a page, an exact copy is placed into one of these frames. 9 Buffer Pool frame1 frame2 frame3 frame4 On-Disk File page1 page2 page3 page4 CMU 15-445/645 (Fall 2019) B U F F E R P O O L O R G A N I Z AT I O N Memory region organized as an array of fixed-size pages. An array entry is called a frame. When the DBMS requests a page, an exact copy is placed into one of these frames. 9 Buffer Pool frame1 frame2 frame3 frame4 page1 On-Disk File page1 page2 page3 page4 CMU 15-445/645 (Fall 2019) B U F F E R P O O L O R G A N I Z AT I O N Memory region organized as an array of fixed-size pages. An array entry is called a frame. When the DBMS requests a page, an exact copy is placed into one of these frames. 9 Buffer Pool frame1 frame2 frame3 frame4 page1 page3 On-Disk File page1 page2 page3 page4 CMU 15-445/645 (Fall 2019) B U F F E R P O O L M E TA - D ATA The page table keeps track of pages that are currently in memory. Also maintains additional meta-data per page: → Dirty Flag → Pin/Reference Counter 10 page1 page2 page3 page4 On-Disk File Buffer Pool frame1 frame2 frame3 frame4 page1 page3 Page Table page1 page3 CMU 15-445/645 (Fall 2019) B U F F E R P O O L M E TA - D ATA The page table keeps track of pages that are currently in memory. Also maintains additional meta-data per page: → Dirty Flag → Pin/Reference Counter 10 page1 page2 page3 page4 On-Disk File Buffer Pool frame1 frame2 frame3 frame4 page1 page3 Page Table page1 page3 CMU 15-445/645 (Fall 2019) B U F F E R P O O L M E TA - D ATA The page table keeps track of pages that are currently in memory. Also maintains additional meta-data per page: → Dirty Flag → Pin/Reference Counter 10 page1 page2 page3 page4 On-Disk File Buffer Pool frame1 frame2 frame3 frame4 page1 page3 Page Table page1 page3 CMU 15-445/645 (Fall 2019) B U F F E R P O O L M E TA - D ATA The page table keeps track of pages that are currently in memory. Also maintains additional meta-data per page: → Dirty Flag → Pin/Reference Counter 10 page1 page2 page3 page4 On-Disk File Buffer Pool frame1 frame2 frame3 frame4 page1 page3 Page Table page1 page3 page2 CMU 15-445/645 (Fall 2019) B U F F E R P O O L M E TA - D ATA The page table keeps track of pages that are currently in memory. Also maintains additional meta-data per page: → Dirty Flag → Pin/Reference Counter 10 page1 page2 page3 page4 On-Disk File Buffer Pool frame1 frame2 frame3 frame4 page1 page3 Page Table page1 page3 page2 page2 CMU 15-445/645 (Fall 2019) LO C K S V S . L AT C H E S Locks: → Protects the database's logical contents from other transactions. → Held for transaction duration. → Need to be able to rollback changes. Latches: → Protects the critical sections of the DBMS's internal data structure from other threads. → Held for operation duration. → Do not need to be able to rollback changes. 11 ←Mutex CMU 15-445/645 (Fall 2019) PA G E TA B L E V S . PA G E D I R E C T O R Y The page directory is the mapping from page ids to page locations in the database files. → All changes must be recorded on disk to allow the DBMS to find on restart. The page table is the mapping from page ids to a copy of the page in buffer pool frames. → This is an in-memory data structure that does not need to be stored on disk. 12 CMU 15-445/645 (Fall 2019) A L LO C AT I O N P O L I C I E S Global Policies: → Make decisions for all active txns. Local Policies: → Allocate frames to a specific txn without considering the behavior of concurrent txns. → Still need to support sharing pages. 13 CMU 15-445/645 (Fall 2019) B U F F E R P O O L O P T I M I Z AT I O N S Multiple Buffer Pools Pre-Fetching Scan Sharing Buffer Pool Bypass 14 CMU 15-445/645 (Fall 2019) M U LT I P L E B U F F E R P O O L S The DBMS does not always have a single buffer pool for the entire system. → Multiple buffer pool instances → Per-database buffer pool → Per-page type buffer pool Helps reduce latch contention and improve locality. 15 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G The DBMS can also prefetch pages based on a query plan. → Sequential Scans → Index Scans 17 Buffer Pool page0 Disk Pages page0 page1 page2 page3 page4 page5 Q1 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G The DBMS can also prefetch pages based on a query plan. → Sequential Scans → Index Scans 17 Buffer Pool page0 page1 Disk Pages page0 page1 page2 page3 page4 page5 Q1 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G The DBMS can also prefetch pages based on a query plan. → Sequential Scans → Index Scans 17 Buffer Pool page0 page1 Disk Pages page0 page1 page2 page3 page4 page5 Q1 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G The DBMS can also prefetch pages based on a query plan. → Sequential Scans → Index Scans 17 Buffer Pool page1 page2 Disk Pages page0 page1 page2 page3 page4 page5 Q1 page3 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G The DBMS can also prefetch pages based on a query plan. → Sequential Scans → Index Scans 17 Buffer Pool page1 page2 Disk Pages page0 page1 page2 page3 page4 page5 Q1 page3 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G The DBMS can also prefetch pages based on a query plan. → Sequential Scans → Index Scans 17 Buffer Pool Disk Pages page0 page1 page2 page3 page4 page5Q1 page3 page4 page5 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G 18 Buffer Pool Disk Pages index-page0 index-page1 index-page2 index-page3 index-page4 index-page5 SELECT * FROM A WHERE val BETWEEN 100 AND 250 Q1 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G 18 Buffer Pool Disk Pages index-page0 index-page1 index-page2 index-page3 index-page4 index-page5 index-page0 index-page4index-page1 index-page2 index-page5index-page3 index-page6 0 99 100 199 200 299 300 399 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G 18 Buffer Pool index-page0 Disk Pages index-page0 index-page1 index-page2 index-page3 index-page4 index-page5 Q1 index-page0 index-page4index-page1 index-page2 index-page5index-page3 index-page6 0 99 100 199 200 299 300 399 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G 18 Buffer Pool index-page0 index-page1 Disk Pages index-page0 index-page1 index-page2 index-page3 index-page4 index-page5 Q1 index-page0 index-page4index-page1 index-page2 index-page5index-page3 index-page6 0 99 100 199 200 299 300 399 CMU 15-445/645 (Fall 2019) P R E- F E T C H I N G 18 Buffer Pool index-page0 index-page1 Disk Pages index-page0 index-page1 index-page2 index-page3 index-page4 index-page5 Q1 index-page0 index-page4index-page1 index-page2 index-page5index-page3 index-page6 0 99 100 199 200 299 300 399 CMU 15-445/645 (Fall 2019) S C A N S H A R I N G Queries can reuse data retrieved from storage or operator computations. → This is different from result caching. Allow multiple queries to attach to a single cursor that scans a table. → Queries do not have to be the same. → Can also share intermediate results. 19 CMU 15-445/645 (Fall 2019) S C A N S H A R I N G If a query starts a scan and if there one already doing this, then the DBMS will attach to the second query's cursor. → The DBMS keeps track of where the second query joined with the first so that it can finish the scan when it reaches the end of the data structure. Fully supported in IBM DB2 and MSSQL. Oracle only supports cursor sharing for identical queries. 20 CMU 15-445/645 (Fall 2019) Buffer Pool page0 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 Q1 CMU 15-445/645 (Fall 2019) Buffer Pool page0 page1 page2 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 Q1 CMU 15-445/645 (Fall 2019) Buffer Pool page0 page1 page2 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 Q1 CMU 15-445/645 (Fall 2019) Buffer Pool page1 page2 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 Q1page3 CMU 15-445/645 (Fall 2019) Buffer Pool page1 page2 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 SELECT AVG(val) FROM AQ2 Q1page3 Q2 CMU 15-445/645 (Fall 2019) Buffer Pool page1 page2 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 SELECT AVG(val) FROM AQ2 Q1page3 Q2 CMU 15-445/645 (Fall 2019) Buffer Pool S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 SELECT AVG(val) FROM AQ2 Q1 page3 Q2 page4 page5 CMU 15-445/645 (Fall 2019) Buffer Pool S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 SELECT AVG(val) FROM AQ2 page3 Q2 page4 page5 CMU 15-445/645 (Fall 2019) Buffer Pool page0 page1 page2 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 SELECT AVG(val) FROM AQ2 Q2 CMU 15-445/645 (Fall 2019) Buffer Pool page0 page1 page2 S C A N S H A R I N G 21 Disk Pages page0 page1 page2 page3 page4 page5 SELECT SUM(val) FROM AQ1 Q2 SELECT AVG(val) FROM A LIMIT 100Q2 CMU 15-445/645 (Fall 2019) B U F F E R P O O L B Y PA S S The sequential scan operator will not store fetched pages in the buffer pool to avoid overhead. → Memory is local to running query. → Works well if operator needs to read a large sequence of pages that are contiguous on disk. → Can also be used for temporary data (sorting, joins). Called \"Light Scans\" in Informix. 22 CMU 15-445/645 (Fall 2019) O S PA G E C A C H E Most disk operations go through the OS API. Unless you tell it not to, the OS maintains its own filesystem cache. Most DBMSs use direct I/O (O_DIRECT)to bypass the OS's cache. → Redundant copies of pages. → Different eviction policies. Demo: Postgres 23 CMU 15-445/645 (Fall 2019) B U F F E R R E P L A C E M E N T P O L I C I E S When the DBMS needs to free up a frame to make room for a new page, it must decide which page to evict from the buffer pool. Goals: → Correctness → Accuracy → Speed → Meta-data overhead 24 CMU 15-445/645 (Fall 2019) L E A S T- R E C E N T LY U S E D Maintain a timestamp of when each page was last accessed. When the DBMS needs to evict a page, select the one with the oldest timestamp. → Keep the pages in sorted order to reduce the search time on eviction. 25 CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=0 ref=0 ref=0 ref=0 CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=1 ref=0 ref=0 ref=0 CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=1 ref=0 ref=0 ref=0 CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=0 ref=0 ref=0 ref=0 CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=0 ref=0 ref=0 ref=0 X CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=0 ref=0 ref=0 ref=0 page5 CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=0 ref=0 ref=1 ref=1 page5 CMU 15-445/645 (Fall 2019) C LO C K Approximation of LRU without needing a separate timestamp per page. → Each page has a reference bit. → When a page is accessed, set to 1. Organize the pages in a circular buffer with a \"clock hand\": → Upon sweeping, check if a page's bit is set to 1. → If yes, set to zero. If no, then evict. 26 page1 page3 page4 page2 ref=0 ref=0 ref=0 ref=0 page5 X CMU 15-445/645 (Fall 2019) P R O B L E M S LRU and CLOCK replacement policies are susceptible to sequential flooding. → A query performs a sequential scan that reads every page. → This pollutes the buffer pool with pages that are read once and then never again. The most recently used page is actually the most unneeded page. 27 CMU 15-445/645 (Fall 2019) Buffer Pool page0 S E Q U E N T I A L F LO O D I N G 28 Disk Pages page0 page1 page2 page3 page4 page5 SELECT * FROM A WHERE id = 1Q1 Q1 CMU 15-445/645 (Fall 2019) Buffer Pool page0 S E Q U E N T I A L F LO O D I N G 28 Disk Pages page0 page1 page2 page3 page4 page5 SELECT * FROM A WHERE id = 1Q1 SELECT AVG(val) FROM AQ2 Q2 CMU 15-445/645 (Fall 2019) Buffer Pool page0 page1 page2 S E Q U E N T I A L F LO O D I N G 28 Disk Pages page0 page1 page2 page3 page4 page5 SELECT * FROM A WHERE id = 1Q1 SELECT AVG(val) FROM AQ2 Q2 CMU 15-445/645 (Fall 2019) Buffer Pool page1 page2 S E Q U E N T I A L F LO O D I N G 28 Disk Pages page0 page1 page2 page3 page4 page5 SELECT * FROM A WHERE id = 1Q1 SELECT AVG(val) FROM AQ2 page3 Q2 CMU 15-445/645 (Fall 2019) Buffer Pool page1 page2 S E Q U E N T I A L F LO O D I N G 28 Disk Pages page0 page1 page2 page3 page4 page5 SELECT * FROM A WHERE id = 1Q1 SELECT AVG(val) FROM AQ2 page3 Q2 SELECT * FROM A WHERE id = 1Q3 Q2 CMU 15-445/645 (Fall 2019) B E T T E R P O L I C I E S : L R U - K Track the history of the last K references as timestamps and compute the interval between subsequent accesses. The DBMS then uses this history to estimate the next time that page is going to be accessed. 29 CMU 15-445/645 (Fall 2019) B E T T E R P O L I C I E S : LO C A L I Z AT I O N The DBMS chooses which pages to evict on a per txn/query basis. This minimizes the pollution of the buffer pool from each query. → Keep track of the pages that a query has accessed. Example: Postgres maintains a small ring buffer that is private to the query. 30 CMU 15-445/645 (Fall 2019) B E T T E R P O L I C I E S : P R I O R I T Y H I N T S The DBMS knows what the context of each page during query execution. It can provide hints to the buffer pool on whether a page is important or not. 31 index-page0 index-page4index-page1 index-page2 index-page5index-page3 index-page6 INSERT INTO A VALUES (id++)Q1 MIN MAXid CMU 15-445/645 (Fall 2019) B E T T E R P O L I C I E S : P R I O R I T Y H I N T S The DBMS knows what the context of each page during query execution. It can provide hints to the buffer pool on whether a page is important or not. 31 index-page0 index-page4index-page1 index-page2 index-page5index-page3 index-page6 INSERT INTO A VALUES (id++)Q1 MIN MAXid CMU 15-445/645 (Fall 2019) B E T T E R P O L I C I E S : P R I O R I T Y H I N T S The DBMS knows what the context of each page during query execution. It can provide hints to the buffer pool on whether a page is important or not. 31 index-page0 index-page4index-page1 index-page2 index-page5index-page3 index-page6 SELECT * FROM A WHERE id = ?Q2 INSERT INTO A VALUES (id++)Q1 MIN MAXid CMU 15-445/645 (Fall 2019) D I R T Y PA G E S FAST: If a page in the buffer pool is not dirty, then the DBMS can simply \"drop\" it. SLOW: If a page is dirty, then the DBMS must write back to disk to ensure that its changes are persisted. Trade-off between fast evictions versus dirty writing pages that will not be read again in the future. 32 CMU 15-445/645 (Fall 2019) B A C KG R O U N D W R I T I N G The DBMS can periodically walk through the page table and write dirty pages to disk. When a dirty page is safely written, the DBMS can either evict the page or just unset the dirty flag. Need to be careful that we don’t write dirty pages before their log records have been written… 33 CMU 15-445/645 (Fall 2019) O T H E R M E M O R Y P O O L S The DBMS needs memory for things other than just tuples and indexes. These other memory pools may not always backed by disk. Depends on implementation. → Sorting + Join Buffers → Query Caches → Maintenance Buffers → Log Buffers → Dictionary Caches 34 CMU 15-445/645 (Fall 2019) C O N C L U S I O N The DBMS can manage that sweet, sweet memory better than the OS. Leverage the semantics about the query plan to make better decisions: → Evictions → Allocations → Pre-fetching 35 CMU 15-445/645 (Fall 2019) P R O J E C T # 1 You will build the first component of your storage manager. → Clock Replacement Policy → Buffer Pool Manager We will provide you with the disk manager and page layouts. 36 Due Date: Friday Sept 27th @ 11:59pm CMU 15-445/645 (Fall 2019) TA S K # 1 C LO C K R E P L A C E M E N T P O L I C Y Build a data structure that tracks the usage of frame_ids using the CLOCK policy. General Hints: → Your ClockReplacer needs to check the \"pinned\" status of a Page. → If there are no pages touched since last sweep, then return the lowest page id. 37 CMU 15-445/645 (Fall 2019) TA S K # 2 B U F F E R P O O L M A N A G E R Use your CLOCK replacer to manage the allocation of pages. → Need to maintain an internal data structures of allocated + free pages. → We will provide you components to read/write data from disk. → Use whatever data structure you want for the page table. General Hints: → Make sure you get the order of operations correct when pinning. 38 Buffer Pool (In-Memory) Page6 Page2 Page4 Database (On-Disk) Page0 Page1 Page2 CMU 15-445/645 (Fall 2019) G E T T I N G S TA R T E D Download the source code from GitHub. Make sure you can build it on your machine. → We've tested Ubuntu, OSX, and Windows (WSL2). → We are also providing a docker file to setup your environment. → It does not compile on the Andrews machines. Please contact me if this is a problem. 39 CMU 15-445/645 (Fall 2019) T H I N G S T O N O T E Do not change any file other than the four that you must hand in. The projects are cumulative. We will not be providing solutions. Post your questions on Piazza or come to our office hours. We will not help you debug. 40 CMU 15-445/645 (Fall 2019) C O D E Q U A L I T Y We will automatically check whether you are writing good code. → Google C++ Style Guide → Doxygen Javadoc Style You need to run these targets before you submit your implementation to Gradescope. → make format → make check-lint → make check-censored → make check-clang-tidy 41 CMU 15-445/645 (Fall 2019) P L A G I A R I S M WA R N I N G Your project implementation must be your own work. → You may not copy source code from other groups or the web. → Do not publish your implementation on GitHub. Plagiarism will not be tolerated. See CMU's Policy on Academic Integrity for additional information. 42 CMU 15-445/645 (Fall 2019) N E X T C L A S S HASH TABLES! 43","libVersion":"0.2.2","langs":""}