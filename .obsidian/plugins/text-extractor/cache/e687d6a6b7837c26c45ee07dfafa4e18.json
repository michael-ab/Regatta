{"path":".obsidian/plugins/text-extractor/cache/e687d6a6b7837c26c45ee07dfafa4e18.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 14 Query Planning & Optimization Part I CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Mid-Term Exam is Wed Oct 16th @ 12:00pm → See mid-term exam guide for more info. Project #2 is due Sun Oct 20th @ 11:59pm 2 CMU 15-445/645 (Fall 2019) Q U E R Y O P T I M I Z AT I O N Remember that SQL is declarative. → User tells the DBMS what answer they want, not how to get the answer. There can be a big difference in performance based on plan is used: → See last week: 1.3 hours vs. 0.45 seconds 3 CMU 15-445/645 (Fall 2019) I B M S Y S T E M R First implementation of a query optimizer from the 1970s. → People argued that the DBMS could never choose a query plan better than what a human could write. Many concepts and design decisions from the System R optimizer are still used today. 4 CMU 15-445/645 (Fall 2019) Q U E R Y O P T I M I Z AT I O N Heuristics / Rules → Rewrite the query to remove stupid / inefficient things. → These techniques may need to examine catalog, but they do not need to examine data. Cost-based Search → Use a model to estimate the cost of executing a plan. → Evaluate multiple equivalent plans for a query and pick the one with the lowest cost. 5 CMU 15-445/645 (Fall 2019) A R C H I T E C T U R E O V E R V I E W 6 Parser System Catalog Tree Rewriter (Optional) Cost Model SQL Rewriter (Optional) Binder Optimizer SQL Query1 SQL Query2 Abstract Syntax Tree 3 Logical Plan 4 Logical Plan 5 Physical Plan 6 Application Name→Internal ID Schema Info Schema Info Estimates CMU 15-445/645 (Fall 2019) LO G I C A L V S . P H Y S I C A L P L A N S The optimizer generates a mapping of a logical algebra expression to the optimal equivalent physical algebra expression. Physical operators define a specific execution strategy using an access path. → They can depend on the physical format of the data that they process (i.e., sorting, compression). → Not always a 1:1 mapping from logical to physical. 7 CMU 15-445/645 (Fall 2019) Q U E R Y O P T I M I Z AT I O N I S N P - H A R D This is the hardest part of building a DBMS. If you are good at this, you will get paid $$$. People are starting to look at employing ML to improve the accuracy and efficacy of optimizers. I am expanding the Advanced DB Systems class to cover this topic in greater detail. 8 CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A Relational Algebra Equivalences Static Rules 9 CMU 15-445/645 (Fall 2019) R E L AT I O N A L A LG E B R A E Q U I VA L E N C E S Two relational algebra expressions are equivalent if they generate the same set of tuples. The DBMS can identify better query plans without a cost model. This is often called query rewriting. 10 CMU 15-445/645 (Fall 2019) P R E D I C AT E P U S H D O W N 11 SELECT s.name, e.cid FROM student AS s, enrolled AS e WHERE s.sid = e.sid AND e.grade = 'A' πname, cid(σgrade='A'(student⋈enrolled)) CMU 15-445/645 (Fall 2019) P R E D I C AT E P U S H D O W N 11 student enrolled s.sid=e.sid grade='A' s.name,e.cid ⨝ s p student enrolled s.sid=e.sid grade='A' s.name,e.cid s p ⨝ SELECT s.name, e.cid FROM student AS s, enrolled AS e WHERE s.sid = e.sid AND e.grade = 'A' CMU 15-445/645 (Fall 2019) R E L AT I O N A L A LG E B R A E Q U I VA L E N C E S 12 πname, cid(σgrade='A'(student⋈enrolled)) πname, cid(student⋈(σgrade='A'(enrolled))) = SELECT s.name, e.cid FROM student AS s, enrolled AS e WHERE s.sid = e.sid AND e.grade = 'A' CMU 15-445/645 (Fall 2019) R E L AT I O N A L A LG E B R A E Q U I VA L E N C E S Selections: → Perform filters as early as possible. → Reorder predicates so that the DBMS applies the most selective one first. → Break a complex predicate, and push down σp1∧p2∧…pn(R) = σp1(σp2(…σpn(R))) Simplify a complex predicate → (X=Y AND Y=3) → X=3 AND Y=3 13 CMU 15-445/645 (Fall 2019) R E L AT I O N A L A LG E B R A E Q U I VA L E N C E S Projections: → Perform them early to create smaller tuples and reduce intermediate results (if duplicates are eliminated) → Project out all attributes except the ones requested or required (e.g., joining keys) This is not important for a column store… 14 CMU 15-445/645 (Fall 2019) P R O J E C T I O N P U S H D O W N 15 student enrolled s.sid=e.sid grade='A' s.name,e.cid ⨝ s p student enrolled s.sid=e.sid grade='A' s.name,e.cid ⨝ s p sid,cidpsid,namep SELECT s.name, e.cid FROM student AS s, enrolled AS e WHERE s.sid = e.sid AND e.grade = 'A' CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Impossible / Unnecessary Predicates 16 Source: Lukas Eder SELECT * FROM A WHERE 1 = 0;X CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Impossible / Unnecessary Predicates 16 Source: Lukas Eder SELECT * FROM A WHERE 1 = 0; SELECT * FROM A WHERE 1 = 1;X CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Impossible / Unnecessary Predicates 16 Source: Lukas Eder SELECT * FROM A WHERE 1 = 0; SELECT * FROM A WHERE 1 = 1;SELECT * FROM A; X CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Impossible / Unnecessary Predicates Join Elimination 16 Source: Lukas Eder SELECT * FROM A WHERE 1 = 0; SELECT A1.* FROM A AS A1 JOIN A AS A2 ON A1.id = A2.id; SELECT * FROM A WHERE 1 = 1;SELECT * FROM A; X CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Impossible / Unnecessary Predicates Join Elimination 16 Source: Lukas Eder SELECT * FROM A WHERE 1 = 0; SELECT * FROM A WHERE 1 = 1; SELECT * FROM A; SELECT * FROM A; X CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Ignoring Projections 17 SELECT * FROM A AS A1 WHERE EXISTS(SELECT val FROM A AS A2 WHERE A1.id = A2.id); CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); Source: Lukas Eder CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Ignoring Projections 17 SELECT * FROM A; CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); Source: Lukas Eder CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Ignoring Projections Merging Predicates 17 SELECT * FROM A WHERE val BETWEEN 1 AND 100 OR val BETWEEN 50 AND 150; SELECT * FROM A; CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); Source: Lukas Eder CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Ignoring Projections Merging Predicates 17 SELECT * FROM A WHERE val BETWEEN 1 AND 100 OR val BETWEEN 50 AND 150; SELECT * FROM A; CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); Source: Lukas Eder CMU 15-445/645 (Fall 2019) M O R E E X A M P L E S Ignoring Projections Merging Predicates 17 SELECT * FROM A WHERE val BETWEEN 1 AND 150; SELECT * FROM A; CREATE TABLE A ( id INT PRIMARY KEY, val INT NOT NULL ); Source: Lukas Eder CMU 15-445/645 (Fall 2019) R E L AT I O N A L A LG E B R A E Q U I VA L E N C E S Joins: → Commutative, associative R ⋈ S = S ⋈ R (R ⋈ S) ⋈ T = R ⋈ (S ⋈ T) How many different orderings are there for an n- way join? 18 CMU 15-445/645 (Fall 2019) R E L AT I O N A L A LG E B R A E Q U I VA L E N C E S How many different orderings are there for an n- way join? Catalan number ≈4n → Exhaustive enumeration will be too slow. We’ll see in a second how an optimizer limits the search space... 19 CMU 15-445/645 (Fall 2019) C O N C L U S I O N We can use static rules and heuristics to optimize a query plan without needing to understand the contents of the database. 20 CMU 15-445/645 (Fall 2019) N E X T C L A S S MID-TERM EXAM! → Seriously, this is not a joke. 21","libVersion":"0.2.2","langs":""}