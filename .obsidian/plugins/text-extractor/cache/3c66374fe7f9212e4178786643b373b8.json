{"path":".obsidian/plugins/text-extractor/cache/3c66374fe7f9212e4178786643b373b8.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 15 Query Planning & Optimization Part 2 CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Project #3 will be released this week. It is due Sun Nov 17th @ 11:59pm. Homework #4 will be released next week. It is due Wed Nov 13th @ 11:59pm. 2 CMU 15-445/645 (Fall 2019) Q U E R Y O P T I M I Z AT I O N Heuristics / Rules → Rewrite the query to remove stupid / inefficient things. → These techniques may need to examine catalog, but they do not need to examine data. Cost-based Search → Use a model to estimate the cost of executing a plan. → Evaluate multiple equivalent plans for a query and pick the one with the lowest cost. 3 CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A Plan Cost Estimation Plan Enumeration Nested Sub-queries 4 CMU 15-445/645 (Fall 2019) C O S T E S T I M AT I O N How long will a query take? → CPU: Small cost; tough to estimate → Disk: # of block transfers → Memory: Amount of DRAM used → Network: # of messages How many tuples will be read/written? It is too expensive to run every possible plan to determine this information, so the DBMS need a way to derive this information… 5 CMU 15-445/645 (Fall 2019) S TAT I S T I C S The DBMS stores internal statistics about tables, attributes, and indexes in its internal catalog. Different systems update them at different times. Manual invocations: → Postgres/SQLite: ANALYZE → Oracle/MySQL: ANALYZE TABLE → SQL Server: UPDATE STATISTICS → DB2: RUNSTATS 6 CMU 15-445/645 (Fall 2019) S TAT I S T I C S For each relation R, the DBMS maintains the following information: → NR: Number of tuples in R. → V(A,R): Number of distinct values for attribute A. 7 CMU 15-445/645 (Fall 2019) D E R I VA B L E S TAT I S T I C S The selection cardinality SC(A,R) is the average number of records with a value for an attribute A given NR / V(A,R) Note that this assumes data uniformity. → 10,000 students, 10 colleges – how many students in SCS? 8 CMU 15-445/645 (Fall 2019) S E L E C T I O N S TAT I S T I C S Equality predicates on unique keys are easy to estimate. What about more complex predicates? What is their selectivity? 9 SELECT * FROM people WHERE id = 123 SELECT * FROM people WHERE val > 1000 SELECT * FROM people WHERE age = 30 AND status = 'Lit' CREATE TABLE people ( id INT PRIMARY KEY, val INT NOT NULL, age INT NOT NULL, status VARCHAR(16) ); CMU 15-445/645 (Fall 2019) C O M P L E X P R E D I C AT E S The selectivity (sel) of a predicate P is the fraction of tuples that qualify. Formula depends on type of predicate: → Equality → Range → Negation → Conjunction → Disjunction 10 CMU 15-445/645 (Fall 2019) C O M P L E X P R E D I C AT E S The selectivity (sel) of a predicate P is the fraction of tuples that qualify. Formula depends on type of predicate: → Equality → Range → Negation → Conjunction → Disjunction 10 CMU 15-445/645 (Fall 2019) S E L E C T I O N S C O M P L E X P R E D I C AT E S Assume that V(age,people) has five distinct values (0–4) and NR = 5 Equality Predicate: A=constant → sel(A=constant) = SC(P) / NR → Example: sel(age=2) = 11 0 1 2 3 4count age SC(age=2)=1 SELECT * FROM people WHERE age = 2 1/5 CMU 15-445/645 (Fall 2019) 0 1 2 3 4count age S E L E C T I O N S C O M P L E X P R E D I C AT E S Range Predicate: → sel(A>=a) = (Amax – a) / (Amax – Amin) → Example: sel(age>=2) 12 ≈ (4 – 2) / (4 – 0) ≈ 1/2 agemin = 0 SELECT * FROM people WHERE age >= 2 agemax = 4 CMU 15-445/645 (Fall 2019) 0 1 2 3 4count age S E L E C T I O N S C O M P L E X P R E D I C AT E S Negation Query: → sel(not P) = 1 – sel(P) → Example: sel(age != 2) 13 SC(age=2)=1 SELECT * FROM people WHERE age != 2 CMU 15-445/645 (Fall 2019) 0 1 2 3 4count age S E L E C T I O N S C O M P L E X P R E D I C AT E S Negation Query: → sel(not P) = 1 – sel(P) → Example: sel(age != 2) Observation: Selectivity ≈ Probability 13 = 1 – (1/5) = 4/5 SC(age!=2)=2 SC(age!=2)=2 SELECT * FROM people WHERE age != 2 CMU 15-445/645 (Fall 2019) S E L E C T I O N S C O M P L E X P R E D I C AT E S Conjunction: → sel(P1 ⋀ P2) = sel(P1) ∙ sel(P2) → sel(age=2 ⋀ name LIKE 'A%') This assumes that the predicates are independent. 14 SELECT * FROM people WHERE age = 2 AND name LIKE 'A%' P1 P2 CMU 15-445/645 (Fall 2019) S E L E C T I O N S C O M P L E X P R E D I C AT E S Conjunction: → sel(P1 ⋀ P2) = sel(P1) ∙ sel(P2) → sel(age=2 ⋀ name LIKE 'A%') This assumes that the predicates are independent. 14 SELECT * FROM people WHERE age = 2 AND name LIKE 'A%' P1 P2 CMU 15-445/645 (Fall 2019) S E L E C T I O N S C O M P L E X P R E D I C AT E S Disjunction: → sel(P1 ⋁ P2) = sel(P1) + sel(P2) – sel(P1⋀P2) = sel(P1) + sel(P2) – sel(P1) ∙ sel(P2) → sel(age=2 OR name LIKE 'A%') This again assumes that the selectivities are independent. 15 SELECT * FROM people WHERE age = 2 OR name LIKE 'A%' P1 P2 CMU 15-445/645 (Fall 2019) S E L E C T I O N S C O M P L E X P R E D I C AT E S Disjunction: → sel(P1 ⋁ P2) = sel(P1) + sel(P2) – sel(P1⋀P2) = sel(P1) + sel(P2) – sel(P1) ∙ sel(P2) → sel(age=2 OR name LIKE 'A%') This again assumes that the selectivities are independent. 15 SELECT * FROM people WHERE age = 2 OR name LIKE 'A%' P1 P2 CMU 15-445/645 (Fall 2019) S E L E C T I O N C A R D I N A L I T Y Assumption #1: Uniform Data → The distribution of values (except for the heavy hitters) is the same. Assumption #2: Independent Predicates → The predicates on attributes are independent Assumption #3: Inclusion Principle → The domain of join keys overlap such that each key in the inner relation will also exist in the outer table. 16 CMU 15-445/645 (Fall 2019) C O R R E L AT E D AT T R I B U T E S Consider a database of automobiles: → # of Makes = 10, # of Models = 100 And the following query: → (make=\"Honda\" AND model=\"Accord\") With the independence and uniformity assumptions, the selectivity is: → 1/10 × 1/100 = 0.001 But since only Honda makes Accords the real selectivity is 1/100 = 0.01 17 Source: Guy Lohman CMU 15-445/645 (Fall 2019) C O S T E S T I M AT I O N S Our formulas are nice, but we assume that data values are uniformly distributed. 20 0 5 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Uniform Approximation Distinct values of attribute # of occurrences CMU 15-445/645 (Fall 2019) C O S T E S T I M AT I O N S Our formulas are nice, but we assume that data values are uniformly distributed. 21 0 5 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Non-Uniform Approximation CMU 15-445/645 (Fall 2019) C O S T E S T I M AT I O N S Our formulas are nice, but we assume that data values are uniformly distributed. 21 0 5 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Non-Uniform Approximation Bucket #1 Count=8 Bucket #2 Count=4 Bucket #3 Count=15 Bucket #4 Count=3 Bucket #5 Count=14 CMU 15-445/645 (Fall 2019) C O S T E S T I M AT I O N S Our formulas are nice, but we assume that data values are uniformly distributed. 21 Bucket #1 Count=8 Bucket #2 Count=4 Bucket #3 Count=15 Bucket #4 Count=3 Bucket #5 Count=14 0 5 10 15 1-3 4-6 7-9 10-12 13-15 Non-Uniform Approximation Bucket Ranges CMU 15-445/645 (Fall 2019) H I S T O G R A M S W I T H Q U A N T I L E S Vary the width of buckets so that the total number of occurrences for each bucket is roughly the same. 22 0 5 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Histogram (Quantiles) Bucket #1 Count=12 Bucket #2 Count=12 Bucket #3 Count=9 Bucket #4 Count=12 CMU 15-445/645 (Fall 2019) H I S T O G R A M S W I T H Q U A N T I L E S Vary the width of buckets so that the total number of occurrences for each bucket is roughly the same. 22 0 5 10 15 1-5 6-8 9-13 14-15 Histogram (Quantiles) CMU 15-445/645 (Fall 2019) S A M P L I N G Modern DBMSs also collect samples from tables to estimate selectivities. Update samples when the underlying tables changes significantly. 23 ⋮ 1 billion tuples SELECT AVG(age) FROM people WHERE age > 50 id name age status 1001 Obama 58 Rested 1002 Kanye 41 Weird 1003 Tupac 25 Dead 1004 Bieber 25 Crunk 1005 Andy 38 Lit CMU 15-445/645 (Fall 2019) S A M P L I N G Modern DBMSs also collect samples from tables to estimate selectivities. Update samples when the underlying tables changes significantly. 23 ⋮ 1 billion tuples SELECT AVG(age) FROM people WHERE age > 50 id name age status 1001 Obama 58 Rested 1002 Kanye 41 Weird 1003 Tupac 25 Dead 1004 Bieber 25 Crunk 1005 Andy 38 Lit 1001 Obama 58 Rested 1003 Tupac 25 Dead 1005 Andy 38 Lit Table Sample CMU 15-445/645 (Fall 2019) S A M P L I N G Modern DBMSs also collect samples from tables to estimate selectivities. Update samples when the underlying tables changes significantly. 23 ⋮ 1 billion tuples 1/3sel(age>50) = SELECT AVG(age) FROM people WHERE age > 50 id name age status 1001 Obama 58 Rested 1002 Kanye 41 Weird 1003 Tupac 25 Dead 1004 Bieber 25 Crunk 1005 Andy 38 Lit 1001 Obama 58 Rested 1003 Tupac 25 Dead 1005 Andy 38 Lit Table Sample CMU 15-445/645 (Fall 2019) O B S E R VAT I O N Now that we can (roughly) estimate the selectivity of predicates, what can we actually do with them? 24 CMU 15-445/645 (Fall 2019) Q U E R Y O P T I M I Z AT I O N After performing rule-based rewriting, the DBMS will enumerate different plans for the query and estimate their costs. → Single relation. → Multiple relations. → Nested sub-queries. It chooses the best plan it has seen for the query after exhausting all plans or some timeout. 25 CMU 15-445/645 (Fall 2019) S I N G L E- R E L AT I O N Q U E R Y P L A N N I N G Pick the best access method. → Sequential Scan → Binary Search (clustered indexes) → Index Scan Predicate evaluation ordering. Simple heuristics are often good enough for this. OLTP queries are especially easy… 26 CMU 15-445/645 (Fall 2019) O LT P Q U E R Y P L A N N I N G Query planning for OLTP queries is easy because they are sargable (Search Argument Able). → It is usually just picking the best index. → Joins are almost always on foreign key relationships with a small cardinality. → Can be implemented with simple heuristics. 27 CREATE TABLE people ( id INT PRIMARY KEY, val INT NOT NULL, ⋮ ); SELECT * FROM people WHERE id = 123; CMU 15-445/645 (Fall 2019) M U LT I - R E L AT I O N Q U E R Y P L A N N I N G As number of joins increases, number of alternative plans grows rapidly → We need to restrict search space. Fundamental decision in System R: only left-deep join trees are considered. → Modern DBMSs do not always make this assumption anymore. 28 CMU 15-445/645 (Fall 2019) M U LT I - R E L AT I O N Q U E R Y P L A N N I N G Fundamental decision in System R: Only consider left-deep join trees. 29 ⨝ ⨝ ⨝ A B C D ⨝ ⨝ ⨝ A B C D ⨝⨝ ⨝ A BC D CMU 15-445/645 (Fall 2019) M U LT I - R E L AT I O N Q U E R Y P L A N N I N G Fundamental decision in System R: Only consider left-deep join trees. 29 ⨝ ⨝ ⨝ A B C D ⨝ ⨝ ⨝ A B C D ⨝⨝ ⨝ A BC DX X CMU 15-445/645 (Fall 2019) M U LT I - R E L AT I O N Q U E R Y P L A N N I N G Fundamental decision in System R: Only consider left-deep join trees. Allows for fully pipelined plans where intermediate results are not written to temp files. → Not all left-deep trees are fully pipelined. 30 CMU 15-445/645 (Fall 2019) M U LT I - R E L AT I O N Q U E R Y P L A N N I N G Enumerate the orderings → Example: Left-deep tree #1, Left-deep tree #2… Enumerate the plans for each operator → Example: Hash, Sort-Merge, Nested Loop… Enumerate the access paths for each table → Example: Index #1, Index #2, Seq Scan… Use dynamic programming to reduce the number of cost estimations. 31 CMU 15-445/645 (Fall 2019) DY N A M I C P R O G R A M M I N G 32 SortMerge Join R.a=S.a SortMerge Join T.b=S.b Hash Join T.b=S.b R ⨝ S T T ⨝ S R R ⨝ S ⨝ T Hash Join R.a=S.a SELECT * FROM R, S, T WHERE R.a = S.a AND S.b = T.b Cost: 300 Cost: 400 Cost: 280 Cost: 200 R S T CMU 15-445/645 (Fall 2019) DY N A M I C P R O G R A M M I N G 32 Hash Join T.b=S.b R ⨝ S T T ⨝ S R R ⨝ S ⨝ T Hash Join R.a=S.a SELECT * FROM R, S, T WHERE R.a = S.a AND S.b = T.b Cost: 300 Cost: 200 R S T CMU 15-445/645 (Fall 2019) DY N A M I C P R O G R A M M I N G 32 Hash Join T.b=S.b R ⨝ S T T ⨝ S R R ⨝ S ⨝ T Hash Join R.a=S.a Hash Join S.b=T.b SortMerge Join S.b=T.b SortMerge Join S.a=R.a Hash Join S.a=R.a SELECT * FROM R, S, T WHERE R.a = S.a AND S.b = T.b Cost: 300 Cost: 200 Cost: 450 Cost: 300 Cost: 400 Cost: 380 R S T CMU 15-445/645 (Fall 2019) DY N A M I C P R O G R A M M I N G 32 Hash Join T.b=S.b R ⨝ S T T ⨝ S R R ⨝ S ⨝ T Hash Join R.a=S.a Hash Join S.b=T.b SortMerge Join S.a=R.a SELECT * FROM R, S, T WHERE R.a = S.a AND S.b = T.b Cost: 300 Cost: 200 Cost: 300 Cost: 380 R S T CMU 15-445/645 (Fall 2019) DY N A M I C P R O G R A M M I N G 32 Hash Join T.b=S.b R ⨝ S T T ⨝ S R R ⨝ S ⨝ T SortMerge Join S.a=R.a SELECT * FROM R, S, T WHERE R.a = S.a AND S.b = T.b Cost: 200 Cost: 300 R S T CMU 15-445/645 (Fall 2019) C A N D I D AT E P L A N E X A M P L E How to generate plans for search algorithm: → Enumerate relation orderings → Enumerate join algorithm choices → Enumerate access method choices No real DBMSs does it this way. It’s actually more messy… 33 SELECT * FROM R, S, T WHERE R.a = S.a AND S.b = T.b CMU 15-445/645 (Fall 2019) C A N D I D AT E P L A N S Step #1: Enumerate relation orderings 34 ⨝ ⨝ T R S ⨝ ⨝ S T R × ⨝ R S T ⨝ ⨝ R S T ⨝ ⨝ S R T × ⨝ S T R Prune plans with cross- products immediately! CMU 15-445/645 (Fall 2019) C A N D I D AT E P L A N S Step #1: Enumerate relation orderings 34 ⨝ ⨝ T R S ⨝ ⨝ S T R × ⨝ R S T ⨝ ⨝ R S T ⨝ ⨝ S R T × ⨝ S T R X X Prune plans with cross- products immediately! CMU 15-445/645 (Fall 2019) C A N D I D AT E P L A N S Step #2: Enumerate join algorithm choices 35 ⨝ ⨝ R S T Do this for the other plans. R S TNLJ NLJ R S THJ NLJ R S TNLJ HJ R S T HJ HJ CMU 15-445/645 (Fall 2019) C A N D I D AT E P L A N S Step #2: Enumerate join algorithm choices 35 ⨝ ⨝ R S T Do this for the other plans. R S TNLJ NLJ R S THJ NLJ R S TNLJ HJ R S T HJ HJ CMU 15-445/645 (Fall 2019) C A N D I D AT E P L A N S Step #3: Enumerate access method choices 36 R S T HJ HJ Do this for the other plans. HJ HJ SeqScan SeqScan SeqScan HJ HJ SeqScan IndexScan(S.b) SeqScan CMU 15-445/645 (Fall 2019) P O S T G R E S O P T I M I Z E R Examines all types of join trees → Left-deep, Right-deep, bushy Two optimizer implementations: → Traditional Dynamic Programming Approach → Genetic Query Optimizer (GEQO) Postgres uses the traditional algorithm when # of tables in query is less than 12 and switches to GEQO when there are 12 or more. 37 CMU 15-445/645 (Fall 2019) P O S T G R E S O P T I M I Z E R 38 1st Generation R S T NL NL Cost: 300 T R S NL HJ S R T HJ HJ Cost: 200 Cost: 100 CMU 15-445/645 (Fall 2019) P O S T G R E S O P T I M I Z E R 38 Best:100 1st Generation R S T NL NL Cost: 300 T R S NL HJ S R T HJ HJ X Cost: 200 Cost: 100 CMU 15-445/645 (Fall 2019) P O S T G R E S O P T I M I Z E R 38 Best:100 1st Generation 2nd Generation R S T NL NL Cost: 300 T R S NL HJ S R T HJ HJ X Cost: 200 Cost: 100 S R T HJ HJ R T S NL HJ T R S HJ HJ Cost: 80 Cost: 200 Cost: 110 CMU 15-445/645 (Fall 2019) P O S T G R E S O P T I M I Z E R 38 1st Generation 2nd Generation Best:80 R S T NL NL Cost: 300 T R S NL HJ S R T HJ HJ X Cost: 200 Cost: 100 S R T HJ HJ R T S NL HJ T R S HJ HJ Cost: 80 Cost: 200 Cost: 110 CMU 15-445/645 (Fall 2019) P O S T G R E S O P T I M I Z E R 38 1st Generation 2nd Generation Best:80 R S T NL NL Cost: 300 T R S NL HJ S R T HJ HJ X Cost: 200 Cost: 100 S R T HJ HJ R T S NL HJ T R S HJ HJ X Cost: 80 Cost: 200 Cost: 110 CMU 15-445/645 (Fall 2019) P O S T G R E S O P T I M I Z E R 38 1st Generation 2nd Generation 3rd Generation … Best:80 R S T NL NL Cost: 300 T R S NL HJ S R T HJ HJ X Cost: 200 Cost: 100 S R T HJ HJ R T S NL HJ T R S HJ HJ X Cost: 80 Cost: 200 Cost: 110 R S T HJ HJ R S T HJ HJ R T S HJ HJ Cost: 90 Cost: 160 Cost: 120 CMU 15-445/645 (Fall 2019) N E S T E D S U B - Q U E R I E S The DBMS treats nested sub-queries in the where clause as functions that take parameters and return a single value or set of values. Two Approaches: → Rewrite to de-correlate and/or flatten them → Decompose nested query and store result to temporary table 39 CMU 15-445/645 (Fall 2019) N E S T E D S U B - Q U E R I E S : R E W R I T E 40 SELECT name FROM sailors AS S WHERE EXISTS ( SELECT * FROM reserves AS R WHERE S.sid = R.sid AND R.day = '2018-10-15' ) CMU 15-445/645 (Fall 2019) N E S T E D S U B - Q U E R I E S : R E W R I T E 40 SELECT name FROM sailors AS S WHERE EXISTS ( SELECT * FROM reserves AS R WHERE S.sid = R.sid AND R.day = '2018-10-15' ) SELECT name FROM sailors AS S, reserves AS R WHERE S.sid = R.sid AND R.day = '2018-10-15' CMU 15-445/645 (Fall 2019) N E S T E D S U B - Q U E R I E S : D E C O M P O S E 41 For each sailor with the highest rating (over all sailors) and at least two reservations for red boats, find the sailor id and the earliest date on which the sailor has a reservation for a red boat. SELECT S.sid, MIN(R.day) FROM sailors S, reserves R, boats B WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red' AND S.rating = (SELECT MAX(S2.rating) FROM sailors S2) GROUP BY S.sid HAVING COUNT(*) > 1 CMU 15-445/645 (Fall 2019) D E C O M P O S I N G Q U E R I E S For harder queries, the optimizer breaks up queries into blocks and then concentrates on one block at a time. Sub-queries are written to a temporary table that are discarded after the query finishes. 42 CMU 15-445/645 (Fall 2019) D E C O M P O S I N G Q U E R I E S 43 SELECT S.sid, MIN(R.day) FROM sailors S, reserves R, boats B WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red' AND S.rating = (SELECT MAX(S2.rating) FROM sailors S2) GROUP BY S.sid HAVING COUNT(*) > 1 Nested Block CMU 15-445/645 (Fall 2019) D E C O M P O S I N G Q U E R I E S 43 SELECT S.sid, MIN(R.day) FROM sailors S, reserves R, boats B WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red' AND S.rating = (SELECT MAX(S2.rating) FROM sailors S2) GROUP BY S.sid HAVING COUNT(*) > 1 Nested Block SELECT MAX(rating) FROM sailors CMU 15-445/645 (Fall 2019) D E C O M P O S I N G Q U E R I E S 43 SELECT S.sid, MIN(R.day) FROM sailors S, reserves R, boats B WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red' AND S.rating = (SELECT MAX(S2.rating) FROM sailors S2) GROUP BY S.sid HAVING COUNT(*) > 1 SELECT MAX(rating) FROM sailors ### CMU 15-445/645 (Fall 2019) D E C O M P O S I N G Q U E R I E S 43 SELECT S.sid, MIN(R.day) FROM sailors S, reserves R, boats B WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red' AND S.rating = (SELECT MAX(S2.rating) FROM sailors S2) GROUP BY S.sid HAVING COUNT(*) > 1 Outer Block SELECT MAX(rating) FROM sailors ### CMU 15-445/645 (Fall 2019) C O N C L U S I O N Filter early as possible. Selectivity estimations → Uniformity → Independence → Histograms → Join selectivity Dynamic programming for join orderings Rewrite nested queries Again, query optimization is hard… 44 CMU 15-445/645 (Fall 2019) E X T R A C R E D I T Each student can earn extra credit if they write a encyclopedia article about a DBMS. → Can be academic/commercial, active/historical. Each article will use a standard taxonomy. → For each feature category, you select pre-defined options for your DBMS. → You will then need to provide a summary paragraph with citations for that category. 45 CMU 15-445/645 (Fall 2019) E X T R A C R E D I T Each student can earn extra credit if they write a encyclopedia article about a DBMS. → Can be academic/commercial, active/historical. Each article will use a standard taxonomy. → For each feature category, you select pre-defined options for your DBMS. → You will then need to provide a summary paragraph with citations for that category. 45 CMU 15-445/645 (Fall 2019) E X T R A C R E D I T Each student can earn extra credit if they write a encyclopedia article about a DBMS. → Can be academic/commercial, active/historical. Each article will use a standard taxonomy. → For each feature category, you select pre-defined options for your DBMS. → You will then need to provide a summary paragraph with citations for that category. 45 CMU 15-445/645 (Fall 2019) E X T R A C R E D I T Each student can earn extra credit if they write a encyclopedia article about a DBMS. → Can be academic/commercial, active/historical. Each article will use a standard taxonomy. → For each feature category, you select pre-defined options for your DBMS. → You will then need to provide a summary paragraph with citations for that category. 45 CMU 15-445/645 (Fall 2019) D B D B . I O All the articles will be hosted on dbdb.io → I will post registration details on Piazza. I will post a sign-up sheet for you to pick what DBMS you want to write about. → If you choose a widely known DBMS, then the article will need to be comprehensive. → If you choose an obscure DBMS, then you will have to do the best you can to find information. 46 CMU 15-445/645 (Fall 2019) D B D B . I O All the articles will be hosted on dbdb.io → I will post registration details on Piazza. I will post a sign-up sheet for you to pick what DBMS you want to write about. → If you choose a widely known DBMS, then the article will need to be comprehensive. → If you choose an obscure DBMS, then you will have to do the best you can to find information. 46 CMU 15-445/645 (Fall 2019) CMU 15-445/645 (Fall 2019) H O W T O D E C I D E Pick a DBMS based on whatever criteria you want: → Country of Origin → Popularity → Programming Language → Single-Node vs. Embedded vs. Distributed → Disk vs. Memory → Row Store vs. Column Store → Open-Source vs. Proprietary 48 CMU 15-445/645 (Fall 2019) P L A G I A R I S M WA R N I N G This article must be your own writing with your own images. You may not copy text/images directly from papers or other sources that you find on the web. Plagiarism will not be tolerated. See CMU's Policy on Academic Integrity for additional information. 49 CMU 15-445/645 (Fall 2019) N E X T C L A S S Transactions! → aka the second hardest part about database systems 50","libVersion":"0.2.2","langs":""}