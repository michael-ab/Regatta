{"path":".obsidian/plugins/text-extractor/cache/90b3842e7f3ac9e1acf0f19a8ff1a9a6.json","text":"Database Systems 15-445/15-645 Fall 2018 Andy Pavlo Computer Science Carnegie Mellon Univ.AP Lecture #18 Timestamp Ordering Concurrency Control CMU 15-445/645 (Fall 2018) A D M I N I S T R I V I A Homework #4: Monday Nov 12th @ 11:59pm Project #3: Monday Nov 19th @ 11:59am 2 CMU 15-445/645 (Fall 2018) C O N C U R R E N C Y C O N T R O L A P P R O A C H E S Two-Phase Locking (2PL) → Determine serializability order of conflicting operations at runtime while txns execute. Timestamp Ordering (T/O) → Determine serializability order of txns before they execute. 3 CMU 15-445/645 (Fall 2018) C O N C U R R E N C Y C O N T R O L A P P R O A C H E S Two-Phase Locking (2PL) → Determine serializability order of conflicting operations at runtime while txns execute. Timestamp Ordering (T/O) → Determine serializability order of txns before they execute. 3 Pessimistic Optimistic CMU 15-445/645 (Fall 2018) T / O C O N C U R R E N C Y C O N T R O L Use timestamps to determine the serializability order of txns. If TS(Ti) < TS(Tj), then the DBMS must ensure that the execution schedule is equivalent to a serial schedule where Ti appears before Tj. 4 CMU 15-445/645 (Fall 2018) T I M E S TA M P A L LO C AT I O N Each txn Ti is assigned a unique fixed timestamp that is monotonically increasing. → Let TS(Ti) be the timestamp allocated to txn Ti. → Different schemes assign timestamps at different times during the txn. Multiple implementation strategies: → System Clock. → Logical Counter. → Hybrid. 5 CMU 15-445/645 (Fall 2018) T O D AY ' S A G E N D A Basic Timestamp Ordering Protocol Optimistic Concurrency Control Partition-based Timestamp Ordering Isolation Levels 6 CMU 15-445/645 (Fall 2018) B A S I C T / O Txns read and write objects without locks. Every object X is tagged with timestamp of the last txn that successfully did read/write: → W-TS(X) – Write timestamp on X → R-TS(X) – Read timestamp on X Check timestamps for every operation: → If txn tries to access an object \"from the future\", it aborts and restarts. 7 CMU 15-445/645 (Fall 2018) B A S I C T / O R E A D S If TS(Ti) < W-TS(X), this violates timestamp order of Ti with regard to the writer of X. → Abort Ti and restart it with same TS. Else: → Allow Ti to read X. → Update R-TS(X) to max(R-TS(X), TS(Ti)) → Have to make a local copy of X to ensure repeatable reads for Ti. 8 CMU 15-445/645 (Fall 2018) B A S I C T / O W R I T E S If TS(Ti) < R-TS(X) or TS(Ti) < W-TS(X) → Abort and restart Ti. Else: → Allow Ti to write X and update W-TS(X) → Also have to make a local copy of X to ensure repeatable reads for Ti. 9 CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0TIME Schedule T1 T2 B A S I C T / O E X A M P L E # 1 10 BEGIN R(B) R(A) COMMIT BEGIN R(B) W(B) R(A) W(A) COMMIT TS(T1)=1 TS(T2 )=2 Database CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0TIME Schedule T1 T2 B A S I C T / O E X A M P L E # 1 10 BEGIN R(B) R(A) COMMIT BEGIN R(B) W(B) R(A) W(A) COMMIT TS(T1)=1 TS(T2 )=2 1 Database CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0TIME Schedule T1 T2 B A S I C T / O E X A M P L E # 1 10 BEGIN R(B) R(A) COMMIT BEGIN R(B) W(B) R(A) W(A) COMMIT TS(T1)=1 TS(T2 )=2 12 Database CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0TIME Schedule T1 T2 B A S I C T / O E X A M P L E # 1 10 BEGIN R(B) R(A) COMMIT BEGIN R(B) W(B) R(A) W(A) COMMIT TS(T1)=1 TS(T2 )=2 12 2 Database CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0TIME Schedule T1 T2 B A S I C T / O E X A M P L E # 1 10 BEGIN R(B) R(A) COMMIT BEGIN R(B) W(B) R(A) W(A) COMMIT TS(T1)=1 TS(T2 )=2 1 12 2 Database CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0TIME Schedule T1 T2 B A S I C T / O E X A M P L E # 1 10 BEGIN R(B) R(A) COMMIT BEGIN R(B) W(B) R(A) W(A) COMMIT TS(T1)=1 TS(T2 )=2 1 12 2 2 Database CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0TIME Schedule T1 T2 B A S I C T / O E X A M P L E # 1 10 BEGIN R(B) R(A) COMMIT BEGIN R(B) W(B) R(A) W(A) COMMIT TS(T1)=1 TS(T2 )=2 1 12 2 2 2 Database No violations so both txns are safe to commit. CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0 DatabaseTIME Schedule T1 T2 B A S I C T / O E X A M P L E # 2 11 BEGIN R(A) W(A) R(A) COMMIT BEGIN W(A) COMMIT 1 CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0 DatabaseTIME Schedule T1 T2 B A S I C T / O E X A M P L E # 2 11 BEGIN R(A) W(A) R(A) COMMIT BEGIN W(A) COMMIT 1 2 CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0 DatabaseTIME Schedule T1 T2 B A S I C T / O E X A M P L E # 2 11 BEGIN R(A) W(A) R(A) COMMIT BEGIN W(A) COMMIT 1 2 Violation: TS(T1) < W-TS(A) T1 cannot overwrite update by T2, so the DBMS has to abort it! CMU 15-445/645 (Fall 2018) T H O M A S W R I T E R U L E If TS(Ti) < R-TS(X): → Abort and restart Ti. If TS(Ti) < W-TS(X): → Thomas Write Rule: Ignore the write and allow the txn to continue. → This violates timestamp order of Ti. Else: → Allow Ti to write X and update W-TS(X) 12 CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0 DatabaseTIME Schedule T1 T2 B A S I C T / O E X A M P L E # 2 13 BEGIN R(A) W(A) R(A) COMMIT BEGIN W(A) COMMIT 1 CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0 DatabaseTIME Schedule T1 T2 B A S I C T / O E X A M P L E # 2 13 BEGIN R(A) W(A) R(A) COMMIT BEGIN W(A) COMMIT 1 2 CMU 15-445/645 (Fall 2018) Object R-TS W-TS A 0 0 B 0 0 DatabaseTIME Schedule T1 T2 B A S I C T / O E X A M P L E # 2 13 BEGIN R(A) W(A) R(A) COMMIT BEGIN W(A) COMMIT 1 2 We do not update W-TS(A) Ignore the write and allow T1 to commit. CMU 15-445/645 (Fall 2018) B A S I C T / O Generates a schedule that is conflict serializable if you do not use the Thomas Write Rule. → No deadlocks because no txn ever waits. → Possibility of starvation for long txns if short txns keep causing conflicts. Permits schedules that are not recoverable. 14 CMU 15-445/645 (Fall 2018) R E C O V E R A B L E S C H E D U L E S A schedule is recoverable if txns commit only after all txns whose changes they read, commit. Otherwise, the DBMS cannot guarantee that txns read data that will be restored after recovering from a crash. 15 CMU 15-445/645 (Fall 2018)TIME Schedule T1 T2 R E C O V E R A B L E S C H E D U L E S 16 BEGIN W(A) ⋮ BEGIN R(A) W(B) COMMIT T2 is allowed to read the writes of T1. CMU 15-445/645 (Fall 2018)TIME Schedule T1 T2 R E C O V E R A B L E S C H E D U L E S 16 BEGIN W(A) ⋮ BEGIN R(A) W(B) COMMIT T2 is allowed to read the writes of T1. This is not recoverable because we cannot restart T1. T1 aborts after T2 has committed. ABORT CMU 15-445/645 (Fall 2018) B A S I C T / O P E R F O R M A N C E I S S U E S High overhead from copying data to txn's workspace and from updating timestamps. Long running txns can get starved. → The likelihood that a txn will read something from a newer txn increases. 17 CMU 15-445/645 (Fall 2018) O B S E R VAT I O N If you assume that conflicts between txns are rare and that most txns are short-lived, then forcing txns to wait to acquire locks adds a lot of overhead. A better approach is to optimize for the no- conflict case. 18 CMU 15-445/645 (Fall 2018) O P T I M I S T I C C O N C U R R E N C Y C O N T R O L The DBMS creates a private workspace for each txn. → Any object read is copied into workspace. → Modifications are applied to workspace. When a txn commits, the DBMS compares workspace write set to see whether it conflicts with other txns. If there are no conflicts, the write set is installed into the \"global\" database. 19 CMU 15-445/645 (Fall 2018) O C C P H A S E S #1 – Read Phase: → Track the read/write sets of txns and store their writes in a private workspace. #2 – Validation Phase: → When a txn commits, check whether it conflicts with other txns. #3 – Write Phase: → If validation succeeds, apply private changes to database. Otherwise abort and restart the txn. 20 CMU 15-445/645 (Fall 2018) Database Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT CMU 15-445/645 (Fall 2018) Database Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT 123 0A CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT T2 Workspace 123 0A CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT T2 Workspace 123 0A 123 0A CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT T2 Workspace 123 0A 123 0A TS(T2 )=1 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT T2 Workspace 123 0A 123 0A TS(T2 )=1 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT 123 0A TS(T2 )=1 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT 456 1123 0A 456 ∞ TS(T2 )=1 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT 456 1123 0A 456 ∞ TS(T2 )=1 TS(T1)=2 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T1 Workspace Object Value W-TS A 123 0 - - -TIME Schedule T1 T2 O C C E X A M P L E 21 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT 456 1 456 2 123 0A 456 ∞ TS(T2 )=1 TS(T1)=2 CMU 15-445/645 (Fall 2018) O C C VA L I D AT I O N P H A S E The DBMS needs to guarantee only serializable schedules are permitted. Ti checks other txns for RW and WW conflicts and makes sure that all conflicts go one way (from older txns to younger txns). 22 CMU 15-445/645 (Fall 2018) O C C S E R I A L VA L I D AT I O N Maintain global view of all active txns. Record read set and write set while txns are running and write into private workspace. Execute Validation and Write phase inside a protected critical section. 23 CMU 15-445/645 (Fall 2018) O C C VA L I D AT I O N P H A S E Each txn's timestamp is assigned at the beginning of the validation phase. Check the timestamp ordering of the committing txn with all other running txns. If TS(Ti) < TS(Tj), then one of the following three conditions must hold… 24 CMU 15-445/645 (Fall 2018) O C C VA L I D AT I O N S T E P # 1 Ti completes all three phases before Tj begins. 25 CMU 15-445/645 (Fall 2018) O C C VA L I D AT I O N S T E P # 1 26 BEGIN READ VALIDATE WRITE COMMIT BEGIN READ VALIDATE WRITE COMMITTIME Schedule T1 T2 CMU 15-445/645 (Fall 2018) O C C VA L I D AT I O N S T E P # 2 Ti completes before Tj starts its Write phase, and Ti does not write to any object read by Tj. → WriteSet(Ti) ∩ ReadSet(Tj) = Ø 27 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace T2 WorkspaceTIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 2 28 BEGIN READ R(A) W(A) VALIDATE BEGIN READ R(A) VALIDATE WRITE COMMIT 123 0A 123 0A∞ Object Value W-TS A 123 0 - - - CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace T2 WorkspaceTIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 2 28 BEGIN READ R(A) W(A) VALIDATE BEGIN READ R(A) VALIDATE WRITE COMMIT 123 0A 123 0A∞ T1 has to abort even though T2 will never write to the database. Object Value W-TS A 123 0 - - - CMU 15-445/645 (Fall 2018)TIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 2 29 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace T2 Workspace 456 0A 123 0A∞ Object Value W-TS A 123 0 - - - CMU 15-445/645 (Fall 2018)TIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 2 29 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(A) VALIDATE WRITE COMMIT Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace T2 Workspace 456 0A 123 0A∞ Object Value W-TS A 123 0 - - - Safe to commit T1 because we know that T2 will not write. CMU 15-445/645 (Fall 2018) O C C VA L I D AT I O N S T E P # 3 Ti completes its Read phase before Tj completes its Read phase And Ti does not write to any object that is either read or written by Tj: → WriteSet(Ti) ∩ ReadSet(Tj) = Ø → WriteSet(Ti) ∩ WriteSet(Tj) = Ø 30 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace T2 Workspace Object Value W-TS A 123 0 B XYZ 0TIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 3 31 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(B) R(A) VALIDATE WRITE COMMIT 123 0A XYZ 0B456 ∞ TS(T1)=1 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace T2 Workspace Object Value W-TS A 123 0 B XYZ 0TIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 3 31 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(B) R(A) VALIDATE WRITE COMMIT 123 0A XYZ 0B456 ∞ TS(T1)=1 Safe to commit T1 because T2 sees the DB after T1 has executed. CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - Object Value W-TS - - - - - - T1 Workspace T2 Workspace Object Value W-TS A 123 0 B XYZ 0TIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 3 31 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(B) R(A) VALIDATE WRITE COMMIT 123 0A XYZ 0B456 ∞ 456 1 TS(T1)=1 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T2 Workspace Object Value W-TS A 123 0 B XYZ 0TIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 3 31 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(B) R(A) VALIDATE WRITE COMMIT XYZ 0B 456 1 CMU 15-445/645 (Fall 2018) Database Object Value W-TS - - - - - - T2 Workspace Object Value W-TS A 123 0 B XYZ 0TIME Schedule T1 T2 O C C VA L I D AT I O N S T E P # 3 31 BEGIN READ R(A) W(A) VALIDATE WRITE COMMIT BEGIN READ R(B) R(A) VALIDATE WRITE COMMIT XYZ 0B 456 1A 456 1 CMU 15-445/645 (Fall 2018) O C C O B S E R VAT I O N S OCC works well when the # of conflicts is low: → All txns are read-only (ideal). → Txns access disjoint subsets of data. If the database is large and the workload is not skewed, then there is a low probability of conflict, so again locking is wasteful. 32 CMU 15-445/645 (Fall 2018) O C C P E R F O R M A N C E I S S U E S High overhead for copying data locally. Validation/Write phase bottlenecks. Aborts are more wasteful than in 2PL because they only occur after a txn has already executed. 33 CMU 15-445/645 (Fall 2018) O B S E R VAT I O N When a txn commits, all previous T/O schemes check to see whether there is a conflict with concurrent txns. → This requires latches. If you have a lot of concurrent txns, then this is slow even if the conflict rate is low. 34 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O Split the database up in disjoint subsets called horizontal partitions (aka shards). Use timestamps to order txns for serial execution at each partition. → Only check for conflicts between txns that are running in the same partition. 35 CMU 15-445/645 (Fall 2018) D ATA B A S E PA R T I T I O N I N G 36 CREATE TABLE customer ( c_id INT PRIMARY KEY, c_email VARCHAR UNIQUE, ⋮ ); CREATE TABLE orders ( o_id INT PRIMARY KEY, o_c_id INT REFERENCES ⮱customer (c_id), ⋮ ); CREATE TABLE oitems ( oi_id INT PRIMARY KEY, oi_o_id INT REFERENCES ⮱orders (o_id), oi_c_id INT REFERENCES ⮱orders (o_c_id), ⋮ ); CMU 15-445/645 (Fall 2018) H O R I Z O N TA L PA R T I T I O N I N G 37 BEGIN Application Server Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 CMU 15-445/645 (Fall 2018) H O R I Z O N TA L PA R T I T I O N I N G 37 COMMIT Application Server Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O Txns are assigned timestamps based on when they arrive at the DBMS. Partitions are protected by a single lock: → Each txn is queued at the partitions it needs. → The txn acquires a partition’s lock if it has the lowest timestamp in that partition’s queue. → The txn starts when it has all of the locks for all the partitions that it will read/write. 38 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O R E A D S Txns can read anything that they want at the partitions that they have locked. If a txn tries to access a partition that it does not have the lock, it is aborted + restarted. 39 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O W R I T E S All updates occur in place. → Maintain a separate in-memory buffer to undo changes if the txn aborts. If a txn tries to write to a partition that it does not have the lock, it is aborted + restarted. 40 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O 41 Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 Server #1 Server #2 Txn Queue CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O 41 BEGIN Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 Server #1 Server #2 Txn Queue BEGIN Server1: 100 Server2: 101 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O 41 BEGIN Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 Server #1 Server #2 Txn Queue BEGIN Server1: 100 Server2: 101 Txn #100 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O 41 Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 Server #1 Server #2 Txn Queue BEGIN Server1: 100 Server2: 101 Txn #100Get C_ID=1 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O 41 Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 Server #1 Server #2 Txn Queue BEGIN Server1: 100 Server2: 101 Txn #100COMMIT CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O 41 Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 Server #1 Server #2 Txn Queue BEGIN Server2: 101 CMU 15-445/645 (Fall 2018) PA R T I T I O N - B A S E D T / O 41 Partitions OITEMS ORDERS CUSTOMERS OITEMS ORDERS CUSTOMERS Customers 1-1000 Customers 1001-2000 Server #1 Server #2 Txn Queue BEGIN Server2: 101 Txn #101 CMU 15-445/645 (Fall 2018) PA R T I T I O N E D T / O P E R F O R M A N C E I S S U E S Partition-based T/O protocol is fast if: → The DBMS knows what partitions the txn needs before it starts. → Most (if not all) txns only need to access a single partition. Multi-partition txns causes partitions to be idle while txn executes. 42 CMU 15-445/645 (Fall 2018) DY N A M I C D ATA B A S E S Recall that so far we have only dealing with transactions that read and update data. But now if we have insertions, updates, and deletions, we have new problems… 43 CMU 15-445/645 (Fall 2018) T H E P H A N T O M P R O B L E M 44 BEGIN COMMIT BEGIN COMMIT INSERT INTO people (age=96, status='lit') 72 96TIME Schedule T1 T2 SELECT MAX(age) FROM people WHERE status='lit' CREATE TABLE people ( id SERIAL, name VARCHAR, age INT, status VARCHAR ); SELECT MAX(age) FROM people WHERE status='lit' CMU 15-445/645 (Fall 2018) W T F ? How did this happen? → Because T1 locked only existing records and not ones under way! Conflict serializability on reads and writes of individual items guarantees serializability only if the set of objects is fixed. 45 CMU 15-445/645 (Fall 2018) P R E D I C AT E LO C K I N G Lock records that satisfy a logical predicate: → Example: status='lit' In general, predicate locking has a lot of locking overhead. Index locking is a special case of predicate locking that is potentially more efficient. 46 CMU 15-445/645 (Fall 2018) I N D E X LO C K I N G If there is a dense index on the status field then the txn can lock index page containing the data with status='lit'. If there are no records with status='lit', the txn must lock the index page where such a data entry would be, if it existed. 47 CMU 15-445/645 (Fall 2018) LO C K I N G W I T H O U T A N I N D E X If there is no suitable index, then the txn must obtain: → A lock on every page in the table to prevent a record’s status='lit' from being changed to lit. → The lock for the table itself to prevent records with status='lit' from being added or deleted. 48 CMU 15-445/645 (Fall 2018) R E P E AT I N G S C A N S An alternative is to just re-execute every scan again when the txn commits and check whether it gets the same result. → Have to retain the scan set for every range query in a txn. → Andy doesn't know of any commercial system that does this (only just Silo?). 49 CMU 15-445/645 (Fall 2018) W E A K E R L E V E L S O F I S O L AT I O N Serializability is useful because it allows programmers to ignore concurrency issues. But enforcing it may allow too little concurrency and limit performance. We may want to use a weaker level of consistency to improve scalability. 50 CMU 15-445/645 (Fall 2018) I S O L AT I O N L E V E L S Controls the extent that a txn is exposed to the actions of other concurrent txns. Provides for greater concurrency at the cost of exposing txns to uncommitted changes: → Dirty Reads → Unrepeatable Reads → Phantom Reads 51 CMU 15-445/645 (Fall 2018) I S O L AT I O N L E V E L S SERIALIZABLE: No phantoms, all reads repeatable, no dirty reads. REPEATABLE READS: Phantoms may happen. READ COMMITTED: Phantoms and unrepeatable reads may happen. READ UNCOMMITTED: All of them may happen. 52Isolation (High) CMU 15-445/645 (Fall 2018) I S O L AT I O N L E V E L S 53 Dirty Read Unrepeatable Read Phantom SERIALIZABLE No No No REPEATABLE READ No No Maybe READ COMMITTED No Maybe Maybe READ UNCOMMITTED Maybe Maybe Maybe CMU 15-445/645 (Fall 2018) I S O L AT I O N L E V E L S SERIALIZABLE: Obtain all locks first; plus index locks, plus strict 2PL. REPEATABLE READS: Same as above, but no index locks. READ COMMITTED: Same as above, but S locks are released immediately. READ UNCOMMITTED: Same as above, but allows dirty reads (no S locks). 54 CMU 15-445/645 (Fall 2018) SQL- 9 2 I S O L AT I O N L E V E L S You set a txn's isolation level before you execute any queries in that txn. Not all DBMS support all isolation levels in all execution scenarios → Replicated Environments The default depends on implementation… 55 SET TRANSACTION ISOLATION LEVEL <isolation-level>; BEGIN TRANSACTION ISOLATION LEVEL <isolation-level>; CMU 15-445/645 (Fall 2018) I S O L AT I O N L E V E L S ( 2 0 1 3 ) 56 Default Maximum Actian Ingres 10.0/10S SERIALIZABLE SERIALIZABLE Aerospike READ COMMITTED READ COMMITTED Greenplum 4.1 READ COMMITTED SERIALIZABLE MySQL 5.6 REPEATABLE READS SERIALIZABLE MemSQL 1b READ COMMITTED READ COMMITTED MS SQL Server 2012 READ COMMITTED SERIALIZABLE Oracle 11g READ COMMITTED SNAPSHOT ISOLATION Postgres 9.2.2 READ COMMITTED SERIALIZABLE SAP HANA READ COMMITTED SERIALIZABLE ScaleDB 1.02 READ COMMITTED READ COMMITTED VoltDB SERIALIZABLE SERIALIZABLE Source: Peter Bailis CMU 15-445/645 (Fall 2018) S Q L- 9 2 A C C E S S M O D E S You can provide hints to the DBMS about whether a txn will modify the database during its lifetime. Only two possible modes: → READ WRITE (Default) → READ ONLY Not all DBMSs will optimize execution if you set a txn to in READ ONLY mode. 57 SET TRANSACTION <access-mode>; BEGIN TRANSACTION <access-mode>; CMU 15-445/645 (Fall 2018) C O N C L U S I O N Every concurrency control can be broken down into the basic concepts that I've described in the last two lectures. I'm not showing benchmark results because I don't want you to get the wrong idea. 58 CMU 15-445/645 (Fall 2018) N E X T C L A S S Multi-Version Concurrency Control 59","libVersion":"0.2.2","langs":""}