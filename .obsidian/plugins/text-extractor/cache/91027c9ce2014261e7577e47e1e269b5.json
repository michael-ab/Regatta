{"path":".obsidian/plugins/text-extractor/cache/91027c9ce2014261e7577e47e1e269b5.json","text":"Database Systems 15-445/15-645 Fall 2018 Andy Pavlo Computer Science Carnegie Mellon Univ.AP Lecture #17 Two-Phase Locking CMU 15-445/645 (Fall 2018) L A S T C L A S S Conflict Serializable → Verify using either the \"swapping\" method or dependency graphs. → Any DBMS that says that they support \"serializable\" isolation does this. View Serializable → No efficient way to verify. → Andy doesn't know of any DBMS that supports this. 2 CMU 15-445/645 (Fall 2018) E X A M P L E 3 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMITTIME Schedule T1 T2 CMU 15-445/645 (Fall 2018) O B S E R VAT I O N We need a way to guarantee that all execution schedules are correct (i.e., serializable) without knowing the entire schedule ahead of time. Solution: Use locks to protect database objects. 4 CMU 15-445/645 (Fall 2018) Lock Manager E X E C U T I N G W I T H LO C K S 5 Granted (T1→A)TIME BEGIN LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN LOCK(A) R(A) W(A) UNLOCK(A) COMMIT Schedule T1 T2 CMU 15-445/645 (Fall 2018) Lock Manager E X E C U T I N G W I T H LO C K S 5 Granted (T1→A) Denied!TIME BEGIN LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN LOCK(A) R(A) W(A) UNLOCK(A) COMMIT Schedule T1 T2 CMU 15-445/645 (Fall 2018) Lock Manager E X E C U T I N G W I T H LO C K S 5 Granted (T1→A) Denied! Released (T1→A)TIME BEGIN LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN LOCK(A) R(A) W(A) UNLOCK(A) COMMIT Schedule T1 T2 CMU 15-445/645 (Fall 2018) Lock Manager E X E C U T I N G W I T H LO C K S 5 Granted (T1→A) Denied! Granted (T2→A) Released (T1→A) Released (T2→A)TIME BEGIN LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN LOCK(A) R(A) W(A) UNLOCK(A) COMMIT Schedule T1 T2 CMU 15-445/645 (Fall 2018) T O D AY ' S A G E N D A Lock Types Two-Phase Locking Deadlock Detection + Prevention Hierarchical Locking Isolation Levels 6 CMU 15-445/645 (Fall 2018) LO C K S V S . L AT C H E S 7 Locks Latches User transactions Threads Database Contents In-Memory Data Structures Entire Transactions Critical Sections Shared, Exclusive, Update, Intention Read, Write Deadlock Detection & Resolution Avoidance Waits-for, Timeout, Aborts Coding Discipline Kept Lock Manager Protected Data Structure Source: Goetz Graefe CMU 15-445/645 (Fall 2018) B A S I C LO C K T Y P E S S-LOCK: Shared locks for reads. X-LOCK: Exclusive locks for writes. 8 Shared Exclusive Shared ✔ X Exclusive X X Compatibility Matrix CMU 15-445/645 (Fall 2018) E X E C U T I N G W I T H LO C K S Transactions request locks (or upgrades). Lock manager grants or blocks requests. Transactions release locks. Lock manager updates its internal lock-table. → It keeps track of what transactions hold what locks and what transactions are waiting to acquire any locks. 9 CMU 15-445/645 (Fall 2018) Schedule Lock Manager BEGIN X-LOCK(A) R(A) W(A) UNLOCK(A) S-LOCK(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H LO C K S 10 Granted (T1→A)TIME T1 T2 CMU 15-445/645 (Fall 2018) Schedule Lock Manager BEGIN X-LOCK(A) R(A) W(A) UNLOCK(A) S-LOCK(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H LO C K S 10 Granted (T1→A) Released (T1→A)TIME T1 T2 CMU 15-445/645 (Fall 2018) Schedule Lock Manager BEGIN X-LOCK(A) R(A) W(A) UNLOCK(A) S-LOCK(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H LO C K S 10 Granted (T1→A) Granted (T2→A) Released (T1→A) Released (T2→A)TIME T1 T2 CMU 15-445/645 (Fall 2018) Schedule Lock Manager BEGIN X-LOCK(A) R(A) W(A) UNLOCK(A) S-LOCK(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H LO C K S 10 Granted (T1→A) Granted (T2→A) Released (T1→A) Released (T2→A) Granted (T1→A) Released (T1→A)TIME T1 T2 CMU 15-445/645 (Fall 2018) Schedule Lock Manager BEGIN X-LOCK(A) R(A) W(A) UNLOCK(A) S-LOCK(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H LO C K S 10 Granted (T1→A) Granted (T2→A) Released (T1→A) Released (T2→A) Granted (T1→A) Released (T1→A)TIME T1 T2 CMU 15-445/645 (Fall 2018) C O N C U R R E N C Y C O N T R O L P R O T O C O L Two-phase locking (2PL) is a concurrency control protocol that determines whether a txn is allowed to access an object in the database on the fly. The protocol does not need to know all of the queries that a txn will execute ahead of time. 11 CMU 15-445/645 (Fall 2018) T W O - P H A S E LO C K I N G Phase #1: Growing → Each txn requests the locks that it needs from the DBMS’s lock manager. → The lock manager grants/denies lock requests. Phase #2: Shrinking → The txn is allowed to only release locks that it previously acquired. It cannot acquire new locks. 12 CMU 15-445/645 (Fall 2018) T W O - P H A S E LO C K I N G The txn is not allowed to acquire/upgrade locks after the growing phase finishes. 13# of Locks TIME Growing Phase Shrinking Phase Transaction Lifetime CMU 15-445/645 (Fall 2018) T W O - P H A S E LO C K I N G The txn is not allowed to acquire/upgrade locks after the growing phase finishes. 14 TIME Transaction Lifetime# of Locks 2PL Violation! Growing Phase Shrinking Phase CMU 15-445/645 (Fall 2018) Lock Manager BEGIN X-LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H 2 P L 15 Granted (T1→A)TIME Schedule T1 T2 CMU 15-445/645 (Fall 2018) Lock Manager BEGIN X-LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H 2 P L 15 Granted (T1→A) Denied!TIME Schedule T1 T2 CMU 15-445/645 (Fall 2018) Lock Manager BEGIN X-LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H 2 P L 15 Granted (T1→A) Denied! Released (T1→A)TIME Schedule T1 T2 CMU 15-445/645 (Fall 2018) Lock Manager BEGIN X-LOCK(A) R(A) W(A) R(A) UNLOCK(A) COMMIT BEGIN X-LOCK(A) W(A) UNLOCK(A) COMMIT E X E C U T I N G W I T H 2 P L 15 Granted (T1→A) Denied! Released (T2→A) Released (T1→A) Granted (T2→A)TIME Schedule T1 T2 CMU 15-445/645 (Fall 2018) T W O - P H A S E LO C K I N G 2PL on its own is sufficient to guarantee conflict serializability. → It generates schedules whose precedence graph is acyclic. But it is subject to cascading aborts. 16 CMU 15-445/645 (Fall 2018) Schedule T1 T2 2 P L C A S C A D I N G A B O R T S 17 BEGIN X-LOCK(A) X-LOCK(B) R(A) W(A) UNLOCK(A) R(B) W(B) ABORT BEGIN X-LOCK(A) R(A) W(A) ⋮TIME CMU 15-445/645 (Fall 2018) Schedule T1 T2 2 P L C A S C A D I N G A B O R T S 17 This is a permissible schedule in 2PL, but the DBMS has to also abort T2 when T1 aborts. → Any information about T1 cannot be \"leaked\" to the outside world. BEGIN X-LOCK(A) X-LOCK(B) R(A) W(A) UNLOCK(A) R(B) W(B) ABORT BEGIN X-LOCK(A) R(A) W(A) ⋮ This is all wasted work!TIME CMU 15-445/645 (Fall 2018) 2 P L O B S E R VAT I O N S There are potential schedules that are serializable but would not be allowed by 2PL. → Locking limits concurrency. May still have \"dirty reads\". → Solution: Strict 2PL May lead to deadlocks. → Solution: Detection or Prevention 18 CMU 15-445/645 (Fall 2018) S T R I C T T W O - P H A S E L O C K I N G The txn is not allowed to acquire/upgrade locks after the growing phase finishes. Allows only conflict serializable schedules, but it is often stronger than needed for some apps. 19 TIME# of Locks Release all locks at end of txn. Growing Phase Shrinking Phase CMU 15-445/645 (Fall 2018) S T R I C T T W O - P H A S E L O C K I N G A schedule is strict if a value written by a txn is not read or overwritten by other txns until that txn finishes. Advantages: → Does not incur cascading aborts. → Aborted txns can be undone by just restoring original values of modified tuples. 20 CMU 15-445/645 (Fall 2018) E X A M P L E S T1 – Move $100 from Andy’s account (A) to his bookie’s account (B). T2 – Compute the total amount in all accounts and return it to the application. 21 BEGIN A=A-100 B=B+100 COMMIT BEGIN ECHO A+B COMMIT T1 T2 CMU 15-445/645 (Fall 2018) Schedule T1 T2 N O N - 2 P L E X A M P L E 22 A=1000, B=1000 Initial Database State BEGIN X-LOCK(A) R(A) A=A-100 W(A) UNLOCK(A) X-LOCK(B) R(B) B=B+100 W(B) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) UNLOCK(A) S-LOCK(B) R(B) UNLOCK(B) ECHO A+B COMMITTIME CMU 15-445/645 (Fall 2018) Schedule T1 T2 N O N - 2 P L E X A M P L E 22 A=1000, B=1000 Initial Database State BEGIN X-LOCK(A) R(A) A=A-100 W(A) UNLOCK(A) X-LOCK(B) R(B) B=B+100 W(B) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) UNLOCK(A) S-LOCK(B) R(B) UNLOCK(B) ECHO A+B COMMITTIME CMU 15-445/645 (Fall 2018) Schedule T1 T2 N O N - 2 P L E X A M P L E 22 A=1000, B=1000 Initial Database State BEGIN X-LOCK(A) R(A) A=A-100 W(A) UNLOCK(A) X-LOCK(B) R(B) B=B+100 W(B) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) UNLOCK(A) S-LOCK(B) R(B) UNLOCK(B) ECHO A+B COMMITTIME CMU 15-445/645 (Fall 2018) Schedule T1 T2 N O N - 2 P L E X A M P L E 22 A=1000, B=1000 Initial Database State A+B=1100 T2 Output BEGIN X-LOCK(A) R(A) A=A-100 W(A) UNLOCK(A) X-LOCK(B) R(B) B=B+100 W(B) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) UNLOCK(A) S-LOCK(B) R(B) UNLOCK(B) ECHO A+B COMMITTIME CMU 15-445/645 (Fall 2018) 2 P L E X A M P L E 23 BEGIN X-LOCK(A) R(A) A=A-100 W(A) X-LOCK(B) UNLOCK(A) R(B) B=B+100 W(B) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) S-LOCK(B) R(B) UNLOCK(A) UNLOCK(B) ECHO A+B COMMITTIME Schedule T1 T2 A=1000, B=1000 Initial Database State CMU 15-445/645 (Fall 2018) 2 P L E X A M P L E 23 BEGIN X-LOCK(A) R(A) A=A-100 W(A) X-LOCK(B) UNLOCK(A) R(B) B=B+100 W(B) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) S-LOCK(B) R(B) UNLOCK(A) UNLOCK(B) ECHO A+B COMMITTIME Schedule T1 T2 A=1000, B=1000 Initial Database State CMU 15-445/645 (Fall 2018) 2 P L E X A M P L E 23 BEGIN X-LOCK(A) R(A) A=A-100 W(A) X-LOCK(B) UNLOCK(A) R(B) B=B+100 W(B) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) S-LOCK(B) R(B) UNLOCK(A) UNLOCK(B) ECHO A+B COMMITTIME Schedule T1 T2 A=1000, B=1000 Initial Database State A+B=2000 T2 Output CMU 15-445/645 (Fall 2018) S T R I C T 2 P L E X A M P L E 24 BEGIN X-LOCK(A) R(A) A=A-100 W(A) X-LOCK(B) R(B) B=B+100 W(B) UNLOCK(A) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) S-LOCK(B) R(B) ECHO A+B UNLOCK(A) UNLOCK(B) COMMITTIME Schedule T1 T2 A=1000, B=1000 Initial Database State CMU 15-445/645 (Fall 2018) S T R I C T 2 P L E X A M P L E 24 BEGIN X-LOCK(A) R(A) A=A-100 W(A) X-LOCK(B) R(B) B=B+100 W(B) UNLOCK(A) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) S-LOCK(B) R(B) ECHO A+B UNLOCK(A) UNLOCK(B) COMMITTIME Schedule T1 T2 A=1000, B=1000 Initial Database State CMU 15-445/645 (Fall 2018) S T R I C T 2 P L E X A M P L E 24 BEGIN X-LOCK(A) R(A) A=A-100 W(A) X-LOCK(B) R(B) B=B+100 W(B) UNLOCK(A) UNLOCK(B) COMMIT BEGIN S-LOCK(A) R(A) S-LOCK(B) R(B) ECHO A+B UNLOCK(A) UNLOCK(B) COMMITTIME Schedule T1 T2 A=1000, B=1000 Initial Database State A+B=2000 T2 Output CMU 15-445/645 (Fall 2018) All Schedules U N I V E R S E O F S C H E D U L E S 25 View Serializable Conflict Serializable No Cascading Aborts Serial CMU 15-445/645 (Fall 2018) 2 P L O B S E R VAT I O N S There are potential schedules that are serializable but would not be allowed by 2PL. → Locking limits concurrency. May still have \"dirty reads\". → Solution: Strict 2PL May lead to deadlocks. → Solution: Detection or Prevention 26 CMU 15-445/645 (Fall 2018) Schedule T1 T2 Lock Manager BEGIN X-LOCK(A) R(A) X-LOCK(B) BEGIN S-LOCK(B) R(B) S-LOCK(A) S H I T J U S T G O T R E A L , S O N 27 Granted (T1→A)TIME CMU 15-445/645 (Fall 2018) Schedule T1 T2 Lock Manager BEGIN X-LOCK(A) R(A) X-LOCK(B) BEGIN S-LOCK(B) R(B) S-LOCK(A) S H I T J U S T G O T R E A L , S O N 27 Granted (T1→A) Granted (T2→B)TIME CMU 15-445/645 (Fall 2018) Schedule T1 T2 Lock Manager BEGIN X-LOCK(A) R(A) X-LOCK(B) BEGIN S-LOCK(B) R(B) S-LOCK(A) S H I T J U S T G O T R E A L , S O N 27 Granted (T1→A) Denied! Granted (T2→B)TIME CMU 15-445/645 (Fall 2018) Schedule T1 T2 Lock Manager BEGIN X-LOCK(A) R(A) X-LOCK(B) BEGIN S-LOCK(B) R(B) S-LOCK(A) S H I T J U S T G O T R E A L , S O N 27 Granted (T1→A) Denied! Granted (T2→B) Denied!TIME CMU 15-445/645 (Fall 2018) 2 P L D E A D LO C K S A deadlock is a cycle of transactions waiting for locks to be released by each other. Two ways of dealing with deadlocks: → Approach #1: Deadlock Detection → Approach #2: Deadlock Prevention 28 CMU 15-445/645 (Fall 2018) D E A D LO C K D E T E C T I O N The DBMS creates a waits-for graph to keep track of what locks each txn is waiting to acquire: → Nodes are transactions → Edge from Ti to Tj if Ti is waiting for Tj to release a lock. The system will periodically check for cycles in waits-for graph and then make a decision on how to break it. 29 CMU 15-445/645 (Fall 2018) D E A D LO C K D E T E C T I O N 30 T1 T2 T3 BEGIN S-LOCK(A) S-LOCK(B) BEGIN X-LOCK(B) X-LOCK(C) BEGIN S-LOCK(C) X-LOCK(A)TIME Schedule T1 T2 T3 Waits-For Graph CMU 15-445/645 (Fall 2018) D E A D LO C K D E T E C T I O N 30 T1 T2 T3 BEGIN S-LOCK(A) S-LOCK(B) BEGIN X-LOCK(B) X-LOCK(C) BEGIN S-LOCK(C) X-LOCK(A)TIME Schedule T1 T2 T3 Waits-For Graph CMU 15-445/645 (Fall 2018) D E A D LO C K D E T E C T I O N 30 T1 T2 T3 BEGIN S-LOCK(A) S-LOCK(B) BEGIN X-LOCK(B) X-LOCK(C) BEGIN S-LOCK(C) X-LOCK(A)TIME Schedule T1 T2 T3 Waits-For Graph CMU 15-445/645 (Fall 2018) D E A D LO C K D E T E C T I O N 30 T1 T2 T3 BEGIN S-LOCK(A) S-LOCK(B) BEGIN X-LOCK(B) X-LOCK(C) BEGIN S-LOCK(C) X-LOCK(A)TIME Schedule T1 T2 T3 Waits-For Graph CMU 15-445/645 (Fall 2018) D E A D LO C K H A N D L I N G When the DBMS detects a deadlock, it will select a \"victim\" txn to rollback to break the cycle. The victim txn will either restart or abort(more common) depending on how it was invoked. There is a trade-off between the frequency of checking for deadlocks and how long txns have to wait before deadlocks are broken. 31 CMU 15-445/645 (Fall 2018) D E A D L O C K H A N D L I N G : V I C T I M S E L E C T I O N Selecting the proper victim depends on a lot of different variables…. → By age (lowest timestamp) → By progress (least/most queries executed) → By the # of items already locked → By the # of txns that we have to rollback with it We also should consider the # of times a txn has been restarted in the past to prevent starvation. 32 CMU 15-445/645 (Fall 2018) D E A D L O C K H A N D L I N G : R O L L B A C K L E N G T H After selecting a victim txn to abort, the DBMS can also decide on how far to rollback the txn's changes. Approach #1: Completely Approach #2: Minimally 33 CMU 15-445/645 (Fall 2018) D E A D LO C K P R E V E N T I O N When a txn tries to acquire a lock that is held by another txn, the DBMS kills one of them to prevent a deadlock. This approach does not require a waits-for graph or detection algorithm. 34 CMU 15-445/645 (Fall 2018) D E A D LO C K P R E V E N T I O N Assign priorities based on timestamps: → Older Timestamp = Higher Priority (e.g., T1 > T2) Wait-Die (\"Old Waits for Young\") → If requesting txn has higher priority than holding txn, then requesting txn waits for holding txn. → Otherwise requesting txn aborts. Wound-Wait (\"Young Waits for Old\") → If requesting txn has higher priority than holding txn, then holding txn aborts and releases lock. → Otherwise requesting txn waits. 35 CMU 15-445/645 (Fall 2018) D E A D LO C K P R E V E N T I O N 36 BEGIN X-LOCK(A) ⋮ BEGIN X-LOCK(A) ⋮ BEGIN X-LOCK(A) ⋮ BEGIN X-LOCK(A) ⋮ Wait-Die T1 waits Wound-Wait T2 aborts Wait-Die T2 aborts Wound-Wait T2 waits T1 T2 T1 T2 CMU 15-445/645 (Fall 2018) D E A D LO C K P R E V E N T I O N Why do these schemes guarantee no deadlocks? Only one \"type\" of direction allowed when waiting for a lock. When a txn restarts, what is its (new) priority? Its original timestamp. Why? 37 CMU 15-445/645 (Fall 2018) O B S E R VAT I O N All of these examples have a one-to-one mapping from database objects to locks. If a txn wants to update one billion tuples, then it has to acquire one billion locks. 38 CMU 15-445/645 (Fall 2018) L O C K G R A N U L A R I T I E S When we say that a txn acquires a “lock”, what does that actually mean? → On an Attribute? Tuple? Page? Table? Ideally, each txn should obtain fewest number of locks that is needed… 39 CMU 15-445/645 (Fall 2018) D ATA B A S E LO C K H I E R A R C H Y 40 Database Table 1 Table 2 Tuple 1 Attr 1 Tuple 2 Attr 2 Tuple n Attr n T1 CMU 15-445/645 (Fall 2018) D ATA B A S E LO C K H I E R A R C H Y 40 Database Table 1 Table 2 Tuple 1 Attr 1 Tuple 2 Attr 2 Tuple n Attr n T1 CMU 15-445/645 (Fall 2018) E X A M P L E T1 – Get the balance of Andy’s shady off-shore bank account. T2 – Increase Lin's bank account balance by 1%. What locks should these txns obtain? Multiple: → Exclusive + Shared for leafs of lock tree. → Special Intention locks for higher levels. 41 CMU 15-445/645 (Fall 2018) I N T E N T I O N LO C K S An intention lock allows a higher level node to be locked in shared or exclusive mode without having to check all descendent nodes. If a node is in an intention mode, then explicit locking is being done at a lower level in the tree. 42 CMU 15-445/645 (Fall 2018) I N T E N T I O N LO C K S Intention-Shared (IS) → Indicates explicit locking at a lower level with shared locks. Intention-Exclusive (IX) → Indicates locking at lower level with exclusive or shared locks. 43 CMU 15-445/645 (Fall 2018) I N T E N T I O N LO C K S Shared+Intention-Exclusive (SIX) → The subtree rooted by that node is locked explicitly in shared mode and explicit locking is being done at a lower level with exclusive-mode locks. 44 CMU 15-445/645 (Fall 2018) C O M PAT I B I L I T Y M AT R I X 45 IS IX S SIX X IS ✔ ✔ ✔ ✔ × IX ✔ ✔ × × × S ✔ × ✔ × × SIX ✔ × × × × X × × × × ×T1Holds T2 Wants CMU 15-445/645 (Fall 2018) L O C K I N G P R O T O C O L Each txn obtains appropriate lock at highest level of the database hierarchy. To get S or IS lock on a node, the txn must hold at least IS on parent node. To get X, IX, or SIX on a node, must hold at least IX on parent node. 46 CMU 15-445/645 (Fall 2018) E X A M P L E T W O - L E V E L H I E R A R C H Y 47 Table R Tuple 2Tuple 1 Tuple n T1 Read R. CMU 15-445/645 (Fall 2018) E X A M P L E T W O - L E V E L H I E R A R C H Y 47 Table R Tuple 2Tuple 1 Tuple n T1 S T1 IS T1 Read R. CMU 15-445/645 (Fall 2018) E X A M P L E T W O - L E V E L H I E R A R C H Y 47 Table R Tuple 2Tuple 1 Tuple n T1 S T1 IS T1 T2 Write Update Lin's record in R. CMU 15-445/645 (Fall 2018) E X A M P L E T W O - L E V E L H I E R A R C H Y 47 Table R Tuple 2Tuple 1 Tuple n T1 S T1 IS T1 T2 X T2IX T2 Write Update Lin's record in R. CMU 15-445/645 (Fall 2018) E X A M P L E T H R E E S O M E Assume three txns execute at same time: → T1 – Scan R and update a few tuples. → T2 – Read a single tuple in R. → T3 – Scan all tuples in R. 48 Table R Tuple 2Tuple 1 Tuple n CMU 15-445/645 (Fall 2018) E X A M P L E T H R E E S O M E 49 Table R Tuple 1 Tuple n T1 Read Read+Write Tuple 2 Read Scan R and update a few tuples. CMU 15-445/645 (Fall 2018) E X A M P L E T H R E E S O M E 49 Table R Tuple 1 Tuple n T1 SIX T1 X T1 Tuple 2 Scan R and update a few tuples. CMU 15-445/645 (Fall 2018) E X A M P L E T H R E E S O M E 49 Table R Tuple 1 Tuple n T1 SIX T1 T2 X T1 Read Tuple 2 Read a single tuple in R. CMU 15-445/645 (Fall 2018) E X A M P L E T H R E E S O M E 49 Table R Tuple 1 Tuple n T1 S T2 SIX T1 T2 X T1IS T2 Tuple 2 Read a single tuple in R. CMU 15-445/645 (Fall 2018) E X A M P L E T H R E E S O M E 49 Table R Tuple 1 Tuple n T1 S T2 SIX T1 T2 X T1IS T2 Read T3 Tuple 2 Read Read Scan all tuples in R. CMU 15-445/645 (Fall 2018) E X A M P L E T H R E E S O M E 49 Table R Tuple 1 Tuple n T1 S T2 SIX T1 T2 X T1IS T2 T3 Tuple 2 S T3 Scan all tuples in R. CMU 15-445/645 (Fall 2018) M U LT I P L E LO C K G R A N U L A R I T I E S Hierarchical locks are useful in practice as each txn only needs a few locks. Intention locks help improve concurrency: → Intention-Shared (IS): Intent to get S lock(s) at finer granularity. → Intention-Exclusive (IX): Intent to get X lock(s) at finer granularity. → Shared+Intention-Exclusive (SIX): Like S and IX at the same time. 50 CMU 15-445/645 (Fall 2018) LO C K E S C A L AT I O N Lock escalation dynamically asks for coarser- grained locks when too many low level locks acquired. This reduces the number of requests that the lock manager has to process. 51 CMU 15-445/645 (Fall 2018) L O C K I N G I N P R A C T I C E You typically don't set locks manually in txns. Sometimes you will need to provide the DBMS with hints to help it to improve concurrency. Explicit locks are also useful when doing major changes to the database. 52 CMU 15-445/645 (Fall 2018) LO C K TA B L E Explicitly locks a table. Not part of the SQL standard. → Postgres/DB2/Oracle Modes: SHARE, EXCLUSIVE → MySQL Modes: READ, WRITE 53 LOCK TABLE <table> IN <mode> MODE; LOCK TABLE <table> <mode>; SELECT 1 FROM <table> WITH (TABLOCK, <mode>); CMU 15-445/645 (Fall 2018) S E L E C T. . . F O R U P D AT E Perform a select and then sets an exclusive lock on the matching tuples. Can also set shared locks: → Postgres: FOR SHARE → MySQL: LOCK IN SHARE MODE 54 SELECT * FROM <table> WHERE <qualification> FOR UPDATE; CMU 15-445/645 (Fall 2018) C O N C L U S I O N 2PL is used in almost DBMS. Automatically generates correct interleaving: → Locks + protocol (2PL, S2PL ...) → Deadlock detection + handling → Deadlock prevention 70 CMU 15-445/645 (Fall 2018) N E X T C L A S S Timestamp Ordering Concurrency Control 71","libVersion":"0.2.2","langs":""}