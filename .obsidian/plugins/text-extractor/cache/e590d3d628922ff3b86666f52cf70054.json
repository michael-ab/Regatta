{"path":".obsidian/plugins/text-extractor/cache/e590d3d628922ff3b86666f52cf70054.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 04 Database Storage Part II CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Homework #1 is due September 11th @ 11:59pm Project #1 will be released on September 11th 2 CMU 15-445/645 (Fall 2019) U P C O M I N G D ATA B A S E E V E N T S SalesForce Talk → Friday Sep 13th @ 12:00pm → CIC 4th Floor Impira Talk → Monday Sep 16th @ 4:30pm → GHC 8102 Vertica Talk → Monday Sep 23rd @ 4:30pm → GHC 8102 3 CMU 15-445/645 (Fall 2019) D I S K- O R I E N T E D A R C H I T E C T U R E The DBMS assumes that the primary storage location of the database is on non-volatile disk. The DBMS's components manage the movement of data between non-volatile and volatile storage. 4 CMU 15-445/645 (Fall 2019) S LO T T E D PA G E S The most common layout scheme is called slotted pages. The slot array maps \"slots\" to the tuples' starting position offsets. The header keeps track of: → The # of used slots → The offset of the starting location of the last slot used. 5 Header Tuple #4 Tuple #2 Tuple #3 Tuple #1 Fixed/Var-length Tuple Data Slot Array CMU 15-445/645 (Fall 2019) S LO T T E D PA G E S The most common layout scheme is called slotted pages. The slot array maps \"slots\" to the tuples' starting position offsets. The header keeps track of: → The # of used slots → The offset of the starting location of the last slot used. 5 Header Tuple #4 Tuple #2 Tuple #3 Tuple #1 Fixed/Var-length Tuple Data Slot Array CMU 15-445/645 (Fall 2019) LO G -S T R U C T U R E D F I L E O R G A N I Z AT I O N Instead of storing tuples in pages, the DBMS only stores log records. The system appends log records to the file of how the database was modified: → Inserts store the entire tuple. → Deletes mark the tuple as deleted. → Updates contain the delta of just the attributes that were modified. 6…New EntriesINSERT id=1,val=a INSERT id=2,val=b DELETE id=4 UPDATE val=X (id=3) UPDATE val=Y (id=4) INSERT id=3,val=c Page CMU 15-445/645 (Fall 2019) LO G -S T R U C T U R E D F I L E O R G A N I Z AT I O N To read a record, the DBMS scans the log backwards and \"recreates\" the tuple to find what it needs. 7 INSERT id=1,val=a INSERT id=2,val=b DELETE id=4 UPDATE val=X (id=3) UPDATE val=Y (id=4) INSERT id=3,val=c…Reads Page CMU 15-445/645 (Fall 2019) LO G -S T R U C T U R E D F I L E O R G A N I Z AT I O N To read a record, the DBMS scans the log backwards and \"recreates\" the tuple to find what it needs. Build indexes to allow it to jump to locations in the log. 7 INSERT id=1,val=a INSERT id=2,val=b DELETE id=4 UPDATE val=X (id=3) UPDATE val=Y (id=4) INSERT id=3,val=c… id=1 id=2 id=3 id=4 Page CMU 15-445/645 (Fall 2019) LO G -S T R U C T U R E D F I L E O R G A N I Z AT I O N To read a record, the DBMS scans the log backwards and \"recreates\" the tuple to find what it needs. Build indexes to allow it to jump to locations in the log. Periodically compact the log. 7 id=1,val=a id=2,val=b id=3,val=X id=4,val=Y Page CMU 15-445/645 (Fall 2019) LO G -S T R U C T U R E D F I L E O R G A N I Z AT I O N To read a record, the DBMS scans the log backwards and \"recreates\" the tuple to find what it needs. Build indexes to allow it to jump to locations in the log. Periodically compact the log. 7 id=1,val=a id=2,val=b id=3,val=X id=4,val=Y Page CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A Data Representation System Catalogs Storage Models 8 CMU 15-445/645 (Fall 2019) T U P L E S T O R A G E A tuple is essentially a sequence of bytes. It's the job of the DBMS to interpret those bytes into attribute types and values. The DBMS's catalogs contain the schema information about tables that the system uses to figure out the tuple's layout. 9 CMU 15-445/645 (Fall 2019) D ATA R E P R E S E N TAT I O N INTEGER/BIGINT/SMALLINT/TINYINT → C/C++ Representation FLOAT/REAL vs. NUMERIC/DECIMAL → IEEE-754 Standard / Fixed-point Decimals VARCHAR/VARBINARY/TEXT/BLOB → Header with length, followed by data bytes. TIME/DATE/TIMESTAMP → 32/64-bit integer of (micro)seconds since Unix epoch 10 CMU 15-445/645 (Fall 2019) VA R I A B L E P R E C I S I O N N U M B E R S Inexact, variable-precision numeric type that uses the \"native\" C/C++ types. → Examples: FLOAT, REAL/DOUBLE Store directly as specified by IEEE-754. Typically faster than arbitrary precision numbers but can have rounding errors… 11 CMU 15-445/645 (Fall 2019) VA R I A B L E P R E C I S I O N N U M B E R S 12 #include <stdio.h> int main(int argc, char* argv[]) { float x = 0.1; float y = 0.2; printf(\"x+y = %f\\n\", x+y); printf(\"0.3 = %f\\n\", 0.3); } Rounding Example x+y = 0.300000 0.3 = 0.300000 Output CMU 15-445/645 (Fall 2019) VA R I A B L E P R E C I S I O N N U M B E R S 12 #include <stdio.h> int main(int argc, char* argv[]) { float x = 0.1; float y = 0.2; printf(\"x+y = %f\\n\", x+y); printf(\"0.3 = %f\\n\", 0.3); } Rounding Example x+y = 0.300000 0.3 = 0.300000 Output #include <stdio.h> int main(int argc, char* argv[]) { float x = 0.1; float y = 0.2; printf(\"x+y = %.20f\\n\", x+y); printf(\"0.3 = %.20f\\n\", 0.3); } x+y = 0.30000001192092895508 0.3 = 0.29999999999999998890 CMU 15-445/645 (Fall 2019) F I X E D P R E C I S I O N N U M B E R S Numeric data types with arbitrary precision and scale. Used when round errors are unacceptable. → Example: NUMERIC, DECIMAL Typically stored in a exact, variable-length binary representation with additional meta-data. → Like a VARCHAR but not stored as a string Demo: Postgres, SQL Server, Oracle 13 CMU 15-445/645 (Fall 2019) P O S T G R E S : N U M E R I C 14 typedef unsigned char NumericDigit; typedef struct { int ndigits; int weight; int scale; int sign; NumericDigit *digits; } numeric; # of Digits Weight of 1st Digit Scale Factor Positive/Negative/NaN Digit Storage CMU 15-445/645 (Fall 2019) P O S T G R E S : N U M E R I C 14 typedef unsigned char NumericDigit; typedef struct { int ndigits; int weight; int scale; int sign; NumericDigit *digits; } numeric; # of Digits Weight of 1st Digit Scale Factor Positive/Negative/NaN Digit Storage CMU 15-445/645 (Fall 2019) L A R G E VA L U E S Most DBMSs don't allow a tuple to exceed the size of a single page. To store values that are larger than a page, the DBMS uses separate overflow storage pages. → Postgres: TOAST (>2KB) → MySQL: Overflow (>½ size of page) → SQL Server: Overflow (>size of page) 15 Overflow Page VARCHAR DATA Tuple Header a b c d e CMU 15-445/645 (Fall 2019) E X T E R N A L VA L U E S T O R A G E Some systems allow you to store a really large value in an external file. Treated as a BLOB type. → Oracle: BFILE data type → Microsoft: FILESTREAM data type The DBMS cannot manipulate the contents of an external file. → No durability protections. → No transaction protections. 16 Data Header a b c d e External File Tuple CMU 15-445/645 (Fall 2019) E X T E R N A L VA L U E S T O R A G E Some systems allow you to store a really large value in an external file. Treated as a BLOB type. → Oracle: BFILE data type → Microsoft: FILESTREAM data type The DBMS cannot manipulate the contents of an external file. → No durability protections. → No transaction protections. 16 Data Header a b c d e External File Tuple CMU 15-445/645 (Fall 2019) S Y S T E M C ATA LO G S A DBMS stores meta-data about databases in its internal catalogs. → Tables, columns, indexes, views → Users, permissions → Internal statistics Almost every DBMS stores their a database's catalog in itself. → Wrap object abstraction around tuples. → Specialized code for \"bootstrapping\" catalog tables. 17 CMU 15-445/645 (Fall 2019) S Y S T E M C ATA LO G S You can query the DBMS’s internal INFORMATION_SCHEMA catalog to get info about the database. → ANSI standard set of read-only views that provide info about all of the tables, views, columns, and procedures in a database DBMSs also have non-standard shortcuts to retrieve this information. 18 CMU 15-445/645 (Fall 2019) A C C E S S I N G TA B L E S C H E M A List all the tables in the current database: 19 SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE table_catalog = '<db name>'; SQL-92 \\d; Postgres SHOW TABLES; MySQL .tables; SQLite CMU 15-445/645 (Fall 2019) A C C E S S I N G TA B L E S C H E M A List all the tables in the student table: 20 SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE table_name = 'student' SQL-92 \\d student; Postgres DESCRIBE student; MySQL .schema student; SQLite CMU 15-445/645 (Fall 2019) O B S E R VAT I O N The relational model does not specify that we have to store all of a tuple's attributes together in a single page. This may not actually be the best layout for some workloads… 23 CMU 15-445/645 (Fall 2019) W I K I P E D I A E X A M P L E 24 CREATE TABLE revisions ( revID INT PRIMARY KEY, userID INT REFERENCES useracct (userID), pageID INT REFERENCES pages (pageID), content TEXT, updated DATETIME ); CREATE TABLE pages ( pageID INT PRIMARY KEY, title VARCHAR UNIQUE, latest INT ⮱REFERENCES revisions (revID), ); CREATE TABLE useracct ( userID INT PRIMARY KEY, userName VARCHAR UNIQUE, ⋮ ); CMU 15-445/645 (Fall 2019) O LT P On-line Transaction Processing: → Simple queries that read/update a small amount of data that is related to a single entity in the database. This is usually the kind of application that people build first. 25 UPDATE useracct SET lastLogin = NOW(), hostname = ? WHERE userID = ? INSERT INTO revisions VALUES (?,?…,?) SELECT P.*, R.* FROM pages AS P INNER JOIN revisions AS R ON P.latest = R.revID WHERE P.pageID = ? CMU 15-445/645 (Fall 2019) O L A P On-line Analytical Processing: → Complex queries that read large portions of the database spanning multiple entities. You execute these workloads on the data you have collected from your OLTP application(s). 26 SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) W O R K LO A D C H A R A C T E R I Z AT I O N Writes Reads Simple Complex Workload FocusOperation Complexity OLTP OLAP [SOURCE] HTAP CMU 15-445/645 (Fall 2019) D ATA S T O R A G E M O D E L S The DBMS can store tuples in different ways that are better for either OLTP or OLAP workloads. We have been assuming the n-ary storage model (aka \"row storage\") so far this semester. 28 CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) The DBMS stores all attributes for a single tuple contiguously in a page. Ideal for OLTP workloads where queries tend to operate only on an individual entity and insert- heavy workloads. 29 CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) The DBMS stores all attributes for a single tuple contiguously in a page. 30 ←Tuple #1 ←Tuple #2 ←Tuple #3 ←Tuple #4 userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname - - - -- Header Header Header Header CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) The DBMS stores all attributes for a single tuple contiguously in a page. 30 NSM Disk Page userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname - - - -- Header Header Header Header CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) 31 SELECT * FROM useracct WHERE userName = ? AND userPass = ? Index NSM Disk Page userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname - - - -- Header Header Header Header Lecture 7 CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) 31 SELECT * FROM useracct WHERE userName = ? AND userPass = ? Index INSERT INTO useracct VALUES (?,?,…?) NSM Disk Page userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname - - - -- Header Header Header Header userID userName userPass lastLoginhostnameHeader Lecture 7 CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) 32 SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) 32 NSM Disk Page userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname Header Header Header Header SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) 32 NSM Disk Page userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname Header Header Header Header SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) 32 NSM Disk Page userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname Header Header Header Header SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L ( N S M ) 32 NSM Disk Page userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname Header Header Header Header Useless Data SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) N- A R Y S T O R A G E M O D E L Advantages → Fast inserts, updates, and deletes. → Good for queries that need the entire tuple. Disadvantages → Not good for scanning large portions of the table and/or a subset of the attributes. 33 CMU 15-445/645 (Fall 2019) D E C O M P O S I T I O N S T O R A G E M O D E L ( D S M ) The DBMS stores the values of a single attribute for all tuples contiguously in a page. → Also known as a \"column store\". Ideal for OLAP workloads where read-only queries perform large scans over a subset of the table’s attributes. 34 CMU 15-445/645 (Fall 2019) D E C O M P O S I T I O N S T O R A G E M O D E L ( D S M ) The DBMS stores the values of a single attribute for all tuples contiguously in a page. → Also known as a \"column store\". 35 userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname userID userName userPass lastLoginhostname Header Header Header Header CMU 15-445/645 (Fall 2019) D E C O M P O S I T I O N S T O R A G E M O D E L ( D S M ) The DBMS stores the values of a single attribute for all tuples contiguously in a page. → Also known as a \"column store\". 35 userID userName userPass DSM Disk Page hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname lastLogin CMU 15-445/645 (Fall 2019) D E C O M P O S I T I O N S T O R A G E M O D E L ( D S M ) 36 SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) DSM Disk Page hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname hostname D E C O M P O S I T I O N S T O R A G E M O D E L ( D S M ) 36 SELECT COUNT(U.lastLogin), EXTRACT(month FROM U.lastLogin) AS month FROM useracct AS U WHERE U.hostname LIKE '%.gov' GROUP BY EXTRACT(month FROM U.lastLogin) CMU 15-445/645 (Fall 2019) T U P L E I D E N T I F I C AT I O N Choice #1: Fixed-length Offsets → Each value is the same length for an attribute. Choice #2: Embedded Tuple Ids → Each value is stored with its tuple id in a column. 37 Offsets 0 1 2 3 A B C D Embedded Ids A 0 1 2 3 B 0 1 2 3 C 0 1 2 3 D 0 1 2 3 CMU 15-445/645 (Fall 2019) D E C O M P O S I T I O N S T O R A G E M O D E L ( D S M ) Advantages → Reduces the amount wasted I/O because the DBMS only reads the data that it needs. → Better query processing and data compression (more on this later). Disadvantages → Slow for point queries, inserts, updates, and deletes because of tuple splitting/stitching. 38 CMU 15-445/645 (Fall 2019) D S M S Y S T E M H I S T O R Y 1970s: Cantor DBMS 1980s: DSM Proposal 1990s: SybaseIQ (in-memory only) 2000s: Vertica, VectorWise, MonetDB 2010s: Everyone 39 CMU 15-445/645 (Fall 2019) C O N C L U S I O N The storage manager is not entirely independent from the rest of the DBMS. It is important to choose the right storage model for the target workload: → OLTP = Row Store → OLAP = Column Store 40 CMU 15-445/645 (Fall 2019) D ATA B A S E S T O R A G E Problem #1: How the DBMS represents the database in files on disk. Problem #2: How the DBMS manages its memory and move data back-and-forth from disk. 41 ← Next","libVersion":"0.2.2","langs":""}