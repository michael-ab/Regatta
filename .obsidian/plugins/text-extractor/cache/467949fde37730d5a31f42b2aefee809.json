{"path":".obsidian/plugins/text-extractor/cache/467949fde37730d5a31f42b2aefee809.json","text":"Database Systems 15-445/15-645 Fall 2018 Andy Pavlo Computer Science Carnegie Mellon Univ.AP Lecture #19 Multi-Version Concurrency Control CMU 15-445/645 (Fall 2018) A D M I N I S T R I V I A Homework #4: Monday Nov 12th @ 11:59pm Project #3: Monday Nov 19th @ 11:59am 2 CMU 15-445/645 (Fall 2018) M U LT I -V E R S I O N C O N C U R R E N C Y C O N T R O L The DBMS maintains multiple physical versions of a single logical object in the database: → When a txn writes to an object, the DBMS creates a new version of that object. → When a txn reads an object, it reads the newest version that existed when the txn started. 3 CMU 15-445/645 (Fall 2018) M V C C H I S T O R Y Protocol was first proposed in 1978 MIT PhD dissertation. First implementations was Rdb/VMS and InterBase at DEC in early 1980s. → Both were by Jim Starkey, co-founder of NuoDB. → DEC Rdb/VMS is now \"Oracle Rdb\" → InterBase was open-sourced as Firebird. 4 CMU 15-445/645 (Fall 2018) M U LT I -V E R S I O N C O N C U R R E N C Y C O N T R O L Writers don't block readers. Readers don't block writers. Read-only txns can read a consistent snapshot without acquiring locks. → Use timestamps to determine visibility. Easily support time-travel queries. 5 CMU 15-445/645 (Fall 2018) Version Value Begin End A0 123 0 -TIME Schedule T1 T2 M V C C E X A M P L E # 1 6 BEGIN R(A) R(A) COMMIT BEGIN W(A) COMMIT Database CMU 15-445/645 (Fall 2018) Version Value Begin End A0 123 0 -TIME Schedule T1 T2 M V C C E X A M P L E # 1 6 BEGIN R(A) R(A) COMMIT BEGIN W(A) COMMIT Database CMU 15-445/645 (Fall 2018) Version Value Begin End A0 123 0 -TIME Schedule T1 T2 M V C C E X A M P L E # 1 6 BEGIN R(A) R(A) COMMIT BEGIN W(A) COMMIT TS(T1)=1 TS(T2)=2 Database CMU 15-445/645 (Fall 2018) Version Value Begin End A0 123 0 -TIME Schedule T1 T2 M V C C E X A M P L E # 1 6 BEGIN R(A) R(A) COMMIT BEGIN W(A) COMMIT TS(T1)=1 TS(T2)=2 Database CMU 15-445/645 (Fall 2018) Version Value Begin End A0 123 0 -TIME Schedule T1 T2 M V C C E X A M P L E # 1 6 BEGIN R(A) R(A) COMMIT BEGIN W(A) COMMIT -2456A1 TS(T1)=1 TS(T2)=2 Database T2 creates version A1 and sets A0 End-TS. CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active T2 2 Active Txn Status Table Version Value Begin End A0 123 0 -TIME Schedule T1 T2 M V C C E X A M P L E # 1 6 BEGIN R(A) R(A) COMMIT BEGIN W(A) COMMIT 2 -2456A1 TS(T1)=1 TS(T2)=2 Database T2 creates version A1 and sets A0 End-TS. CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active T2 2 Active Txn Status Table Version Value Begin End A0 123 0 -TIME Schedule T1 T2 M V C C E X A M P L E # 1 6 BEGIN R(A) R(A) COMMIT BEGIN W(A) COMMIT 2 T1 reads version A0. -2456A1 TS(T1)=1 TS(T2)=2 Database CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT TS(T1)=1 TS(T2)=2 Database CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT TS(T1)=1 TS(T2)=2 Database CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT -1456A1 TS(T1)=1 TS(T2)=2 Database CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT 1 -1456A1 TS(T1)=1 TS(T2)=2 Database CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT 1 -1456A1 TS(T1)=1 TS(T2)=2 Database Active2T2 T2 reads version A0 because T1 has not committed yet. CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT 1 -1456A1 TS(T1)=1 TS(T2)=2 Database Active2T2 T2 has to stall until T1 commits. CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT 1 T1 reads version A1 that it wrote earlier. -1456A1 TS(T1)=1 TS(T2)=2 Database Active2T2 CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT 1 -1456A1 TS(T1)=1 TS(T2)=2 Database Active2T2 Committed1T1 CMU 15-445/645 (Fall 2018) TxnId Timestamp Status T1 1 Active Txn Status Table Version Value Begin End A0 123 0TIME Schedule T1 T2 M V C C E X A M P L E # 2 7 BEGIN R(A) W(A) R(A) COMMIT BEGIN R(A) W(A) COMMIT 1 -1456A1 2 -2789A2 TS(T1)=1 TS(T2)=2 Database Active2T2 Committed1T1 Now T2 can create the new version. CMU 15-445/645 (Fall 2018) M U LT I -V E R S I O N C O N C U R R E N C Y C O N T R O L MVCC is more than just a concurrency control protocol. It completely affects how the DBMS manages transactions and the database. 8 CMU 15-445/645 (Fall 2018) M V C C D E S I G N D E C I S I O N S Concurrency Control Protocol Version Storage Garbage Collection Index Management 9 CMU 15-445/645 (Fall 2018) C O N C U R R E N C Y C O N T R O L P R O T O C O L Approach #1: Timestamp Ordering → Assign txns timestamps that determine serial order. Approach #2: Optimistic Concurrency Control → Three-phase protocol from last class. → Use private workspace for new versions. Approach #3: Two-Phase Locking → Txns acquire appropriate lock on physical version before they can read/write a logical tuple. 10 CMU 15-445/645 (Fall 2018) V E R S I O N S T O R A G E The DBMS uses the tuples’ pointer field to create a version chain per logical tuple. → This allows the DBMS to find the version that is visible to a particular txn at runtime. → Indexes always point to the “head” of the chain. Different storage schemes determine where/what to store for each version. 11 CMU 15-445/645 (Fall 2018) V E R S I O N S T O R A G E Approach #1: Append-Only Storage → New versions are appended to the same table space. Approach #2: Time-Travel Storage → Old versions are copied to separate table space. Approach #3: Delta Storage → The original values of the modified attributes are copied into a separate delta record space. 12 CMU 15-445/645 (Fall 2018) A P P E N D - O N LY S T O R A G E All of the physical versions of a logical tuple are stored in the same table space. The versions are mixed together. On every update, append a new version of the tuple into an empty space in the table. 13 Main Table VERSION VALUE A0 $111 POINTER A1 $222 Ø B1 $10 Ø CMU 15-445/645 (Fall 2018) A P P E N D - O N LY S T O R A G E All of the physical versions of a logical tuple are stored in the same table space. The versions are mixed together. On every update, append a new version of the tuple into an empty space in the table. 13 Main Table VERSION VALUE A0 $111 POINTER A1 $222 Ø A2 $333 Ø B1 $10 Ø CMU 15-445/645 (Fall 2018) A P P E N D - O N LY S T O R A G E All of the physical versions of a logical tuple are stored in the same table space. The versions are mixed together. On every update, append a new version of the tuple into an empty space in the table. 13 Main Table VERSION VALUE A0 $111 POINTER A1 $222 Ø A2 $333 Ø B1 $10 Ø CMU 15-445/645 (Fall 2018) A P P E N D - O N LY S T O R A G E All of the physical versions of a logical tuple are stored in the same table space. The versions are mixed together. On every update, append a new version of the tuple into an empty space in the table. 13 Main Table VERSION VALUE A0 $111 POINTER A1 $222 A2 $333 Ø B1 $10 Ø CMU 15-445/645 (Fall 2018) V E R S I O N C H A I N O R D E R I N G Approach #1: Oldest-to-Newest (O2N) → Just append new version to end of the chain. → Have to traverse chain on look-ups. Approach #2: Newest-to-Oldest (N2O) → Have to update index pointers for every new version. → Don’t have to traverse chain on look ups. 14 CMU 15-445/645 (Fall 2018) T I M E-T R AV E L S T O R A G E 15 On every update, copy the current version to the time- travel table. Update pointers. Main Table VERSION VALUE A2 $222 POINTER B1 $10 Time-Travel Table VERSION VALUE A1 $111 POINTER Ø CMU 15-445/645 (Fall 2018) T I M E-T R AV E L S T O R A G E 15 On every update, copy the current version to the time- travel table. Update pointers. Main Table VERSION VALUE A2 $222 POINTER B1 $10 Time-Travel Table VERSION VALUE A1 $111 POINTER A2 $222 Ø CMU 15-445/645 (Fall 2018) T I M E-T R AV E L S T O R A G E 15 On every update, copy the current version to the time- travel table. Update pointers. Overwrite master version in the main table. Update pointers. Main Table VERSION VALUE A2 $222 POINTER B1 $10 Time-Travel Table VERSION VALUE A1 $111 POINTER A2 $222 Ø CMU 15-445/645 (Fall 2018) T I M E-T R AV E L S T O R A G E 15 On every update, copy the current version to the time- travel table. Update pointers. Overwrite master version in the main table. Update pointers. Main Table VERSION VALUE A2 $222 POINTER B1 $10 A3 $333 Time-Travel Table VERSION VALUE A1 $111 POINTER A2 $222 Ø CMU 15-445/645 (Fall 2018) T I M E-T R AV E L S T O R A G E 15 On every update, copy the current version to the time- travel table. Update pointers. Overwrite master version in the main table. Update pointers. Main Table VERSION VALUE A2 $222 POINTER B1 $10 A3 $333 Time-Travel Table VERSION VALUE A1 $111 POINTER A2 $222 Ø CMU 15-445/645 (Fall 2018) D E LTA S T O R A G E 16 On every update, copy only the values that were modified to the delta storage and overwrite the master version. Main Table VERSION VALUE A1 $111 POINTER B1 $10 Delta Storage Segment CMU 15-445/645 (Fall 2018) D E LTA S T O R A G E 16 On every update, copy only the values that were modified to the delta storage and overwrite the master version. Main Table VERSION VALUE A1 $111 POINTER B1 $10 Delta Storage Segment DELTA POINTER A1 (VALUE→$111) ØA2 $222 CMU 15-445/645 (Fall 2018) D E LTA S T O R A G E 16 On every update, copy only the values that were modified to the delta storage and overwrite the master version. Main Table VERSION VALUE A1 $111 POINTER B1 $10 Delta Storage Segment DELTA POINTER A2 (VALUE→$222) A1 (VALUE→$111) ØA2 $222 CMU 15-445/645 (Fall 2018) D E LTA S T O R A G E 16 On every update, copy only the values that were modified to the delta storage and overwrite the master version. Txns can recreate old versions by applying the delta in reverse order. Main Table VERSION VALUE A1 $111 POINTER B1 $10 Delta Storage Segment DELTA POINTER A2 (VALUE→$222) A1 (VALUE→$111) ØA2 $222A3 $333 CMU 15-445/645 (Fall 2018) G A R B A G E C O L L E C T I O N The DBMS needs to remove reclaimable physical versions from the database over time. → No active txn in the DBMS can “see” that version (SI). → The version was created by an aborted txn. Two additional design decisions: → How to look for expired versions? → How to decide when it is safe to reclaim memory? 17 CMU 15-445/645 (Fall 2018) G A R B A G E C O L L E C T I O N Approach #1: Tuple-level → Find old versions by examining tuples directly. → Background Vacuuming vs. Cooperative Cleaning Approach #2: Transaction-level → Txns keep track of their old versions so the DBMS does not have to scan tuples to determine visibility. 18 CMU 15-445/645 (Fall 2018) VERSION BEGIN END A100 1 9 B100 1 9 B101 10 20 T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Vacuum CMU 15-445/645 (Fall 2018) VERSION BEGIN END A100 1 9 B100 1 9 B101 10 20 T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Vacuum CMU 15-445/645 (Fall 2018) VERSION BEGIN END A100 1 9 B100 1 9 B101 10 20 T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Vacuum CMU 15-445/645 (Fall 2018) VERSION BEGIN END A100 1 9 B100 1 9 B101 10 20 T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Vacuum CMU 15-445/645 (Fall 2018) VERSION BEGIN END A100 1 9 B100 1 9 B101 10 20 T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 VacuumDirty Page BitMap CMU 15-445/645 (Fall 2018) VERSION BEGIN END A100 1 9 B100 1 9 B101 10 20 T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 VacuumDirty Page BitMap CMU 15-445/645 (Fall 2018) T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Cooperative Cleaning: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N. A2 A3 B0 B1 B2 B3 INDEX A0 A1GET(A) CMU 15-445/645 (Fall 2018) T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Cooperative Cleaning: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N. A2 A3 B0 B1 B2 B3 INDEX A0 A1GET(A) CMU 15-445/645 (Fall 2018) T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Cooperative Cleaning: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N. A2 A3 B0 B1 B2 B3 INDEX A0 A1X GET(A) CMU 15-445/645 (Fall 2018) T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Cooperative Cleaning: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N. A2 A3 B0 B1 B2 B3 INDEX A0 A1X X GET(A) CMU 15-445/645 (Fall 2018) T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Cooperative Cleaning: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N. A2 A3 B0 B1 B2 B3 INDEX GET(A) CMU 15-445/645 (Fall 2018) T U P L E- L E V E L G C 19 Background Vacuuming: Separate thread(s) periodically scan the table and look for reclaimable versions. Works with any storage. Thread #1 TS(T1)=12 Thread #2 TS(T2)=25 Cooperative Cleaning: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N. A2 A3 B0 B1 B2 B3 INDEX GET(A) CMU 15-445/645 (Fall 2018) T R A N S A C T I O N - L E V E L G C Each txn keeps track of its read/write set. The DBMS determines when all versions created by a finished txn are no longer visible. 20 CMU 15-445/645 (Fall 2018) I N D E X M A N A G E M E N T Primary key indexes point to version chain head. → How often the DBMS has to update the pkey index depends on whether the system creates new versions when a tuple is updated. → If a txn updates a tuple’s pkey attribute(s), then this is treated as an DELETE followed by an INSERT. Secondary indexes are more complicated… 21 CMU 15-445/645 (Fall 2018) I N D E X M A N A G E M E N T Primary key indexes point to version chain head. → How often the DBMS has to update the pkey index depends on whether the system creates new versions when a tuple is updated. → If a txn updates a tuple’s pkey attribute(s), then this is treated as an DELETE followed by an INSERT. Secondary indexes are more complicated… 21 CMU 15-445/645 (Fall 2018) S E C O N D A R Y I N D E X E S Approach #1: Logical Pointers → Use a fixed identifier per tuple that does not change. → Requires an extra indirection layer. → Primary Key vs. Tuple Id Approach #2: Physical Pointers → Use the physical address to the version chain head. 22 CMU 15-445/645 (Fall 2018) I N D E X P O I N T E R S 23 PRIMARY INDEX SECONDARY INDEX A100 A99 A98 A97 GET(A) Append-Only Newest-to-Oldest Physical Address CMU 15-445/645 (Fall 2018) I N D E X P O I N T E R S 23 PRIMARY INDEX SECONDARY INDEX A100 A99 A98 A97 Append-Only Newest-to-Oldest GET(A) Physical Address CMU 15-445/645 (Fall 2018) SECONDARY INDEX SECONDARY INDEX SECONDARY INDEX I N D E X P O I N T E R S 23 PRIMARY INDEX SECONDARY INDEX A100 A99 A98 A97 Append-Only Newest-to-Oldest GET(A) CMU 15-445/645 (Fall 2018) I N D E X P O I N T E R S 23 PRIMARY INDEX SECONDARY INDEX A100 A99 A98 A97 Append-Only Newest-to-Oldest GET(A) Physical Address Primary Key CMU 15-445/645 (Fall 2018) I N D E X P O I N T E R S 23 PRIMARY INDEX SECONDARY INDEX A100 A99 A98 A97 Append-Only Newest-to-Oldest GET(A) TupleId→Address TupleId Physical Address CMU 15-445/645 (Fall 2018) M V C C I M P L E M E N TAT I O N S 24 Protocol Version Storage Garbage Collection Indexes Oracle MV2PL Delta Vacuum Logical Postgres MV-2PL/MV-TO Append-Only Vacuum Physical MySQL-InnoDB MV-2PL Delta Vacuum Logical HYRISE MV-OCC Append-Only – Physical Hekaton MV-OCC Append-Only Cooperative Physical MemSQL MV-OCC Append-Only Vacuum Physical SAP HANA MV-2PL Time-travel Hybrid Logical NuoDB MV-2PL Append-Only Vacuum Logical HyPer MV-OCC Delta Txn-level Logical CMU 15-445/645 (Fall 2018) C O N C L U S I O N MVCC is the widely used scheme in DBMSs. Even systems that do not support multi-statement txns (e.g., NoSQL) use it. 25 CMU 15-445/645 (Fall 2018) N E X T C L A S S Logging & Recovery 26","libVersion":"0.2.2","langs":""}