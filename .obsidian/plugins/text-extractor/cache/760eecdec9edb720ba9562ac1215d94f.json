{"path":".obsidian/plugins/text-extractor/cache/760eecdec9edb720ba9562ac1215d94f.json","text":"Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #1: Introduction Goal of this Course Teach you how to ‚Äúengineer‚Äù software Help you become better programmers Teach you how to write code of higher quality increased complexity 2 What is High Quality? Code is high quality when it is Correct Easy to change 3 Goals of Software System Building Building the right system Does the program meet the user‚Äôs needs? Determining this is usually called validation Building the system right Does the program meet the specification? Determining this is usually called verification 4 What We Will Cover in the Course Material covered in this course partly overlaps with three courses in the CS faculty: 1. Object oriented programming (236703) 2. Software engineering methods (236321) 3. Software design (236700) Emphasis on design 5 Principles vs. Tools You will learn how to design software using some powerful abstraction mechanisms and techniques that have been found to work well in practice Modularity, documentation, testing, ‚Ä¶. You will use tools Java, JUnit, UML, ‚Ä¶ IDEs, debuggers, ‚Ä¶ Tools change, principles are forever 6 Main Topics Covered in the Course Abstraction and Specification Procedural, object-oriented Writing, understanding, and reasoning about code Pragmatic considerations Defensive programming Testing and debugging The software development process Requirements specification Design and implementation 7 Main Topics Covered in the Course Design What makes a design good or bad The process of design Design rules of thumb Design patterns 8 Prerequisites Introduction to Software Systems ( ◊û◊û\"◊™ , 044101) / Introduction to Systems Programming ( ◊™◊û\"◊û , 234122) A basis for the course + Introduction to Data Structures and Algorithms (044268) / Data Structures 1 (234218) Needed for solving some of the assignments 9 Books 10 Books 11 Administrivia Lecturer: Yair Moshe yair@ee, Meyer 504 Teaching assistants: Oded Naor (in charge) - odednaor@campus Amir Avivi - saavivi@campus Homework checker: ? Course website: @Technion‚Äôs Moodle Contains all course material and announcements Forums for discussions (staff will participate) Please e-mail staff only for things that don‚Äôt make sense to post on the forums 12 Lectures and Tutorials Lectures and tutorials are related and complementary, not necessarily repeat the same material Tutorials contain more examples and are more focused on tools 13 Lectures and Tutorials All materials are posted but they are visual aids It is highly recommended you attend (@zoom) If you don‚Äôt feel that arriving to the lectures and tutorials helps you, one of us is messing up Short Kahoot quizzes Keep you awake an engaged Bonus in final grade for students with best 3 Kahoot scores 14 Assignments 5 homework assignments One warmup (#0) + 4 heavy-duty assignments Some ‚Äúwet‚Äù, some ‚Äúdry‚Äù Submission in couples only Assignment submission is a must No submission for all 4 heavy-duty assignments ‚Üí no grade in the course! 15 Exams Focused on concepts learned in class With open material Structure and level of difficulty similar to before COVID-19 Solved past exams in the course website 16 Grading 75% Final exam 25% Homework Assignment #0 ‚Äì 1 point Other assignments ‚Äì 6 points each But if examGrade ‚â§ 65 finalGrade = examGrade 17 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #2: Introduction to Software Engineering Why Software Engineering Matters More and more systems are software controlled Software costs often > hardware system costs 2 Why Software Engineering Matters Many applications System, real-time, business, engineering and scientific, embedded, personal computer, web based, ‚Ä¶ The economies of all developed nations are dependent on software Let‚Äôs see some (bad) examples 3 Ariane 5 (1996) A European heavy-lift launch vehicle Self-destructed 37 seconds after launch 4 Ariane 5 (1996) 5 Ariane 5 (1996) A European heavy-lift launch vehicle Self-destructed 37 seconds after launch Loss of more than US$370 million Cause: Failure of conversion of the velocity of the rocket from 64-bit floating point to 16-bit signed integer Dead code left from Ariane 4 led to an exception handled inappropriately, halting the whole inertial navigation system 6 Therac-25 (1985-1987) A radiation therapy machine Massively overdosed at least six people Causes: Concurrent programming error in case of fast user switching from one radiation mode to another No hardware interlocks to prevent such faults 7 Patriot at Dharan (1991) A surface-to-air missile Used during the Gulf War in Saudi Arabia Failed to track and intercept an incoming Iraqi Scud missile 28 American soldiers killed, 100 injured Cause: An inaccurate calculation of the time since boot due to computer arithmetic errors The battery was operating for 100 hours, by which time the system‚Äôs internal clock had drifted by ‚Öì of a second Due to the missile‚Äôs speed this was equivalent to a miss distance of 600 meters 8 Northeast Blackout (2003) A widespread power outage that occurred throughout parts of the Northeastern and Midwestern United States Affected about 55 million people Most people got their power back only after two days Cause: A race condition in General Electric‚Äôs energy management system 9 Knight Capital's loss (2012) An American supplier of global financial services Its trading algorithm was the largest trader in U.S. equities, with a market share of 16.9% on NASDAQ Took a loss of $440 million Cause: Accidently deployed untested software to a production environment 10 787 Dreamliner electrical systems can fail (2015) Cause: AC generator control units going into failsafe mode 11 Standish Group 2015 Chaos Report 12 Standish Group 2015 Chaos Report 1314 What matters in commercial software development? 15 Commercial Software Development Engineering is all about money Engineers often forget this Business folks usually don‚Äôt ‚ò∫ Software systems cost too much to build Software systems take too long to build Software systems don‚Äôt do what people want them to do Or even need them to do 16 Why? Because building good software is hard ! 17 Why Software Development is Hard Software is long-lived Large software systems are enormously complex People expect software to be adaptable Very law manufacturing cost Extreme modifiability After all, it‚Äôs ‚Äúonly software‚Äù Software has no borders and no ‚Äúfundamentals laws‚Äù We are always trying to do new things with software 18 Software Size 19 A Million Lines of Code Would take 18,000 printed pages ‚âà 14 copied of War and Piece Requires 40,000 pages of external documentation Will typically have 100,000 bugs pre-test The effort required is about x22 (and not x10) than for 100,000 lines of code Occupy 223 person-years 20 Size Does Matter 21 vs. Small Software vs. Large Software 22 Small Size Large Size Single developer (architect = developer = manager = tester) Team of developers with multiple roles (architect ‚â† developer ‚â† manager ‚â† tester) ‚ÄúToy‚Äù applications Complex systems Short lifespan Indefinite lifespan One-of-a-kind system System families Built from scratch Reuse to amortize costs Minimal maintenance Maintenance accounts for over 60% of overall development costs (and getting higher) Effort for Large Software Ideal: Make difficulty linear with respect to size Practical: Some studies suggest effort = length1.35 Bugs grow like ùëÇ(ùëÅùëôùëúùëîùëÅ) Naive solution: Add more people Provide expertise Reduce elapsed time But‚Ä¶ adds problems 23 Adding More People Nobody understands the whole system Opportunities for misunderstandings abound Communication and costs management overhead Personnel turnover People leave taking knowledge with them People arrive Must be brought up to speed Must live with decisions already made Brooks Law (1975): Adding personnel to a late project makes it later 24 Need For Flexibility Hardware is relatively stable Expensive to change, especially in field Software is more easily upgraded Paradoxically, software often outlives hardware Because people interact with it Because it can be upgraded Usually it is too expensive to start over 25 Need For Flexibility 26 Software Failure Curve 27 Hardware Software Failure Curve 28 Hardware Software Development with Need For Flexibility 29 ‚ÄúWalking on water and developing software from a specification are easy if both are frozen.‚Äù - Edward V. Berard Software Maintenance Costs 30 Software Maintenance Good software is maintained, bad software is discarded Different types of maintenance: Corrective maintenance Fix defects after release Perfective maintenance Add new features Adaptive maintenance Make it work in a changing environment 31 OO Design Example A house is wired with all the controls for heating Different heating systems should be supported All devices are controlled by a thermostat 32 OO Design Example ‚Äì Possible Solution 33 OO Design Example ‚Äì Need for Flexibility Now, the heater brakes down and we decide to buy an air condition instead Can both heat and cool Redesign looks easy: Air condition is a heating device ‚Üí Air condition is a subclass of heating device 34 OO Design Example ‚Äì Problem with Solution 35 Ok, I am convinced there's a problem; What's the solution? No silver bullet ! (Brooks, 1986) 36 ‚ÄúControlling complexity is the essence of computer programming.‚Äù Brian Kernighan 37 Controlling Complexity Development processes Specification ‚Üí Development ‚Üí Validation ‚Üí Evolution Tools, best practices, etc. Model Driven Architecture No dependence in programming language and programming environment For example: UML language Documentation 38 Software Engineering (From IEEE standard glossary of software engineering terminology): The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software. 39 Software Engineering in a Nutshell Software engineering is concerned with all aspects of software production Software engineering is about managing complexity Managing change Coping with potential defects Essence of all engineering But software engineering is different 40 Software Engineering is Different Little separation between design and fabrication Radical design changes during implementation Ill-defined goals Enormous pressure for features Great need for flexibility Variety of applications Banking to games Huge design space Physics rarely intrudes 41 Software Development Primarily a planning activity Process Can differ greatly from project to project Schedules Intermediate deadlines Staffing System, architecture Intertwined with process Quality assurance Design plan up front Continuous 42 Software Development Maintenance Risk reduction and contingency planning Often neglected 43 Hacking vs. Software Engineering Bad examples (hacking): Writing lots of code before testing any of it Keeping all the details in your head, assuming you‚Äôll remember them forever, instead of writing them down in your code Assuming that bugs will be nonexistent or else easy to find and fix 44 Hacking vs. Software Engineering Good examples (engineering): Writing a little bit at a time, testing as you go Documenting the assumptions that your code depends on Defending your code against stupidity Especially your own! 45 Reducing and Organizing Complexity The key: Divide and rule Modularity Split code into pieces that can be built independently Each must be documented so others can use it We do this using Decomposition Abstraction 46 Decomposition Decomposition creates structure Divide the problem into independent smaller sub-problems/modules What kind of division is best ? Example: When we give someone directions to our house, we are decomposing the process of getting from one place to another 47 Abstraction Abstraction suppresses detail Enables decomposition Trick is to suppress the right details Example: A road map is an abstraction of the earth in terms of roads and landmarks 48 Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #3: Java Semantics Java History Developed by James Gosling at Sun Microsystems Now a part of Oracle Corporation 1995: First release 1997: Became a standard 2004: J2SE 5.0 Addition of generics 2006: Released as open source 2007: Used in Google‚Äôs Android 2 Java Goals Simple, object-oriented, and familiar Robust and secure Architecture-neutral and portable High performance Interpreted, threaded and dynamic Syntax is developed from the syntax of C and C++ The Java Virtual Machine 3 The Java Virtual Machine 4 Types Every entity in a Java program has a type Primitives: int, double, char, boolean, ‚Ä¶ Objects: String, PrintStream, ArrayList, ‚Ä¶ Variables are declared with a type: Compiler requires type correctness Stricter than C/C++ 5 boolean isFinished; Cat kitty; Declared Type and Actual Type Objects have 2 types: Declared type The type an object variable was declared as The compiler only cares about this type Actual type The type an object variable was constructed as The JVM only cares about this type Determines which implementation of the method is called 6 Person p = new Worker(); Type Safety Java is a strongly typed language Declared type of any expression is a supertype of its actual type Type errors such as using a pointer as an integer are detected by the complier All array accesses are checked to ensure they are within bounds Compiled code is guaranteed to be type safe Except for explicit class casting 7 Casting Casts have no effect on the object They perform a run-time check They change the declared type In Java, casts are usually an indication of bad style There are very few exceptions For example, the equals method takes an Object argument that must be cast 8 Stack and Heap Objects live on the heap new creates an object on the heap One exception: Strings can be created via a literal: \"hi\" Primitive types live on the stack Local references may point to objects on the heap 9 List<Date> lst = new ArrayList<>(); Aliasing Aliasing is useful but adds complexity Breaks the rule that a statement affects only the variables it mentions 10 String s = new String(\"Hello OOPD\"); String t = s; s = new String(\"Hello again\"); t and s are aliased Equality x == y Primitive types: same value Object types: same object x.equals(y) Primitive types: doesn‚Äôt exist Object types: method that compares values of objects May be overwritten 11 Mutability Type can be mutable or immutable Objects of an immutable type never change after creation Example: String is immutable, StringBuffer is mutable String.concat() creates a new String object StringBuffer.append() doesn‚Äôt Immutable types simplify reasoning You know what state they are: The state in which they were created 12 Mutable vs. Immutable Immutable types can be safely shared No issues with aliasing You can pass them and return them without fear of damage Inherently thread safe Immutable types can increase efficiency Immutable types can consume more memory Need a unique instance for each unique abstract value used Can be mitigated using techniques we‚Äôll see later in the course Mutable types are sometimes a more natural way of modeling E.g., a transaction on a bank account 13 Mutability What are the values of s, t, sb, tb, s==t, sb==tb? 14 String s = new String(\"hello\"); String t = new String(\"hello\"); StringBuffer sb = new StringBuffer(\"he\"); StringBuffer tb = sb; sb.append(\"llo\"); tb.append(\" goodbye!\"); s.concat(\" goodbye!\"); t = s.concat(\" goodbye!\"); Immutable Values A variable declared with the keyword final is assigned once and never reassigned Similar to const in C++ Static checking for immutable references 15 final int n = 5; String s1; final String s2; final StringBuffer sb; immutable reference to an immutable value mutable reference to an immutable value immutable reference to a mutable value Call by Value Java methods always use call-by-value Method arguments are copied when sent This includes object references Contain the address of the object on the heap 16 A Few Important Types int ‚Äì The integer you learned about in grade school (almost) A primitive type Integer ‚Äì container for ints A class ArrayList ‚Äì container for a sequence of elements A generic class 17 A Few Important Types 18 int i = 3; Integer iobj = Integer.valueOf(i); List<Integer> al = new ArrayList<>(); al.add(iobj); al.add(new Date()); al.add(i); compile-time error autoboxing Autoboxing 19 Integer counter = 1; while (true) { System.out.println(\"Iteration \" + counter); counter++; if (counter > 1000) break; } Array vs. ArrayLists Arrays are built into Java as primitive types But really are a class Fixed size ArrayList is part of the standard library of collection classes In general, prefer ArrayLists to arrays Arrays are more efficient Do you really care? Arrays are ok only if you know in advance how large they will be 20 Array vs. ArrayLists 21 int[] array1; array1 = new int[10]; for (int i = 0; i < array1.length; i++) { // do something with array1[i] } for (int value : array1) { // do something with value } What happens if you use an invalid index? An ArrayIndexOutOfBoundsException is thrown Uninitialized Variables 22 String a; System.out.println(a); String b = a.toUpperCase(); int[] intList = new int[10]; System.out.println(intList[2]); String[] strList = new String[10]; System.out.println(strList[2]); Java Collections A collection is an object that groups multiple elements into a single unit The collections framework contains Interfaces ‚Äì List, Set, Map Implementations ‚Äì data structures implementing the interfaces Algorithms ‚Äì searching, sorting, ‚Ä¶ Uses generics 2324 Java Collections List An ordered collection of zero or more objects, where the same object might appear multiple times Example methods: Implementations: ArrayList, LinkedList 25 int count = lst.size() // count the number of elements lst.add(e) // append an element to the end if (lst.isEmpty()) ... // test if the list is empty Set An unordered collection of zero or more unique objects Example methods: Implementations: HashSet, TreeSet, LinkedHashset 26 s1.contains(e) // test if the set contains an element s1.containsAll(s2) // test whether s1 ‚äá s2 s1.removeAll(s2) // remove s2 from s1 Map A collection that maps keys to values that cannot contains duplicate keys Example methods: Implementations: HashMap, TreeMap, LinkedHashset 27 map.put(key, val) // add the mapping key‚Üíval map.get(key) // get the value for a key map.containsKey(key) // test whether the map has a key map.remove(key) // delete a mapping Declaring New Types - Bank Account System 28 class Transaction { private int amount; private Date date; public Transaction(int amount, Date date) { this.amount = amount; this.date = date; } public Transaction(int amount) { this(amount, new Date()); // today } ... } Bank Account System 29 class Account { private String name; private List<Transaction> transactions = new ArrayList<>(); private int balance = 0; public Account(String name) { this.name = name; } public boolean hasSufficientFunds(Transaction t) { return (balance + t.getAmount()) >= 0; } public void post(Transaction t) { if (hasSufficientFunds(t)) { transactions.add(t); balance += t.getAmount(); } } } Bank Account System Use of class: 30 Account account = new Account(‚ÄúRothschild\"); Transaction t = new Transaction(100); account.post(t); Bank Account System 31 class OverdraftAccount extends Account { private int creditLimit; public OverdraftAccount(String name, int limit) { super(name); creditLimit = limit; } @Override public boolean hasSufficientFunds(Transaction t) { return (balance + t.getAmount() + creditLimit) >= 0; } public void improveCredit(int amount) { creditLimit += amount; } } Bank Account System Use of class: Which version of hasSufficientFund is called? OverdraftAccount version since this is the actual type 32 Account account = new OverdraftAccount(‚Äútycoon\"); Transaction t = new Transaction(-100); account.post(t); Bank Account System 33 class Bank { private List<Account> accounts = new ArrayList<>(); ... public void chargeMonthlyFee() { for (Account account : accounts) { Transaction fee = new Transaction(-1); if (account.hasSufficientFunds(fee)) account.post(fee); } } ... } Abstract Classes An abstract class is partially implemented Some declared methods are not implemented The class cannot be instantiated Subclasses inherit implementation A concrete subclass must implement all methods 34 Abstract Class Example 35 abstract class GraphicObject { private int x, y; public void moveTo(int newX, int newY) { ... } public abstract void draw(); public abstract void resize(); ‚Ä¶ } Interfaces An interface is not at all implemented Methods may be declared No fields except final public static ones No constructors Cannot be instantiated Can only be implemented by classes Can be extended by other interfaces (more on this later in the course) 36 Interface Example 37 interface Shape { public static final String LABEL = \"Shape\"; public abstract void draw(); public abstract double getArea(); } class Circle implements Shape { public void draw() { ‚Ä¶ } public double getArea() { ‚Ä¶ } } Object Class Every class in Java is a descendant, direct or indirect, of the Object class Provides some common behaviors to all the objects Primitive types share these behaviors with autoboxing Every class inherits Object‚Äôs methods and may need to override them 38 Object Methods Returns a string representation of the object Should always override it Called when the object is garbage collected Don‚Äôt use it Unpredictable, often dangerous, and generally unnecessary Deprecated since Java 9 39 public String toString() protected void finalize() throws Throwable Object Methods Creates and returns a copy of this object A flawed and complicated design Should override judiciously Better to provide a copy constructor Related to object equality and hashing We‚Äôll take about these methods in detail later in the course 40 protected Object clone() throws CloneNotSupportedException public boolean equals(Object obj) public int hashCode() Object Methods Returns the runtime class of an object Use of this method can be justified only in rare cases Help in thread synchronization Out of the scope of this course 41 public final Class getClass() public final void notify() public final void notifyAll() public final void wait() public final void wait(long timeout) public final void wait(long timeout, int nanos) Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #4: Specification Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 Managing Complexity Decomposition: Divide problem into sub-problems that Can be solved independently Can be combined to solve the original problem How do we know they can be solved independently? How do we know they can be combined to solve the original problem? 2 Abstraction We often view a program in two distinct ways: The implementer's view (how to build it) The client's view (how to use it) It helps to apply these views to program parts While implementing one part, consider yourself a client of any other parts it depends on This helps reduce decoupling between parts 3 Abstraction An abstraction is a many-to-one mapping How should client know what to expect? 4 A Problem Complete this method so that it returns the index of the largest value of the first n elements of the array arr 5 int indexOfMax(int[] arr, int n) { ‚Ä¶ } You can all write this code Several possible implementations A Problem More interesting: What if n = 0? What if n < 0? What if n > arr.length? What if there are two maximum elements? Writing the answer to these questions is often harder than writing the code 6 Specification Abstraction is formalized through the idea of a specification Tells the client of an abstraction what the client can expect it to do Not necessarily exact behavior E.g., compute the square root of x within Œµ Tells the implementer of an abstraction what the implementation must do to satisfy the client Denotes a set of possible implementations E.g., set of all procedures that sort lists Abstracts from the kinds of list and algorithm 7 Specification as a Contract Specification is a contract between client and implementer Client will only rely on behavior described by specification Implementer will provide an implementation that satisfies the specification 8 Specification as a Firewall Acts as a firewall between client and implementer Shields the client from implementation details Shields the implementer from how the part is used Discourages implicit, unwritten expectations Results in decoupling 9 Specification Facilitates Change Reduces the ‚ÄúMedusa‚Äù effect The specification, rather than the code, gets ‚Äúturned to stone‚Äù by client dependencies 10 Good Specification Good specification is Clear, precise and unambiguous Clients and implementers will agree on what it means Complete Describe the behavior of the abstraction in all situations Declarative Describe what the abstraction should do, not how it should do it 11 Bad Specification Example From java.util.HasMap 12 // Returns the value to which the specified key is mapped, or null if // this map contains no mapping for the key ‚Ä¶ // A return value of null does not necessarily indicate that the map // contains no mapping for the key; it's also possible that the map // explicitly maps the key to null. The containsKey operation may be // used to distinguish these two cases. public V get(Object key) Preciseness of Specification A specification should be Sufficiently restrictive to rule out all implementations unacceptable to clients Do something useful Sufficiently general not to rule out desirable implementations Permit efficient implementation 13 Preciseness of Specification Desirable Implementation ‚äÜ Specified Set ‚äÜ Acceptable Solutions 14 Procedural Specification Specification for a procedure describes: What its inputs are What the mapping between inputs and outputs is What it can do to the state of the world 15 Interface The interface (header) defines the boundary between the implementers and clients Provides the syntax: name of methods, types of parameters and return value Isn‚Äôt the interface sufficient? Nothing about the behavior and effects Too little information to clients 16 Why Not Just Read Code? 17 <T> boolean sub(List<T> src, List<T> part) { int part_index = 0; for (T element : src) { if (element.equals(part.get(part_index))) { part_index++; if (part_index == part.size()) return true; } else part_index = 0; } return false; } Why Not Just Read Code? Code is Complicated Gives more detail than needed by client Client cares only about what code does, not how it does it Code is ambiguous What properties will be maintained over time? What properties might be changed by future optimization, improved algorithms, or just bug fixes? Implementer also needs to know what features the client depends on, and which can be changed 18 What About Code and Comments? Most comments convey only an informal general idea of what the code does Problem: ambiguity remains What if src and part are both empty lists? When does the function return true? 19 // Check if part appears as a sub-sequence in src static <T> boolean sub(List<T> src, List<T> part) { ‚Ä¶ } From Comments to Specification In a specification: Client agrees to rely only on information in the description in their use of the part Implementer of the part promises to support everything in the description 20 Specification v1 A more careful description of sub() Complicated description suggests poor design 21 // This method scans the src list from beginning to end, building up a // match for part, and resetting that match every time that... static <T> boolean sub(List<T> src, List<T> part) { ‚Ä¶ } Specification v2 It‚Äôs better to simplify than to describe complexity! Better to rewrite sub() to be more sensible and easier to describe 22 // Returns true iff exist sequences A, B (possibly empty) such that // src = A + part + B // where + is sequence concatenation static <T> boolean sub(List<T> src, List<T> part) { ‚Ä¶ } Specification Style Mathematical flavor is not always necessary, but often helps to avoid ambiguity Declarative style is important 23 Specification Side Effect #1 Rewards code that is easy to describe and understand Punishes code that is hard to describe and understand (even if it is shorter or easier to write) If you find yourself writing complicated specifications, it is an incentive to redesign 24 Writing Specifications with Javadoc Javadoc is a documentation generator for the Java language Its format is the de facto industry standard for documenting Java classes Javadoc convention for writing specifications: Method signature Text description of method @param: describes a method parameter @return: describes return value @throws: describes a possible exception and a condition under which it is thrown 25 Example Javadoc Specification String.contains() 26 /** * Returns true if and only if this string contains the specified * sequence of char values. * @param s the sequence to search for * @return true if this contains s, false otherwise * @throws NullPointerException if s is null * @since 1.5 */ public boolean contains(CharSequence s) Writing Specifications in the Course Precondition: Constraints that hold before the method is called @requires: obligations client must satisfy before calling Postcondition: Constraints that hold after the method is called (if the precondition held) @modifies: lists objects that may be affected by method; any object not listed is guaranteed to be unchanged @effects: gives guarantees on final state of modified objects @return: describes return value @throws: describes a possible exception and conditions under which it is thrown 27 Total vs. Partial Procedures A procedure is total if its behavior is specified for all possible inputs; otherwise, it is partial Partial procedure contains a @requires clause Partial procedures are used more in ‚Äúhelper‚Äù methods/classes In public libraries, it is necessary to deal with all possible inputs Rule of thumb: Avoid partial procedures unless there is a good reason to do so Partial procedures are less safe But may be more efficient or easy to implement 28 @requires Clause What happens if the precondition is not satisfied? Not defined The code is free to do anything Still, it is polite to fail-fast 29 Fail-fast Provide an immediate error, rather than permitting mysterious bad behavior A part of the approach of Defensive programming Rule of Thumb: check if cheap to do so Example: list has to be non-null ‚Üí check Example: list has to be sorted ‚Üí skip 30 Examples of Poorly Chosen Preconditions Stating the obvious String s is a string The computer has enough memory to run Making up for a lazy or poor implementation For List.isSorted: List shouldn't contain any duplicates because our code messes up in that case and returns the wrong answer Things that clients cannot check, avoid, or ensure For Stack.push: Stack's internal array capacity must be ‚â• stack size For a download: If it starts, the whole file will arrive successfully 31 Specification Example, 1st Try What should client expect if a is null or empty? 32 // @requires none // @return the value of the biggest element of a public static int biggest(int[] a) Specification Example, 2nd Try Is this a good specification? Depends on the client, it‚Äôs risky 33 // @requires a != null and has at least one element // @return the value of the biggest element of a public static int biggest(int[] a) Specification Example, 3rd Try Is this a good specification? Better but client has to deal with a special case now Invitation to bugs and confusion Better would probably be to throw an exception 34 // @requires none // @effects If a != null and has at least one element, returns the // value of the biggest element of a. Otherwise, returns // Integer.MIN_VALUE (smallest int value). public static int biggest(int[] a) Specification Example, 3rd Try How does a client know a is the same after biggest returns? Reading the @effects clause is enough ‚Äì if biggest modifies anything, it should describe it But that‚Äôs a lot of work 35 // @requires none // @effects If a != null and has at least one element, returns the // value of the biggest element of a. Otherwise, returns // Integer.MIN_VALUE (smallest int value). public static int biggest(int[] a) @modifies Clause Any state not listed in the @modifies clause may not be changed by the method 36 // @requires none // @modifies nothing // @effects If a has at least one element, returns the value of the // biggest element of a. Otherwise, returns Integer.MIN_VALUE // (smallest int value). public static int biggest(int[] a) @modifies Example 37 // @requires a and b != null and have at least one element // @modifies a // @effects Replaces the value of the biggest element in a with the // value of the biggest element in b. public static int replaceBiggest(int[] a, int[] b) Another @modifies Example 38 // @requires lst != null // @modifies lst // @effects Puts lst in sorted order, i.e. // lst[i]<=lst[j] for all 0<=i<j<lst.size() static void sort(List<String> lst) Defaults What does it mean when there is no @requires clause? @requires none What does it mean when there is no @modifies clause? @modifies nothing What does it mean when there is no @effects clause? Meaningless 39 Specification Example, 1st version 40 // @requires // // // // @modifies // // @return // // // static List<Integer> listAdd1(List<Integer> lst1, List<Integer> lst2) { List<Integer> result = new ArrayList<Integer>(); for (int i = 0; i < lst1.size(); i++) result.add(lst1.get(i) + lst2.get(i)); return result; } Specification Example, 2nd version 41 // @requires // // // // @modifies // // @effects // // // static void listAdd2(List<Integer> lst1, List<Integer> lst2) { for (int i = 0; i < lst1.size(); i++) lst1.set(i, lst1.get(i) + lst2.get(i)); } Specification Side Effect #2 Client doesn't need to look at implementation So code may not even exist yet! Write specifications first, make sure system will fit together, and then assign separate implementers to different modules Allows teamwork and parallel development Also helps with testing, as we'll see later in the course 42 Satisfaction of a Specification Let M be an implementation and S a specification M satisfies S if and only if Every behavior of M is permitted by S For every input allowed by the spec precondition, M produces an output allowed by the spec postcondition 43 Comparing Specifications Occasionally, we need to compare different versions of a specification: For example, comparing new version of a specification with old Can the new specification be used anywhere that the old specification is required? For that, we talk about stronger and weaker specifications 44 Specification Strength - Definition Definition 1: Specification S1 is stronger than S2 iff ‚àÄ implementation M, (M satisfies S1) ‚Üí (M satisfies S2) S1 is harder to satisfy than S2 Definition 2: Specification S2 is stronger than S1 iff Postcondition of S2 is stronger than that of S1 on all inputs allowed by both Precondition of S2 is weaker than that of S1 45 Specification Strength 46 Incomparable Specifications Two specifications may be incomparable Neither is weaker/stronger than the other Some implementations might still satisfy them both 47 Weaker vs. Stronger Specification A procedure satisfying a stronger specification can be used anywhere that a weaker specification is required A weaker specification is Easier to satisfy (easier to implement, more implementations satisfy it) Harder to use (makes fewer guarantees) A stronger specification is Harder to satisfy (more constraints on the implementation) Easier to use (more guarantees, more predictable, client can make more assumptions) 48 Strengthening or Weakening a Specification Strengthen a specification by Asking less of client Making @requires easier to satisfy Promising more Making @effects and @return harder to satisfy Removing objects from @modifies clause Throwing more specific exceptions (subclasses) Weaken a specification by Opposite of everything above 49 Stronger or Weaker? Which specification is better, stronger or weaker? There are tradeoffs Usefulness to client Ease of simple, efficient, correct implementation Promotion of reuse and modularity Clarity of specification itself It depends 50 Example - Specification How to make specification stronger? 51 // @requires value occurs in a // @return i such that a[i] = value int find(int[] a, int value) { for (int i = 0; i < a.length; i++) { if (a[i] == value) return i; } return -1; } Example ‚Äì A Stronger Specification, ver. A 52 // @requires value occurs in a // @return smallest i such that a[i] = value int find(int[] a, int value) { for (int i = 0; i < a.length; i++) { if (a[i] == value) return i; } return -1; } Example ‚Äì A Stronger Specification, ver. B 53 // @return i such that a[i] = value, or -1 if value is not in a int find(int[] a, int value) { for (int i = 0; i < a.length; i++) { if (a[i] == value) return i; } return -1; } Object Oriented Programming and Design Yair Moshe Winter, 2020/1 Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 #5: Abstract Data Types Procedural and Data Abstraction Procedural abstraction Abstract from implementation details of procedures Specification is the abstraction Satisfy the specification with an implementation Data abstraction Abstract from details of data representation Also a specification mechanism A way of thinking about programs and design Standard terminology: Abstract Data Type Invented by Barbara Liskov in the 70s 2 The Need for Data Abstractions Organizing and manipulating data is common Inventing and describing algorithms is less common Often best to start your design by designing data abstractions What is the meaning of data? What operations will be permitted on the data by clients? Later you can choose a data structure 3 ‚ÄúBad programmers worry about the code. Good programmers worry about data structures and their relationships.‚Äù Linus Torvalds 4 An ADT is a Set of Operations ADT abstracts from the organization to meaning of data ADT abstracts from data structure to use Representation should not matter to the client So hide it from the client Operations are the only way clients can access data 5 Are these Classes the Same? Different details: cannot replace one with the other in a program Same concept: both implement the concept ‚Äú2D point‚Äù Goal of ADT is to express the sameness Achieve this by specifying operations, not the representation 6 class Point { public double x; public double y; } class Point { public double r; public double theta; } 2D Point as an ADT // A 2D point exists in the plane ... class Point { public double x(); public double y(); public double r(); public double theta(); public Point(); // new point at (0,0) public Point centroid(Set<Point> points); public void translate(double deltaX, double deltaY); public void scaleAndRotate(double deltaR, double deltaTheta); } 7 Observers Creator Producer Mutators Benefits of ADTs Can delay decisions on how ADT is implemented Can change how ADT is implemented Improve, fix, ‚Ä¶ Creates an abstraction barrier 8 ADT= Objects + Operations Implementation is hidden The only operations on objects are those provided by the abstraction 9 ADT Examples 10 ADTs come from the problem space or from the program space Quiz: Where Do ADTs Come From? ◊ë ◊©◊ï◊û◊ô◊©-Kahoot ◊®◊™◊ê◊ú ◊ï◊©◊ú◊íkahoot.it ◊™◊ô◊ô◊¶◊ß◊ô◊ú◊§◊ê◊ë ◊ï◊©◊û◊™◊©◊î ◊ï◊êKahoot! ◊î ◊®◊§◊°◊û ◊™◊ê ◊ï◊©◊ô◊ß◊î-PIN◊ù◊õ◊™◊ê ◊£◊™◊©◊û ◊ô◊†◊ê◊© ◊ö◊°◊û◊î ◊ú◊¢ ◊ù◊ô◊ê◊ï◊® ◊ù◊™◊ê◊© ◊ù◊© ◊©◊ô◊ß◊î◊ú ◊ù◊ô◊©◊ß◊ë◊™◊û ◊ù◊™◊ê◊©◊õ , ◊™◊ê ◊ï◊©◊ô◊ß◊î◊ù◊õ◊ú◊© ◊™◊ï◊î◊ñ◊î ◊™◊ì◊ï◊¢◊™ ◊®◊§◊°◊û ◊î◊§ ◊ù◊™◊ê◊© ◊¢◊ì◊ê ◊ô◊†◊ê ◊î◊õ◊õ 11 ADT Examples From problem space Light Light on, light off Elevator Move up one floor Move down one floor Move to specific floor Return to home floor Get current floor 12 From program space File Open, read , write, close file Menu Start new menu Delete menu Add menu item Remove menu item Activate menu item Deactivate menu item Display menu Hide menu Get meu choice Specifying an ADT Abstraction A collection of procedural abstractions (operations) Need a way to write specifications for these procedures Avoid referencing the actual implementation Description of a state is called an abstract state Refers to specification fields, not implementation Should have no information about the implementation 13 Abstract vs. Concrete State Example Abstract state of an int list: Ordered sequence of integer values Possible concrete state of an int list: Array of primitive ints: [1, 2, 17, 42] Another possible concrete state of an int list: Linked list of BigInteger objects: Many more possible concrete states 14 BigInteger(1) BigInteger(2) BigInteger(17) BigInteger(42) Specifying an ADT Overview Abstract state Creators Return new ADT values e.g., Java constructors Producers ADT operation that returns new values Rare in mutable types Observers Return information about an ADT Mutators Modify a value of an ADT Only available in mutable types 15 Poly - Overview State if immutable (default not) Define an abstract state for use in operation specifications 16 // A Poly is an immutable polynomial with integer // coefficients. A typical Poly is // c0 + c1*x + c2*x^2 + ... class Poly { Poly - Creators New object, so no pre-state Only @effects, no @modifies 17 // @effects Makes a new Poly = 0 public Poly() // @effects Makes a new Poly = c*x^n // @throws NegativeExponentException if n < 0 public Poly(int c, int n) Poly - Observers Used to obtain information about objects of the type Return values of other types Never modify the abstract state 18 // @return the degree of this, i.e., the largest exponent with // a non-zero coefficient, or 0 if this = 0. public int degree() // @return the coefficient of the term of this whose exponent is d // @throws NegativeExponentException if d < 0 public int coeff(int d) Poly - Producers 19 // @return this + q public Poly add(Poly q) // @return this * q public Poly mul(Poly q) // @return -this public Poly negate() Operations on a type that create other objects of the same type Common in immutable types No side effects Never modify the abstract value of existing objects IntSet ‚Äì Overview and Creator 20 // An IntSet is a mutable, unbounded set of integers. A typical IntSet // is { x1, ..., xn }. class IntSet { // @effects Makes a new IntSet = {} public IntSet() IntSet - Observers 21 // @return true iff x in this public boolean contains(int x) // @return the cardinality of this public int size() // @return some element of this // @throws EmptyException if size()==0 public int choose() IntSet - Mutators 22 // @modifies this // @effects this_post = this_pre + {x} public void add(int x) // @modifies this // @effects this_post = this_pre - {x} public void remove(int x) Operations that modify an element of the type Rarely modify anything available to clients other than this Typically have no return value ‚ÄúDo one thing and do it well‚Äù ADTs and Java Java classes Make operations in the ADT public Make other operations and fields of the class private Clients cannot access the implementation but can see it Java interfaces Clients only see the ADT, not the implementation Cannot include creators (constructors) or fields 23 Java Access Control Four possible access levels for fields and methods: private: Accessible only inside the class where it is declared package: Accessible from any class in the package where it is declared Default access level protected: Accessible from subclasses of the class where it is declared and from any class in the package where it is declared Different than the meaning in C++ public: Accessible from anywhere Top-level classes and interfaces can be only package or public 24 Restricting Accessibility Rule of thumb: Make each class or member as inaccessible as possible Why? 25 The Connection Between ADTs and OOP OOP is a way to implement ADTs In Java, every data abstraction can be implemented by a class, but not every class is a data abstraction 26 OOP Principles (by Alan Key) 1. Everything is an object In Java: Except primitive types But autoboxing helps 2. Objects perform computation by making requests of each other through the passing of messages 27 String s = ‚ÄúA test string‚Äù; int index = s.indexOf(‚Äútest‚Äù); OOP Principles (by Alan Key) 3. Every object has its own memory, which consists of other objects 4. Every object is an instance of a class. A class groups similar objects 5. The class is the repository for behavior associated with an object An object consists of Memory: state / data fields Behavior: Set of operations / methods ID: memory address 28 OOP Principles (by Alan Key) 3. Every object has its own memory, which consists of other objects 4. Every object is an instance of a class. A class groups similar objects 5. The class is the repository for behavior associated with an object A class defines an ADT An abstraction over objects A recipe for creating new objects 29 OOP Principles (by Alan Key) 6. Classes are organized into singly-rooted tree structure, called an inheritance hierarchy Inheritance is a way to implement subtyping 30 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 #6: Representation Invariant and Abstraction Function ADTs and Specifications So far, we have only specified ADTs We need guidelines for how to ensure our implementations satisfy our specifications Two intellectual tools are really helpful ‚Ä¶ Used by implementers / debuggers / maintainers of the implementation 2 Representation Invariant Maps object ‚Üí boolean Defines the set of valid concrete values Set of reachable values of the data structure Must always hold (outside of mutators) 3 Abstraction Function Maps object ‚Üí abstract value Says what the data structure means as an abstract value How the data structure is to be interpreted Only defined on objects meeting the rep. invariant 4 Connecting Implementations to Specs 5 Example of Connecting Implem. to Specs 6 Implementing an ADT To implement an ADT Select the representation of instances, ‚Äúthe rep‚Äù Implement operations in terms of that representation Choose a representation so that It is possible to implement required operations The most frequently used operations are efficient Abstraction allows the rep to change later 7 CharSet ADT 8 // A CharSet is a finite mutable set of Characters that contains no duplicate Characters // @effects Creates a new empty CharSet public CharSet() // @modifies this // @effects this_post = this_pre + {c} public void insert(Character c) // @modifies this // @effects this_post = this_pre - {c} public void delete(Character c) // @return (c in this) public boolean member(Character c) // @return cardinality of this public int size() CharSet Implementation Is the implementation correct? 9 class CharSet { private List<Character> elements = new ArrayList<>(); public void insert(Character c) { elements.add(c); } public void delete(Character c) { elements.remove(c); } public boolean member(Character c) { return elements.contains(c); } public int size() { return elements.size(); } } CharSet Implementation Where is the defect? 10 CharSet s = new CharSet(); Character a = Character.valueOf('a'); s.insert(a); s.insert(a); s.delete(a); if (s.member(a)) System.out.print(\"wrong\"); else System.out.print(\"right\"); Where is the Defect? Perhaps delete is wrong Should remove all occurrences? Perhaps insert is wrong Should not insert a character that is already there? The representation invariant tells us which is correct This is how we document our choice for ‚Äúthe right answer‚Äù 11 Representation Invariant The representation invariant defines data structure well- formedness Must hold before and after every CharSet operation Write it like this: 12 class CharSet { // Rep. Invariant: // elements has no nulls and no duplicates ‚Ä¶ Representation Invariant Or, more formally: So, where is the error? 13 class CharSet { // Rep. Invariant: // for all indices i of elements // elements.elementAt(i) != null // for all indices i, j of elements // elements.elementAt(i).equals(elements.elementAt(j)) => i=j ‚Ä¶ Another Rep. Invariant Example Real-world constraints: balance ‚â• 0 balance = œÉùëñ transactions.get(i).amount Implementation-related constraints: transactions ‚â† null No nulls in transactions 14 class Account { private int balance; // history of all transactions private List<Transaction> transactions; ‚Ä¶ } Checking the Rep Invariant You should write code to check that the rep invariant holds More considerations: Always in development, even when it‚Äôs expensive Usually for production, no if expensive Should we check in observer methods? Yes, as a defensive practice Should we check in private methods? Not for all of them Why? 15 Defensive Programming Design your code to catch bugs by implementing and using a method to check the rep invariant Rule of thumb: check on entry and on exit Why? Reasoning about the rep invariant helps you avoid errors Checking the rep invariant helps you discover errors 16 checkRep() 17 public void delete(Character c) { checkRep(); elements.remove(c); checkRep(); } // Verify that elements contains no nulls and no duplicates private void checkRep() { for (int i = 0; i < elements.size(); i++) { assert elements.elementAt(i) != null; assert elements.indexOf(elements.elementAt(i)) == i; } } Assertions assert is a Java keyword for checking a Boolean condition If expression evaluates to true, nothing happens If expression evaluates to false, an AssertionError is thrown Assertions are disabled by default If not enabled, no performance penalty 18 Representation Exposure Example Consider adding the following method to CharSet: Does the implementation of getElements preserve the rep. invariant? 19 // @returns a List containing the members of this public List<Character> getElements() { return elements; } Representation Exposure Example Consider this client code: 20 CharSet s = new CharSet(); Character a = new Character(‚Äôa‚Äô); s.insert(a); s.getElements().add(a); s.delete(a); if (s.member(a)) ‚Ä¶ Representation Exposure Representation exposure is external access to the representation Representation exposure is almost always evil Can cause bugs that will be very hard to detect Rule #1: Don‚Äôt do it! Rule #2: If you do it, document it clearly and then feel guilty about it! 21 Returning an Iterator 22 public class PointSet { private List<Point> points = new ArrayList<>(); public Iterator<Point> getElementsIter() { return points.iterator(); } ‚Ä¶ } Returning and Iterator is Still Evil An iterator allows cycling through a collection: Problem: Java Iterator interface allows removing elements from the underlying collection Representation exposure 23 PointSet ps; ‚Ä¶ Iterator<Point> iter = ps.getElementsIter(); while (iter.hasNext()) { System.out.println(iter.next()); iter.remove(); } Avoiding Rep. Exposure, Way #1 Exploit the immutability of (other) ADTs the implementation uses Aliasing is no problem if nobody can change data An immutable ADT must be immutable ‚Äúall the way down‚Äù No references reachable to data that may be mutated 24 Avoiding Rep. Exposure, Way #1 - Example Assume Point is an immutable ADT: 25 class Line { private Point start, end; public Line(Point start, Point end) { this.start = start; this.end = end; } public Point getStart() { return start; } ‚Ä¶ } Immutability Several advantages of immutability Aliasing does not matter No need to make copies with identical contents Rep. invariants cannot be broken Requires different designs, e.g., if Point is immutable: ‚ÄúFamous‚Äù immutable classes in Java libraries include String, Character, Integer, ‚Ä¶ 26 void raiseLine(double deltaY) { start = new Point(start.x, start.y+deltaY); end = new Point(end.x, end.y+deltaY); } Avoiding Rep. Exposure, Way #2 Make copies of all data that cross the abstraction barrier Copy in parameters that become part of the implementation Copy out results that are part of the implementation Mutating a copy doesn‚Äôt affect the original 27 Avoiding Rep. Exposure, Way #2 - Example Assume Point is a mutable ADT: 28 class Line { private Point start, end; public Line(Point start, Point end) { this.start = new Point(start.x,start.y); this.end = new Point(end.x,end.y); } public Point getStart() { return new Point(start.x,start.y); } ‚Ä¶ } Avoiding Rep. Exposure, Way #2 What‚Äôs the bug (assuming Point is a mutable ADT)? 29 class PointSet { private List<Point> points = ‚Ä¶ public List<Point> getElements() { return new ArrayList<Point>(points); } ‚Ä¶ } ‚ÄúShallow‚Äù copying is not enough Avoiding Rep. Exposure, Way #3 Recall our Charset example: Another version, with an immutable wrapper: 30 public List<Character> getElements() { return new ArrayList<Character>(elements); } public List<Character> getElements() { return Collections.unmodifiableList(elements); } Collections.unmodifiableList From the JavaDoc for Collections.unmodifiableList: Returns an unmodifiable view of the specified list. This method allows modules to provide users with \"read-only\" access to internal lists. Query operations on the returned list \"read through\" to the specified list, and attempts to modify the returned list‚Ä¶ result in an UnsupportedOperationException. 31 Avoiding Rep. Exposure, Way #3 ‚Äì Pros and Cons Pros Clients cannot modify (mutate) the rep. More efficient than copy out Cons Immutability only at runtime A polluted interface Clients are forced to depend on methods that they do not use More on this later in the course 32 Which Way to Choose? Best options for implementing CharSet‚Äôs getElements: If O(n) time is acceptable, copy the list If O(1) time is required, return an unmodifiableList Prevents breaking the rep invariant If O(1) time is required and there is no unmodifiable version and you don‚Äôt have time to write one, expose the rep., document it and feel guilty 33 Making Rep. Invariant Hold To make an invariant hold, we need to Make the invariant true in the initial state of the object Ensure that all changes to the object keep the invariant true In terms of ADT operations, this means Creators and producers must establish the invariant for new object instances Mutators and observers must preserve the invariant No representation exposure 34 Quiz: checkRep() ◊ë ◊©◊ï◊û◊ô◊©-Kahoot ◊®◊™◊ê◊ú ◊ï◊©◊ú◊íkahoot.it ◊™◊ô◊ô◊¶◊ß◊ô◊ú◊§◊ê◊ë ◊ï◊©◊û◊™◊©◊î ◊ï◊êKahoot! ◊î ◊®◊§◊°◊û ◊™◊ê ◊ï◊©◊ô◊ß◊î-PIN◊ù◊õ◊™◊ê ◊£◊™◊©◊û ◊ô◊†◊ê◊© ◊ö◊°◊û◊î ◊ú◊¢ ◊ù◊ô◊ê◊ï◊® ◊ù◊™◊ê◊© ◊ù◊© ◊©◊ô◊ß◊î◊ú ◊ù◊ô◊©◊ß◊ë◊™◊û ◊ù◊™◊ê◊©◊õ , ◊™◊ê ◊ï◊©◊ô◊ß◊î◊ù◊õ◊ú◊© ◊™◊ï◊î◊ñ◊î ◊™◊ì◊ï◊¢◊™ ◊®◊§◊°◊û ◊î◊§ ◊ù◊™◊ê◊© ◊¢◊ì◊ê ◊ô◊†◊ê ◊î◊õ◊õ 35 CharSet‚Äôs insert 36 public void insert(Character c) { elements.add(c); } public boolean member(Character c) { return elements.contains(c); } A Different Implementation of insert Representation invariant is preserved 37 public void insert(Character c) { Character cc = new Character(encrypt(c)); if (!elements.contains(cc)) elements.add(cc); } public boolean member(Character c) { return elements.contains(c); } Rep. Invariant is Not Enough Where is the defect? We must consider the meaning The abstraction function helps us 38 CharSet s = new CharSet(); Character a = new Character('a'); s.insert(a); if (s.member(a)) System.out.print(‚Äúright\"); else System.out.print(‚Äúwrong\"); Abstraction Function Abstraction function maps concrete representation to the abstract value it represents We write it like this: 39 class CharSet { // Abs. Function: // represents the set of Characters contained in elements // // Rep. Invariant: // elements has no nulls and no duplicates ‚Ä¶ Abstraction Function Or more formally: 40 class CharSet { // Abs. Function: // {c | c is contained in elements } // // Rep. Invariant: // elements has no nulls and no duplicates ‚Ä¶ Applying the Abstraction Function Applying the abstraction function to the result of the call to insert yields AF(elements) U {encrypt(‚Äòa‚Äô)} insert is wrong What if we used this abstraction function? { c | decrypt(c) is contained in elements } member is wrong 41 Abs. Function & Rep. Invariant Abstraction function combined with representation invariant allow us to examine operators independently ‚ÄúCorrectness‚Äù is now a local issue Can examine operators one at a time Modularize implementation 42 Abstraction Function is a Function Why do we map concrete to abstract rather than vice versa? It‚Äôs not a function in the other direction E.g., lists [a,b] and [b,a] each represent the set {a, b} It‚Äôs not as useful in the other direction Purpose is to reason about whether our methods are manipulating concrete representations correctly in terms of the abstract specifications 43 Writing an Abstraction Function Domain: All representations that satisfy the rep. invariant Range: Can be tricky to denote Easy for mathematical entities like sets For more complex abstractions, give names to ‚Äúfields‚Äù that are parts of the abstract value The abstraction function defines the value of each ‚Äúspecification field‚Äù Overview section of the specification should provide a notation for writing abstract values 44 Circle Example, #1 45 // A mutable circle in the plane. For example, it can be a circle with // center (0,0) and radius 1. class Circle { // Abs. Function: // represents a circle with center at this.center and // radius this.radius // Rep. Invariant: // center != null // radius > 0 private Point center; private double radius; ‚Ä¶ } Circle Example, #2 46 // A mutable circle in the plane. For example, it can be a circle with // center (0,0) and radius 1. class Circle { // Abs. Function: // represents a circle with center at this.center and // radius this.center.distanceTo(this.edge) // Rep. Invariant: // center != null, edge != null // !center.equals(edge) private Point center; private Point edge; ‚Ä¶ } Tweet Datatype Example 47 // An immutable type representing a Tweeter tweet. class Tweet { // Abs. Function: // represents a tweet posted by author, with content text and // with time timestamp // Rep. Invariant: // author != null, text != null, timestamp != null // author is a Twitter username (a nonempty string of letters, // digits, underscores) // text.length <= 280 private final String author; private final String text; private final Date timestamp; ‚Ä¶ } Recommendations You should design and write the abs. function and rep. invariant as part of the design of the representation, before you start coding In practice (not in this course!) Always write a representation invariant Write an abstraction function when you need it Write an informal one for most non-trivial classes 48 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 #7: Subtyping What is Subtyping? Sometimes ‚Äúevery B is an A‚Äù Examples in a library database: Every book is a library item Every CD is a library item ‚ÄúB is a subtype of A‚Äù means: Every object that satisfies the rules for a B also satisfies the rules for an A Goal: code written using A's specification operates correctly if given a B Plus: clarify design, share tests, (sometimes) share code 2 Liskov Substitution Principle Let P(x) be a property provable about objects x of type T. Then P(y) should be true for objects y of type S where S is a subtype of T This means B is a subtype of A if anywhere you can use an A, you could also use a B 3 True Subtype vs. Java Subtype Subtypes are substitutable for supertypes Subtype won't surprise client by failing to satisfy the supertype's specification Subtype won't surprise client by having more expectations than the supertype's specification We say B is a (true) subtype of A if B has a stronger specification than A This is not the same as a Java subtype Java subtypes that are not true subtypes are confusing & dangerous But unfortunately common poor design 4 Subtyping and Subclassing Substitution (subtype) is a matter of specification B is a subtype of A iff an object of type B can pretend do be an object of type A in any context Any fact about an A object is true about a B object B is a subtype if its spec is a strengthening of A‚Äôs spec Inheritance (subclass) is a matter of implementation Factor out repeated code To create a new class, write only the differences Java purposely merges these notions for classes Every subclass is a Java subtype But not necessarily a true subtype 5 Subclassing for Code Reuse 6 class Product { private String title; private String description; private int price; // in cents public int getPrice() { return price; } public int getTax() { return (int)(getPrice() * 0.17); } ‚Ä¶ } Subclassing for Code Reuse 7 class SaleProduct { private String title; private String description; private int price; // in cents private float factor; public int getPrice() { return (int)(price*factor); } public int getTax() { return (int)(getPrice() * 0.17); } ‚Ä¶ } Is this a good design? Subclassing for Code Reuse A better design: Inheritance makes small extensions small 8 class SaleProduct extends Product { private float factor; @Override public int getPrice() { return (int)(super.getPrice()*factor); } } Benefits of Subclassing In implementation: Simpler maintenance In specification: Clients who understand the superclass specification need only study novel parts of the subclass Modularity: Can ignore private fields and methods of superclass (if properly designed) Readability: Differences not buried under mass of similarities 9 Subtyping vs. Implementation Inheritance Subtyping and implementation inheritance are orthogonal Subclassing gives you both Sometimes you want just one. Instead use: Interfaces: Subtyping without inheritance Composition: Use implementation without subtyping Can seem less convenient, but often better long-term 10 Is Every Square a Rectangle? Square is not a true subtype of Rectangle Rectangles are expected to have a width and height that can be mutated independently Squares violate that expectation, could surprise client Rectangle is not a true subtype of Square Squares are expected to have equal widths and heights Rectangles violate that expectation, could surprise client Subtyping is not always intuitive 11 Square and Rectangle - Solutions Make them unrelated Make them subtypes of Shape Make them immutable 12 Substitution Principle for Classes If B is a subtype of A, then a B can always be substituted for an A Any property guaranteed by A must be guaranteed by B Anything provable about an A is provable about a B 13 Substitution Principle for Classes B is permitted to strengthen properties and add properties Fine to add new methods (that preserve invariants) An overriding method must have a stronger or equal spec B is not permitted to weaken a spec No method removal No overriding method with a weaker spec 14 Substitution Principle for Methods Each overridden method must strengthen (or match) the spec Ask nothing extra of client @requires clause is at most as strict as in supertype‚Äôs method Guarantee at least as much @effects clause is at least as strict as in the supertype method No new entries in @modifies clause Promise more or the same in @return clause @throws clauses must indicate fewer or same exception types, but nothing new 15 Specification Strengthening For method inputs: Argument types in A.foo may be replaced with supertypes in B.foo Called contravariance Places no extra demand on the clients Java does not have such overriding For method outputs: Result type of A.foo may be replaced by a subtype in B.foo Called covariance No new exceptions (for values in the domain) Existing exceptions can be replaced with subtypes 16 Substitution Exercise Suppose we have a method in Product which, when given one Product, recommends another: Which of these are possible forms of this method in SaleProduct (a true subtype of Product)? In theory, not in Java! 17 Product recommend(Product p); SaleProduct recommend(Product p); Product recommend(Object p); Product recommend(Product p) throws NoSaleException; Product recommend(SaleProduct p); Java Subtyping Java types are defined by classes, interfaces or primitives Java subtyping stems from B extends A and B implements A declarations In a Java subtype, each corresponding method has: Same argument types If different, then overloading and not overriding Compatible (covariant) return type No additional checked exceptions 18 Java Subtyping Guarantees A variable‚Äôs actual type (run time type) is a Java subtype of its declared type (compile time type) If a variable of declared type T1 holds a reference to an object of actual type T2, then T2 is a Java subtype of T1 Corollaries: Objects always have implementations of the methods specified by their declared type Does not guarantee that overridden method have a stronger specification 19 Object o = new Date(); // ok Date d = new Object(); // compile-time error Inheritance Can Break Encapsulation 20 public class CountingHashSet<E> extends HashSet<E> { private int addCount = 0; // count # insertions public CountingHashSet(Collection<? extends E> c) { super(c); } public boolean add(E element) { addCount++; return super.add(element); } public boolean addAll(Collection<? extends E> c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } } Inheritance Can Break Encapsulation What does this code print? Answer depends on implementation of addAll in HashSet Different implementations may behave differently! If HashSet.addAll calls add, then double-counting 21 CountingHashSet<String> hs = new CountingHashSet<>(); System.out.println(hs.getAddCount()); hs.addAll(List.of(\"OOPD\", \"046271\")); System.out.println(hs.getAddCount()); Inheritance Can Break Encapsulation HashSet is a descendant of AbstractCollection AbstractCollection.addAll specification: ‚Äúadds all the elements in the specified collection to this collection.‚Äù Does not specify whether it calls add Lesson: Subclassing often requires designing for extension 22 Fragile Base Class Problem Poor design can produce subclasses that depend on many implementation details of superclasses Super- and sub-classes are often tightly coupled Changes in superclasses can break subclasses 23 Solutions 1. Change spec of HashSet Indicate all self-calls Less flexibility for implementers 2. Avoid self-calls by re-implementing methods such as addAll More work Less code reuse 3. Avoid self-calls by composition / delegation No longer a subtype 24 Solution #3: Composition 25 public class CountingHashSet<E> { private final HashSet<E> s = new HashSet<>(); private int addCount = 0; // count # insertions public CountingHashSet(Collection<? extends E> c) { this.addAll(c); } public boolean add(E element) { addCount++; return s.add(element); } public boolean addAll(Collection<? extends E> c) { addCount += c.size(); return s.addAll(c); } public int getAddCount() { return addCount; } } Should also implement every other method specified by HashSet<E> Composition / Delegation Composition allows implementation reuse without inheritance Easy to reason about Works around badly-designed / badly-specified classes Disadvantages (may be worthwhile price to pay): Does not preserve subtyping Sometimes tedious to write 26 Composition Breaks Subtyping CountingHashSet is not a HashSet anymore So can't easily substitute it It may be a true subtype of HashSet but Java doesn't know that! Interfaces to the rescue Can declare that we implement interface Set 27 Subtyping with Interfaces 28 public class CountingHashSet<E> implements Set<E> { private final Set<E> s = new HashSet<>(); private int addCount = 0; // count # insertions public CountingHashSet(Collection<? extends E> c) { this.addAll(c); } public boolean add(E element) { addCount++; return s.add(element); } public boolean addAll(Collection<? extends E> c) { addCount += c.size(); return s.addAll(c); } public int getAddCount() { return addCount; } } Should also implement every other method specified by Set<E> Interfaces and Abstract Classes Provide interfaces for your functionality Client code to interfaces rather than concrete classes Allows different implementations later Facilitates composition and wrapper classes Basis of lots of useful, clever techniques Consider also providing helper/template abstract classes Makes writing new implementations much easier Not necessary to use them to implement an interface 29 Java Library Interface/Class Example 30 // Root interface of collection hierarchy interface Collection<E> // Skeletal implementation of Collection<E> abstract class AbstractCollection<E> implements Collection<E> // Type of all ordered collections interface List<E> extends Collection<E> // Skeletal implementation of List<E> abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> class ArrayList<E> extends AbstractList<E> Java Library Interface/Class Example 31 Multiple Inheritance The diamond problem (‚Äúdeadly diamond of death‚Äù) foo is a method in A Overridden in B and C but not in D Which version of foo should D inherit? There are some ways to mitigate the problem None is perfect Java solution: Don‚Äôt allow multiple inheritance 32 Interfaces vs Classes Java design decisions: A class has exactly one superclass A class may implement multiple interfaces An interface may extend multiple interfaces Multiple superclasses are difficult to use and to implement Multiple interfaces + single superclass gets most of the benefit 33 Pluses and Minuses of Inheritance Inheritance is a powerful way to achieve code reuse Inheritance can break encapsulation A subclass may need to depend on unspecified details of the implementation of its superclass Subclass may need to evolve in tandem with superclass Recommendation: Either design for extension or else prohibit it Favor composition and interfaces to inheritance 34 Polymorphism Polymorphism means that the same expression can have several meanings In OOP, a polymorphic expression can perform different actions depending on the actual type of its object Can rely on inheritance: Can rely on generics: 35 Superclass s = new SubClass(); public void sort(List<T> list) Power of OOP The power of OOP mainly comes from the combination of the principles of subtyping and polymorphism Requires: Liskov substitution principle Upcasting Casting objects up the inheritance hierarchy Dynamic binding Linking method call to a specific method at run-time based on actual type 36 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 #8: Equality Object Equality May first look like a simple idea Two objects are equal if they have ‚Äúthe same value‚Äù Two objects are equal if they are indistinguishable But it is quite subtle: intuition can be misleading Same object or same contents? Same concrete value or same abstract value? Same right now or same forever? Same for instances of this class or also for subclasses? When are two collections equal? How can we implement equality efficiently? 2 Expected Properties of Equality Reflexive: a.equals(a) == true An object equals itself Symmetric: a.equals(b) iff b.equals(a) Order or arguments doesn‚Äôt matter Transitive: a.equals(b) && b.equals(c) ‚Üí a.equals(c) Equality is ‚Äútransferable‚Äù A relation that is reflexive, transitive, and symmetric is an equivalence relation 3 Reference Equality Reference equality means an object is equal only to itself a == b only if a and b refer to the same object Reference equality is an equivalence relation Reflexive, symmetric, transitive Sometimes but not always what we want 4 What Might We Want? Sometimes we want equivalence relation weaker than == Called object equality Java lets classes override equals 5 Date d1 = new Date(10,17,2017); Date d2 = new Date(10,17,2017); Date d3 = d2; // d1 == d2 ? // d2 == d3 ? // d1.equals.(d2) ? // d2.equals(d3) ? Object.equals method Implements reference equality Subclasses can override to implement a different equality But library includes a specification equals should satisfy 6 public class Object { public boolean equals(Object obj) { return this == obj; } ‚Ä¶ } equals Specification public boolean equals(Object obj) should be: Reflexive: For any reference value x, x.equals(x) == true Symmetric: For any reference values x and y, x.equals(y) == y.equals(x) Transitive: For any reference values x, y, and z, if x.equals(y) == true and y.equals(z) == true, then x.equals(z) == true Consistent: For any reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false (provided no information used in equals comparisons on the objects is modified) For any non-null reference value x, x.equals(null) == false 7 equals Specification In summary: Equivalence relation Consistency, but allow for mutation to change the answer Asymmetric with null null.equals(a) raises exception For non-null a, a.equals(null) == false 8 An Example A class where we may want equals to mean equal contents: 9 public class Duration { private final int min; // RI: min>=0 private final int sec; // RI: 0<=sec<60 public Duration(int min, int sec) { assert min>=0 && sec>=0 && sec<60; this.min = min; this.sec = sec; } } An Example, 1st Try Is this a good implementation of equals? Two bugs: 1. Violates contract for null 2. Does not override Object‚Äôs equals method 10 public class Duration { ‚Ä¶ public boolean equals(Duration d) { return min==d.min && sec==d.sec; } } Overloading vs. Overriding In Java: A class can have multiple methods with the same name and different parameters (number or type) A method overrides a superclass method only if it has the same name and exact same argument types Duration‚Äôs boolean equals(Duration d) overloads and not overrides Object‚Äôs boolean equals(Object obj) 11 An Example, 1st Try 12 public class Duration { public boolean equals(Duration d) { ‚Ä¶ } ‚Ä¶ } Duration d1 = new Duration(10,5); Duration d2 = new Duration(10,5); Object o1 = d1; Object o2 = d2; d1.equals(d2); o1.equals(o2); d1.equals(o2); o1.equals(d2); d1.equals(o1); // true // false // false // false // true (using Object‚Äôs equals) An Example, 2nd Try 13 public class Duration { public boolean equals(Object obj) { ‚Ä¶ } ‚Ä¶ } Duration d1 = new Duration(10,5); Duration d2 = new Duration(10,5); Object o1 = d1; Object o2 = d2; d1.equals(d2); o1.equals(o2); d1.equals(o2); o1.equals(d2); d1.equals(o1); // true // true (overriding) // true (overriding) // true (overriding) // true (overriding) An Example, 3rd Try This is the 2nd try: Is this a good implementation of equals? It doesn‚Äôt compile Requires casting from Object to Duration 14 public class Duration { public boolean equals(Object obj) { return min==obj.min && sec==obj.sec; } ‚Ä¶ } An Example, 3rd Try The instanceof operator tests whether an object is an instance (actual type) of a particular type Cast cannot fail 15 public class Duration { public boolean equals(Object obj) { if (!(obj instanceof Duration)) return false; Duration d = (Duration)obj; return min==d.min && sec==d.sec; } } An Example, 3rd Try We want equals to work on any pair of objects Gets null case right too (null instanceof x always false) Rare use of cast and instanceof that is correct 16 public class Duration { public boolean equals(Object obj) { if (!(obj instanceof Duration)) return false; Duration d = (Duration)obj; return min==d.min && sec==d.sec; } } An Example, 3rd Try Reflexive: Yes Symmetric: Yes, even if obj is not a Duration Transitive: Yes 17 public class Duration { public boolean equals(Object obj) { if (!(obj instanceof Duration)) return false; Duration d = (Duration)obj; return min==d.min && sec==d.sec; } } equals and Subtyping We understood the equals contract and how to implement equals correctly for Duration Alas, matters can get worse for subclasses of Duration Perfect solution is quite tricky Possible implementations involve trade-offs 18 equals and Subtyping Subtypes should be useable wherever their supertype is used Liskov substitution principle Unresolvable incompatibility between What we want for equality: treat subclasses differently What we want for subtyping: treat subclasses the same No perfect solution for all cases If you want correct subtyping, don‚Äôt override equals (make it final) If you want correct equality, use composition instead Less recommended: Compromise with a trick a not perfect equals implementations 19 hashCode Another method in Object: Contract: Self-consistent: obj.hashCode() is fixed so long as obj doesn‚Äôt change between the calls Consistent with equality: a.equals(b) ‚Üí a.hashCode() == b.hashCode() 20 // Returns a hash code value for the object. This method is supported // for the benefit of hash tables such as those provided by // java.util.HashMap. public int hashCode() hashCode Object Implementation Satisfies hashCode contract for Object‚Äôs implementation of equals 21 public int hashCode() { return /* the memory address of this */; } hashCode If two objects are equal, they must have the same hash code If you override equals, you must override hashCode Libraries won‚Äôt work if your classes break relevant contract If objects have same hash code, they may or may not be equal ‚Äúusually not‚Äù usually leads to better performance 22 Overriding hashCode We have to override hashCode in Duration Must obey contract Aim for non-equals objects usually having different results 23 Overriding hashCode Correct but not efficient A bit better Better Best 24 public int hashCode() { return 1; } public int hashCode() { return min; } public int hashCode() { return min ^ sec; } public int hashCode() { return 60*min+sec; } Equality and Mutation If two objects are equal now, will they always be equal? In mathematics, yes In Java, you choose Object contract doesn't specify 25 Equality and Mutation For immutable objects: Abstract value never changes Equality should be forever (even if rep changes) Override equals and hashCode For mutable objects, either: Use reference equality (never changes) Not forever: Mutation changes abstract value hence changes what object equals May cause some problems 26 Mutating in a Data Structure Set class checks equality only upon insertion Can violate rep. invariant of a Set by mutating after insertion 27 Set<Date> s = new HashSet<>(); Date d1 = new Date(0); Date d2 = new Date(1000); s.add(d1); s.add(d2); d2.setTime(0); for (Date d : s) { // prints two of same date System.out.println(d); } Pitfalls of Mutability and Equivalence From Set‚Äôs specification: ‚ÄúNote: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set.‚Äù Same problem applies to other containers Especially hard bugs to detect! Easy to cause when modules don‚Äôt list everything they mutate Why we need @modifies 28 Summary Different notions of equality Reference equality vs object equality Java‚Äôs equals has an elaborate specification Does not require equality forever Requires consistency with hashCode Mutation and/or subtyping make things tricky Good reason not to overuse/misuse either 29 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #9: Generics Partially based on slides of Univ. of Washington CSE 331 Reminder: Benefits of Abstraction Hide details Avoid getting lost in details Permit details to change later on Give meaningful names to concepts Permit reuse in new contexts Avoid duplication: error-prone, confusing, less changeable Save reimplementation effort 2 Varieties of Abstraction Abstraction over computation: procedures (methods) Abstraction over data: ADTs (classes, interfaces) 3 int x1, y1, x2, y2; Math.sqrt(x1*x1 + y1*y1); Math.sqrt(x2*x2 + y2*y2); Point p1, p2; Varieties of Abstraction Abstraction over types: polymorphism (inheritance) Abstraction over types: polymorphism (generics) 4 public void makeAnimalSound(Animal a) { a.makeSound(); } Point<Integer>, Point<Double> Cat c = new Cat(); makeAnimalSound(c); Polymorphism with Generics ‚Ä¶ and many, many more 5 interface ListOfStrings { boolean add(String element); String get(int index); } interface ListOfIntegers { boolean add(Integer element); Integer get(int index); } Polymorphism with Generics Instead, we‚Äôll write: And use types like List<Integer>, List<String>, List<List<String>>, ‚Ä¶ 6 interface List<E> { boolean add(E element); E get(int index); } Type Variables are Types 7 class MySet<T> implements Set<T> { private List<T> theRep; private T lastItemInserted; ‚Ä¶ } Declaring and Instantiating Generics Convention: Type variables have one-letter name Examples: T for Type, E for Element, K for Key, V for Value, ‚Ä¶ To instantiate a generic class/interface, client supplies type: 8 class MyClass<TypeVar1, ‚Ä¶, TypeVarN> {‚Ä¶} interface MyInterface<TypeVar1, ‚Ä¶, TypeVarN> {‚Ä¶} MyClass<String, ‚Ä¶, Date> x = new MyClass<>(); Restricting Instantiations by Clients 9 boolean add1(Object element); boolean add2(Number element); add1(new Date()); // OK add2(new Date()); // compile-time error interface List1<E> {‚Ä¶} interface List2<E extends Number> {‚Ä¶} List1<Date> // OK, Date is a subtype of Object List2<Date> // compile-time error, Date is not a // subtype of Number Using Type Variables Code can perform any operation permitted by the bound Because we know all instantiations will be subtypes An enforced precondition on type instantiations 10 Using Type Variables 11 class Foo1<E> { void m(E arg) { arg.intValue(); // compiler error, E might // not support intValue } } class Foo2<E extends Number> { void m(E arg) { arg.intValue(); // OK, since Number and its // subtypes support intValue } } Examples of Bounds 12 public class Graph<N> implements Iterable<N> { private final Map<N, Set<N>> node2neighbors; public Graph(Set<N> nodes, Set<Pair<N,N>> edges) { ‚Ä¶ } ‚Ä¶ } public class TreeSet<T extends Comparable<T>> { ‚Ä¶ } Generics Classes are not Enough 13 static void arrayToCollection(Object[] array, Collection<Object> c) { for (Object obj : array) { c.add(obj); } } Would like to use arrayToCollection for any element For example, Double or Integer But as we will see, Collection<Double> is not a subtype of Collection <Object> Class that contains arrayToCollection is not generic, but the method should be generic Generic Methods Solve the Problem 14 static <T> void arrayToCollection(T[] array, Collection<T> c) { for (T obj : array) { c.add(obj); } } String[] sa = new String[100]; Collection<String> sc = new ArrayList<String>(); arrayToCollection(sa, sc); Generic Methods Examples 15 <T extends Comparable<T>> T max(Collection<T> c) { // ‚Ä¶ use T.compareTo } <T> void copyTo(List<T> dst, List<T> src) { for (T t : src) dst.add(t); } <T extends Comparable<T>> void sort(List<T> list) { // ‚Ä¶ use list.get and T.compareTo } Works but we‚Äôll see a more useful version later Generics and Subtyping Integer is a subtype of Number Is List<Integer> a subtype of a List<Number>? Let‚Äôs use subtyping to find out ‚Ä¶ 16 Generics and Subtyping List<Number> has: List<Integer> has: Java subtyping is invariant with respect to generics Neither List<Number> nor List<Integer> subtype of other 17 boolean add(Number element); Number get(int index); boolean add(Integer element); Integer get(int index); Generics and Subtyping If T1 and T2 are different types, then for all Foo, Foo<T1> is not a subtype of Foo<T2> Previous example shows why: Observer methods prevent one direction Mutator/producer methods prevent the other direction If our types have only observers or only mutators, then one direction of subtyping would be fine But Java‚Äôs type system is not expressive enough to allow this 18 Read-only Allows Covariance If ReadOnlyList<T> has only observers, then ReadOnlyList<Number> has: ReadOnlyList<Integer> has: So covariant subtyping would be correct ReadOnlyList<Integer> is a true subtype of ReadOnlyList<Number> But Java conservatively disallows this subtyping 19 Number get(int index); Integer get(int index); Write-only Allows Contravariance If WriteOnlyList<T> has only mutators and producers, then WriteOnlyList<Number> has: WriteOnlyList<Integer> has: So contravariant subtyping would be correct WriteOnlyList<Number> is a true subtype of WriteOnlyList<Integer> But Java conservatively disallows this subtyping 20 boolean add(Number element); boolean add(Integer element); Generics and Subtyping In general, List<T> should be Covariant if T only appears as a return value Contravariant if T only appears as an argument Some languages (e.g., Scala and C#) allow this Java does not Cannot substitute List<T1> for List<T2> unless T1 = T2 However: LinkedList<Number> is a Java subtype of List<Number> LinkedList<Integer> is a Java subtype of List<Integer> ‚Ä¶ 21 Invariant Subtyping and Bounds What is the best type for addAll‚Äôs parameter? Allow as many clients as possible While allowing only correct implementations 22 interface Set<E> { // Adds all elements in c to this set (that are not already present) void addAll(???? c); } Invariant Subtyping and Bounds Too restrictive: Does not let clients pass other collections, like List<E> 23 interface Set<E> { // Adds all elements in c to this set (that are not already present) void addAll(Set<E> c); } Invariant Subtyping and Bounds Still too restrictive: Client cannot pass a List<Integer> to addAll for a Set<Number> That should be okay because addAll implementations only need to read from c, not put elements in it But Java does not allow it because of the invariant-subtyping limitation 24 interface Set<E> { // Adds all elements in c to this set (that are not already present) void addAll(Collection<E> c); } Invariant Subtyping and Bounds The fix: A bounded generic type parameter Now client can pass a List<Integer> to addAll for a Set<Number> addAll implementations won‚Äôt know what element type T is, but will know it is a subtype of E It cannot add anything to collection c But this is enough to implement addAll 25 interface Set<E> { // Adds all elements in c to this set (that are not already present) <T extends E> void addAll(Collection<T> c); } Revisited copyTo Method Earlier version: More general: 26 <T> void copyTo(List<T> dst, List<T> src) { for (T t : src) dst.add(t); } <T1, T2 extends T1> void copyTo(List<T1> dst, List<T2> src) { for (T2 t : src) dst.add(t); } Wildcards Syntax: for a type-parameter instantiation (inside the <‚Ä¶>), can write: <? extends Type> - some unspecified subtype of Type <?> - a shorthand for <? extends Object> <? super Type> - some unspecified supertype of Type A wildcard is an anonymous type variable Each ? stands for some possibly-different unknown type Use it when you would use a type variable only once so no need to give it a name Communicates to readers of your code that the type‚Äôs ‚Äúidentity‚Äù is not needed anywhere else 27 Wildcards Example Earlier version: Equally powerful: 28 interface Set<E> { <T extends E> void addAll(Collection<T> c); } interface Set<E> { void addAll(Collection<? extends E> c); } Cannot Always Use Wildcards Here we cannot use wildcards because T is used more than once 29 <T extends Comparable<T>> T max(Collection<T> c); Where to Use Wildcards? Use ? extends T when you get values No problem if it‚Äôs a subtype (the covariant subtyping case) Use ? super T when you put values No problem if it‚Äôs a supertype (the contravariant subtyping case) Use neither (just T, not ?) if you both get and put 30 Type Erasure All generic types become type Object once compiled Gives backward compatibility At run-time, all generic instantiations have the same type 31 List<String> lst1 = new ArrayList<>(); List<Integer> lst2 = new ArrayList<>(); Lst1.getClass() == lst2.getClass(); // true Type Erasure Has several tricky implications Cannot use instanceof to discover a generic type parameter Casting to a generic type Array of generics types ‚Ä¶ 32 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #10: Error Handling Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 Not All Errors Should be Failures Misuse of your code E.g., precondition violation Should be a failure Errors in your code E.g., representation invariant fails to hold Should be a failure Unexpected resource problems E.g., missing file, server offline, out of memory ‚Ä¶ Should not be a failure, try to recover 2 What To Do When Failing Fail fast and fail friendly Failing quickly helps localize the defect Goal 1: Give information about the problem Important for debugging Goal 2: Prevent harm Stop before anything worse happens 3 Prevent Harm Several options: Abort Prevent computation Perform cleanup actions, log the error, etc. Re-try Problem might be transient Skip a subcomputation Permit rest of program to continue Fix the problem Usually infeasible to repair from an unexpected state 4 Avoiding Errors A precondition prohibits misuse of your code Weakens the spec by throwing out unhandled cases This ignores the problem of errors-will-happen Removing a precondition requires specifying more behavior Example: specify that an exception is thrown Often a good thing, but there are tradeoffs Strengthens the spec 5 Defensive Programming Question is not: Will you make mistakes? You will Question is: Will you catch those mistakes early? Write and incorporate code designed to catch the errors you make Check rep invariant on operation entry and exit Check preconditions (don‚Äôt trust other programmers) Check postconditions (don‚Äôt trust yourself either) Check other properties that you know to be true 6 Defensive Programming Check these statically via reasoning and tools Check these dynamically via assertions Write assertions as you write code Include descriptive messages 7 assert items != null : \"null item list argument\"; assert size % 2 == 0 : \"Bad size for \" + toString(); Assertions In Java, assertions can be enabled or disabled at runtime A flag to the JVM Disabled by default! Turn them off only in rare circumstances May be too slow in production code Most assertions better left enabled 8 Assertions Example These two assertions serve different purposes First assertion: check precondition Second assertion: check postcondition 9 // @requires x >= 0 // @return approximation to square root of x public double sqrt(double x) { assert x >= 0.0; double result; /* compute result */ assert Math.abs(result*result ‚Äì x) < .0001; return result; } Square Root, Specified for All Inputs throws keyword is part of a method signature: ‚Äúit might happen‚Äù Declares comma-separated list of exceptions throw is a statement that causes exception-throw Immediate control transfer (like return but different) 10 // @throws IllegalArgumentException if x < 0 // @return approximation to square root of x public double sqrt(double x) throws IllegalArgumentException { if (x < 0) throw new IllegalArgumentException( \"sqrt needs positive x, got \" + x); ‚Ä¶ } Using try-catch to Handle Exceptions Client code: Exception is handled by nearest dynamically enclosing try/catch 11 try { y = sqrt(‚Ä¶); } catch (IllegalArgumentException e) { e.printStackTrace(); // and/or take other actions } Throwing and Catching Stack of currently executing methods reflects runtime order of method calls When an exception is thrown, control transfers to nearest method with a matching catch block If none found, top-level handler prints stack trace and terminates Exceptions allow non-local error handling 12 Throwing and Catching 13 (Partial) Exceptions Hierarchy 14 Code that Throws Exceptions Divide by Zero: Trying to dereference a null variable: Trying to interpret input in the wrong way: Reading a non-existent file: 15 int x = 0; System.out.println(1/x); // ArithmeticException Point p = null; p.translate(2, -3); // NullPointerException int err = Integer.parseInt(\"hi\"); // NumberFormatException // FileNotFoundException Scanner in = new Scanner(new File(\"notHere.txt\")); Catching with Inheritance Subsequent catch blocks need not be supertypes like this But order matters: check for matching type in given order 16 try { /* code */ } catch (FileNotFoundException fnfe) { /* code to handle a file not found exception */ } catch (IOException ioe) { /* code to handle any other I/O exception */ } catch (Exception e) { /* code to handle any other exception */ } Java‚Äôs Checked/Unchecked Distinction Checked exceptions (for ‚Äúspecial cases‚Äù) Callee: Must declare in signature (else compile error) Client: Must either catch or declare (else compile error) Unchecked exceptions (for ‚Äúunexpected cases‚Äù/bugs) Library: No need to declare Client: No need to catch Subclasses of: RuntimeException Error (rarely caught) 17 Checked vs. Unchecked Advantages to checked exceptions: Ensures callee throws no other checked exceptions Ensures caller does not forget to check Disadvantages: Makes it harder to implement Have to catch or declare even in clients where the exception is not possible Which one is better ‚Äì check or unchecked exceptions? No perfect answer Java provided both options 18 Handling Exceptions Two uses of exceptions 1. Errors that should be failures Unexpected (ideally, should not happen at all) Should be rare with high quality client and library 2. Special results Expected but not the common case Unpredictable or unpreventable by client 19 Handling Exceptions 1. Errors that should be failures Usually can‚Äôt recover Unchecked exceptions the better choice (else many methods have to declare they could throw it) 2. Special results Take special action and continue computing Should always check for this condition Should handle locally by code that knows how to continue Checked exceptions the better choice 20 Don‚Äôt Ignore Exceptions Empty catch block is common poor style Often done to get code to compile despite checked exceptions Defeats the purpose of exceptions At a minimum, print out the exception so you know it happened And exit if that‚Äôs appropriate for the application 21 try { readFile(filename); } catch (IOException e) {} // silent failure } catch (IOException e) { e.printStackTrace(); System.exit(1); } Propagating an Exception 22 // @return x such that ax^2 + bx + c = 0 // @throw: IllegalArgumentException if no real solution exists double solveQuad(double a, double b, double c) throws IllegalArgumentException { return (-b + sqrt(b*b - 4*a*c)) / (2*a); } Why Catch Exceptions Locally? Failure to catch exceptions often violates modularity Example call chain: A -> IntegerSet.insert -> IntegerList.insert IntegerList.insert throws some exception Implementer of IntegerSet.insert knows how list is being used Implementer of A may not even know that IntegerList exists 23 Exception Chaining Some exceptions are detected at lower level of abstraction but must be handled in higher levels of abstraction Missing file, low battery, out of memory, ‚Ä¶ Alternative: catch it and throw again (‚Äúchaining‚Äù) Restate exception in a level of abstraction that client can understand 24 Exception Chaining for solveQuad 25 // @return x such that ax^2 + bx + c = 0 // @throw: NotRealException if no real solution exists double solveQuad(double a, double b, double c) throws NotRealException { try { double discriminant = b*b ‚Äì 4*a*c; return (-b + discriminant)) / (2*a); } catch (IllegalArgumentException e) { // ‚Äúchaining‚Äù throw new NotRealException( ‚ÄúNeed positive b^2-4ac, got \" + discriminant, e); } } Exception Chaining for solveQuad 26 // Exception thrown when not a real number class NotRealException extends Exception { // implement constructor analogous to each of super's NotRealException() { super(); } NotRealException(String message) { super(message); } NotRealException(Throwable cause) { super(cause); } NotRealException(String msg, Throwable c) { super(msg, c); } } Returning Special Values An alternative to throwing an exception is returning a special value null for Map.get -1 for indexOf NaN for sqrt of negative number 27 Returning Special Values Advantages: Less verbose clients than try/catch machinery Disadvantages: Error-prone: callers may forget to check Need ‚Äúextra‚Äù result: Doesn‚Äôt work if every result could be real Has to be propagated manually one call at a time For exceptional conditions in Java, use exceptions 28 Optionals Java 8 introduced a new type called Optional<T> Container type for a value which may be absent (empty) Help developers deal with null values properly 29 Tonny Hoare ‚ÄúI call it my billion-dollar mistake. It was the invention of the null reference in 1965. I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement.‚Äù Dealing with Absent Values Using Optional: findUserById returns an Optional<User> Make it clear to the clients of this method that there might not be a User with the given id Clients of this method are explicitly forced to handle this fact 30 // @return the user‚Äôs details of the user with the given id after // fetching them from the database Optional<User> findUserById(String id) { ‚Ä¶ } Benefits of Optionals Optionals help design better APIs By reading the signature of a method users can tell whether to expect an optional value Force clients to think about the case when the value is not present Optional are designed with functional programming in mind Very powerful when used with lambdas 31 Summary Use an assertion for internal consistency checks that should not fail Use a precondition when Used in a narrow context in which calls can be checked Checking would be prohibitive Use an exception when Used in a broad or unpredictable context Checking the condition is feasible Use an optional when An API may return a value or no value A compromise between a special value and an exception 32 Summary Not all exceptions are errors (just special cases) Use checked exceptions most of the time Avoid checked exceptions if there is probably no way to recover Handle exceptions sooner rather than later 33 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #11: Testing Partially based on slides of MIT 6.031, Univ. of Washington CSE 331 How Do We Ensure Correctness? Best practice - Use three techniques: 1. Tools Type checking, @Override, libraries, etc. 2. Inspection / code review Think through your code carefully Have another person review your code 3. Testing Usually >50% of the work in building software Each removes ~2/3 of bugs. Together >97% 2 Number of Defects Typical industry software 1-10 defects/1000 lines of code High quality software Example: Java libraries 0.1-1 detects/1000 lines of code Safety-critical software Examples: air traffic control, life-support medical equipment 0.01-0.1 defects/1000 lines of code A typical software with a million lines of code will ship with 1000 bugs! 3 Formal Verification Can‚Äôt we construct a formal proof that a program is correct? Tedious to do by hand so done with the help of automated tools Cannot verify that the specification is correct Possible only for some programs Sometimes done only for small, crucial pieces of a program 4 Code Review Careful, systematic study of source code by people who are not the original author of the code Analogous to proofreading an academic paper Has two purposes Improve the code Improve the programmer Widely practiced in the industry Studies show about 80% reduction in errors 5 Testing 6 Edsgar Dijkstra ‚ÄúProgram testing can be used to show the presence of bugs, but never to show their absence!‚Äù Who Tests Software? Your code should be tested as much as possible by as many people as possible Which includes you Probably, you will be expected to test your own code Developers unit test their own code Other tests usually performed by QA department or client themselves QA testers are the last line of defense before production world They are not a substitute for you taking responsibility for the correctness of your code 7 Testing Your Own Code Confirmation bias Tendency to avoid evidence that you‚Äôre wrong Can be avoided by writing most of your tests before the code Operant conditioning Programmers are rewarded when the code works Testers are rewarded when the code breaks 8 Kind of Testing Unit testing versus system/integration testing One module‚Äôs functionality versus pieces fitting together Black-box testing versus white-box testing Does implementation influence test creation? Did you look at the code when writing the test? 9 Unit Testing vs. Integration Testing A unit test focuses on one method/class/interface/ module Tests a single unit in isolation from all others If it fails, defect is localized so easier debugging Unit isolation may require stub version of modules Integration tests verify that the modules work together properly Usually don‚Äôt want these until the units are well tested 10 Black Box vs. White Box Black-box testing Tests designed using only information in the specification White box (clear box / glass box) testing Implementation influences test design Both types of tests pass for any implementation 11 How is Testing Done? Write the test 1. Choose input / configuration 2. Define the expected outcome Run the test 3. Run with input and record the outcome 4. Compare observed outcome to expected outcome 12 What‚Äôs So Hard About Testing? ‚ÄúJust try it and see if it works...‚Äù Exhaustive testing would require 1 trillion runs! Impractical even for this trivially small problem 13 // @requires 1 <= x,y,z <= 10000 // @return some computation f(x,y,z) int foo(int x, int y, int z) {‚Ä¶} Random Testing Other engineering disciplines: Test small random samples and infer the defect rate for the whole production lot Doesn‚Äôt work well for software Software behavior varies discontinuously and discretely across the space of possible inputs May abruptly fail at a single boundary point E.g., stack overflows, out of memory No probabilistic distribution near the failure point Always the same way 14 Choosing Test Suite Key problem: Choosing test suite Large/diverse enough to provide a useful amount of validation Small enough to write/run in a reasonable amount of time 15 Partitioning the Input Space Ideal test suite: Identify sets with same behavior Test one input from each set Two problems: 1. Notion of same behavior is subtle Naive approach: execution equivalence Better approach: revealing subdomains 2. Discovering the sets requires perfect knowledge If we had it, we wouldn‚Äôt need to test Use heuristics to approximate cheaply 16 Execution Equivalence All x < 0 are execution equivalent: Program takes same sequence of steps for any x < 0 All x ‚â• 0 are execution equivalent Suggests that {-3, 3}, for example, is a good test suite 17 // @return x < 0 => returns ‚Äìx // otherwise => returns x int abs(int x) { if (x < 0) return -x; else return x; } Execution Equivalence {-3, 3} does not reveal the error Two possible executions: x < -2 and x ‚â• -2 Three possible behaviors: x < -2 OK x = -2 or x= -1 BAD x ‚â• 0 OK 18 // @return x < 0 => returns ‚Äìx // otherwise => returns x int abs(int x) { if (x < -2) return -x; else return x; } Heuristic: Revealing Subdomains A subdomain is a subset of possible inputs A subdomain is revealing for error E if either: Every input in that subdomain triggers error E, or No input in that subdomain triggers error E Need test only one input from a given subdomain If subdomains cover the entire input space, we are guaranteed to detect the error if it is present The trick is to guess these revealing subdomains 19 Revealing Subdomains Example sets of subdomains: Too many: ‚Ä¶ {-2} {-1} {0} {1} ‚Ä¶ Not revealing: {‚Ä¶,-6, -5, -4} {-3, -2, -1} {0, 1, 2, ‚Ä¶} Revealing: {‚Ä¶, -4, -3} {-2, -1} {0, 1, ‚Ä¶} 20 // @return x < 0 => returns ‚Äìx // otherwise => returns x int abs(int x) { if (x < -2) return -x; else return x; } Heuristics for Designing Test Suites A good heuristic gives: For all errors in some class of errors E: high probability that some subdomain is revealing for E (i.e., triggers E) A reasonable number of subdomains Different heuristics target different classes of errors In practice, combine multiple heuristics 21 Heuristic: Black-Box Testing Explore alternate cases in the specification Procedure is a black box: specification visible, internals hidden 3 cases lead to 3 tests (4, 3) => 4 (i.e. any input in the subdomain a > b) (3, 4) => 4 (i.e. any input in the subdomain a < b) (3, 3) => 3 (i.e. any input in the subdomain a = b) 22 // @return a > b => returns a // a < b => returns b // a = b => returns a int max(int a, int b) {‚Ä¶} Another Black-Box Testing Example Two obvious black-box tests: ( [4, 5, 6], 5 ) => 1 ( [4, 5, 6], 7 ) => throw MissingValueException Have we captured all the cases? ( [4, 5, 5], 5 ) => 1 Must hunt for multiple cases Explicit cases in the spec are not enough 23 // @returns the smallest i such that a[i] == value // @throws MissingValueException if value is not in a int find(int[] a, int value) throws MissingValueException Black Box Testing Advantages Process is not influenced by component being tested Assumptions embodied in code not propagated to test data Robust with respect to changes in implementation Allows for independent testers Testers need not be familiar with code Tests can be developed before the code 24 Heuristic: Boundary Testing Create tests at the edges of subdomains Why? Off-by-one bugs Special cases: e.g., zero elements, null Discontinuity in the code behavior: e.g., overflow Object aliasing Small subdomains at the edges of the ‚Äúmain‚Äù subdomains have a high probability of revealing many common errors Also, you might have misdrawn the boundaries 25 Boundary Testing To define the boundary, need a notion of adjacent inputs One approach: Identify basic operations on input values Two input values are adjacent if one basic operation apart Value is on a boundary if either: There exists an adjacent value in a different subdomain Some basic operation cannot be applied to the value Example: List of integers Basic operations: create, set, append, remove Adjacent values: <[2,3],[2,4]>, <[2,3],[2,3,3]>, <[2,3],[2]> Boundary values: [ ] (can‚Äôt apply remove) 26 Other Boundary Cases Arithmetic Smallest/largest values Zero Objects Null Empty string, list, array First and last element of a collection Circular list Aliasing (same object passed as multiple arguments) 27 Boundary Cases: Integers What are some values of x that might be worth probing? x < 0 (flips sign) or x ‚â• 0 (returns unchanged) Around x = 0 (boundary condition) Specific tests: say x = -1, 0, 1 28 // @return |x| int abs(int x) { Boundary Cases: Arithmetic Overflow From Javadoc for Math.abs: ‚ÄúNote that if the argument is equal to the value of Integer.MIN_VALUE, the most negative representable int value, the result is that same value, which is negative.‚Äù 29 int x = Integer.MIN_VALUE; System.out.println(x<0); System.out.println(Math.abs(x)<0); // x=-2147483648 // true // also true! Boundary Cases: Aliasing What happens if src and dest refer to the same object? This is aliasing It‚Äôs easy to forget Watch out for shared references in inputs 30 // @modifies src, dest // @effects Removes all elements of src and appends them in reverse // order to the end of dest <E> void appendList(List<E> src, List<E> dest) { while (src.size()>0) { E element = src.remove(src.size()-1); dest.add(element); } } Heuristic: White Box Testing Focus on features not described by specification Use knowledge of implementation Control-flow details (e.g., conditions of ‚Äúif‚Äù statements in code) 31 Heuristic: White Box Testing Common goal is high code coverage Ensure test suite covers (executes) all the program Measure quality of test suite with % coverage Tools to measure this for you Assumption implicit in goal: If high coverage, then most mistakes discovered Far from perfect but widely used 32 White Box Testing Motivation There are some subdomains that black-box testing won't catch: 33 boolean[] primeTable = new boolean[CACHE_SIZE]; boolean isPrime(int x) { if (x > CACHE_SIZE) { for (int i=2; i <= x/2; i++) { if (x % i == 0) return false; } return true; } else return primeTable[x]; } White Box Testing Advantage: Finds important class of boundaries Yields useful test cases Consider CACHE_SIZE in isPrime example Important tests CACHE_SIZE-1, CACHE_SIZE, CACHE_SIZE+1 Disadvantage: Buggy code tricks you into thinking it‚Äôs right once you look at it Tests may have same bugs as implementation 34 White Box Testing Black box subdomains: {‚Ä¶ -2, -1, 0} {1, 2, ‚Ä¶} Boundary cases: 0, 1 White box subdomains: {‚Ä¶ -3, -2, 0} {-1, 0, ‚Ä¶} Boundary cases: -2, -1 35 // @return if x < 0 => -x // otherwise => x int abs(int x) { if (x < -2) return -x; else return x; } Code Coverage: Statement Coverage Consider any test with a ‚â§ b (e.g., min(1,2)) Statement coverage: Executes every instruction Misses the bug Statement coverage is not enough 36 int min(int a, int b) { int r = a; if (a <= b) r = a; return r; } Code Coverage: Branch Coverage Consider two-test suite: (2,-2) and (-2,2) Branch coverage: All tests ‚Äúgo both ways‚Äù Misses the bug Branch coverage is not enough 37 int quadrant(int x, int y) { int ans; if (x >= 0) ans=1; else ans=2; if (y < 0) ans=4; return ans; } Here, path coverage is enough Every possible combination of branches (4 in this example) Code Coverage: Path Coverage Consider two-test suite: {0,0} and {1} Misses the bug Or consider one-test suite: {0,1,0} Misses the bug Branch coverage is not enough Here, path coverage is enough, but no bound on path-count 38 int countPositive(int[] arr) { int answer = 0; for (int x : arr) if (x > 0) answer = 1; // should be answer += 1; return answer; } Code Coverage: Path Coverage Path coverage is not enough Consider test suites where c is always 0 Typically a ‚Äúfalse point‚Äù since path coverage is unattainable for realistic programs But do not assume a tested path is correct Even though it is more likely correct than an untested path 39 int sumOfThree(int a, int b, int c) { return a+b; } Varieties of Coverage Various coverage metrics Statement coverage Branch coverage Path coverage Limitations of coverage: 100% coverage is not always a reasonable target Coverage is just a heuristic We really want the revealing subdomains 40 Increasing number of test cases required Code Coverage Tools Coverage is usually measured by a code coverage tool 41 Pragmatics: Regression Testing Whenever you find a bug Store the input that elicited that bug, plus the correct output Add these to the test suite Verify that the test suite fails Fix the bug Verify the fix Ensures that your fix solves the problem Protects against reversions that reintroduce bug 42 Quiz: Black and White Box Testing ◊ë ◊©◊ï◊û◊ô◊©-Kahoot ◊®◊™◊ê◊ú ◊ï◊©◊ú◊íkahoot.it ◊™◊ô◊ô◊¶◊ß◊ô◊ú◊§◊ê◊ë ◊ï◊©◊û◊™◊©◊î ◊ï◊êKahoot! ◊î ◊®◊§◊°◊û ◊™◊ê ◊ï◊©◊ô◊ß◊î-PIN◊ù◊õ◊™◊ê ◊£◊™◊©◊û ◊ô◊†◊ê◊© ◊ö◊°◊û◊î ◊ú◊¢ ◊ù◊ô◊ê◊ï◊® ◊ù◊™◊ê◊© ◊ù◊© ◊©◊ô◊ß◊î◊ú ◊ù◊ô◊©◊ß◊ë◊™◊û ◊ù◊™◊ê◊©◊õ , ◊™◊ê ◊ï◊©◊ô◊ß◊î◊ù◊õ◊ú◊© ◊™◊ï◊î◊ñ◊î ◊™◊ì◊ï◊¢◊™ ◊®◊§◊°◊û ◊î◊§ ◊ù◊™◊ê◊© ◊¢◊ì◊ê ◊ô◊†◊ê ◊î◊õ◊õ 43 Summary of Heuristics Split subdomains according to the specification Split subdomains according to the implementation Test boundaries that commonly lead to errors Tests to exercise every branch of the code All paths would be even nicer (but not always possible) Test any cases that caused bugs before Don't confuse volume with quality of tests Look for revealing subdomains Want tests in every subdomain not just lots of tests 44 Testing Tips Test early and test often Best to catch bugs soon, before they have a chance to hide Automate the process if you can Regression testing will save time Write tests both before and after you write the code Only white box tests need to come afterward Be systematic: Think through revealing subdomains and test each one Writing tests is a good way to understand the spec Spec can be buggy too Incorrect, incomplete, ambiguous, missing corner cases 45 Testing Tools Modern development ecosystems have built-in support for testing In this course we will work with JUnit Standard framework for testing in Java You will see examples in the recitation class You will see more sophisticated tools in industry Tools that ensure tests pass before code is submitted Libraries for creating mock implementations of other modules Automated tools to test on every platform Automated tools to find severe bugs 46 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #12: Software Development Process Partially based on slides of Software Engineering 10th ed. by Ian Sommerville Reminder: The Software Crisis 2 ‚ÄúSoftware and cathedrals are much the same ‚Äì first we build them, then we pray.‚Äù ‚Äì Sam Redwine Software Project Failures We‚Äôve seen that many software projects fail Why? Large software systems are enormously complex Extreme need for modifiability 3 Software Engineering It‚Äôs fairly easy to write computer programs without using software engineering methods Results in more expensive and less reliable software So, what can we do about this? No silver bullet! (Brooks, 1986) But applying software engineering techniques can help a lot 4 Software Engineering Defined Software Engineering (IEEE standard glossary of software engineering terminology): The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software. 5 Software Engineering in a Nutshell Software engineering is concerned with all aspects of software production Software engineering is about managing complexity Managing change Coping with potential defects Essence of all engineering Solve problems Bearing in mind constraints Technological, organizational, financial , ‚Ä¶ 6 All Aspects of Software Production Project management Development of tools, methods, etc. to support software production Working with limited time and resources Managing risk Teamwork and communication 7 Attributes of Good Software Correct Delivers the required functionality and performance to the user Maintainable Easy to change Dependable Reliable: Performs according to its specifications Safe: Should not cause physical or economic damage in the event of system failure Secure: Malicious users should not be able to access or damage the system 8 Attributes of Good Software Efficient Responsiveness, processing time, memory utilization Should not make wasteful use of system resources such as memory and processor cycles Acceptable Understandable Usable: Easy to use or to perform prescribed tasks Compatible with other systems that users use 9 Software Diversity Many different types of software systems Stand-alone Interactive transaction-based Embedded control Batch processing Entertainment Modeling and simulation Data collection System of systems 10 Choosing Methods and Tools No universal set of software techniques that is applicable to all of these The software engineering methods and tools used should be carefully selected Depends on type of application being developed Depends on requirements of the customer Depends on the background of the development team 11 Software Engineering Fundamentals Systems should be developed using a managed and understood development process Dependability and performance are important Understanding and managing the software specification and requirements (what the software should do) are important Where appropriate, you should reuse software that has already been developed rather than write new software 12 Software Development Process Four main software engineering activities: 1. Specification Defined by customers and engineers Describes the software to be produced Including constraints on its operation 2. Development Converting the specification into an executable system Design and implementation (programming) 13 Software Development Process 3. Validation Checking that a software meets its specification and fulfills its intended purpose Most common: testing 4. Evolution Modifications to reflect changing customer and market requirements 14 Software Development Process ‚ò∫ 15 Plan-driven vs. Agile Process Plan-driven process: All process activities are planned in advance Progress is measured against this plan Agile process: Planning is incremental Easier to change the process to reflect changing customer requirements In practice, most practical processes include elements of both plan-driven and agile approaches 16 Waterfall vs. Incremental Model The waterfall model Plan-driven model Separate and distinct phases of specification and development Incremental development model Plan-driven or agile Specification, development and validation are interleaved In practice, most large systems are developed using a process that incorporates elements from both models 17 Software Process Models Code-and-fix: Write code, fix it when it breaks Waterfall: Perform each phase in order Spiral: Prioritize riskiest things first Staged delivery: Build initial requirement specs or several releases, then design-and-code each in sequence Evolutionary prototyping: Do the next easiest thing that could possibly lead to feedback 18 Code-and-fix Advantages: Little to no overhead, see progress quickly Applicable for very small projects and short-lived prototypes Disadvantages: No way to assess progress, quality, or risks Unlikely to accommodate changes without a major design overhaul Unclear delivery features, timing, and support 19 Requirements (maybe) Release (maybe) Design Stamina Hypothesis 20 Waterfall Model 21 Waterfall Model Advantages Tackles all planning upfront Efficient software development process Orderly, easy-to-follow sequential model Reviews at each stage determine if the product is ready to advance 22 Waterfall Model Drawbacks Main drawback of the waterfall: difficulty of accommodating change A phase has to be complete before moving onto the next phase Costly to go back to a previous phase Only appropriate when the requirements are well-understood and changes will be fairly limited during the design process Quite rare 23 Waterfall Model Drawbacks No sense of progress until the very end No code to show until almost done Integration occurs at the very end Contradicts ‚Äúintegrate early and often‚Äù rule No feedback until end Delivered product may not match customer needs 24 Incremental Development 25 Incremental Development 26 Incremental Development Benefits Cost of accommodating changing requirements is reduced Easier to get customer feedback More rapid delivery and deployment of useful software to the customer Lower risk of overall project failure 27 Incremental Development Problems Process is less visible Need regular deliverables to measure progress Not cost-effective to produce documents that reflect every version of the system Hard to identify common facilities that are needed by all increments System structure tends to degrade as new increments are added In many organizations, full specification is part of the system development contract 28 Spiral Model 29 An incremental model Each iteration is like a waterfall model Risk analysis is performed before each iteration More significant risks are mitigated first Spiral Model Advantages Accommodates change As costs increase, risks decrease Provides early indication of unforeseen problems Especially appropriate at the beginning of the project, when the requirements are still fluid 30 Spiral Model Disadvantages A lot of planning and management Frequent changes of task Requires customer and contract flexibility Developers must be able to assess risk Must address most important issues first 31 Staged Delivery Model Waterfall-like beginning Then, short release cycles plan, design, code, test, release Delivery possible at the end of any cycle 32 Requirements Definition Design Stage 1: detailed design, code, test, deliver Stage n: detailed design, code, test, deliver Staged Delivery Advantages Can ship at the end of any release cycle Looks like success to customers, even if not original goal Intermediate deliveries show progress, satisfy customers, and lead to feedback Problems are visible early (e.g., integration) Facilitates shorter, more predictable release cycles Very practical, widely used 33 Staged Delivery Model Disadvantages Requires tight coordination with documentation, management, marketing Product must be decomposable Extra releases cause overhead 34 Evolutionary Prototyping Model Develop a skeleton system and evolve it for delivery Different from staged delivery in that requirements are not known ahead of time Requirements are discovered by feedback 35 Initial concept Design and implement initial prototype Refine prototype until acceptable Complete and release Evolutionary Prototyping Model Advantages Addresses risks early Steady signs of progress build customer confidence Useful when requirements are unknown or changing Participatory design / useful feedback loops Very practical, widely used 36 Evolutionary Prototyping Model Disadvantages Requires close customer involvement Assumes user's initial spec is flexible Problems with planning Especially if the developers are inexperienced Feature creep, major design decisions, use of time, etc. Hard to estimate completion schedule or feature set Unclear how many iterations will be needed to finish Integration problems Temporary fixes become permanent constraints Requires low friction deployment and experimentation 37 Why So Many Models? Choice of a model depends on project circumstances and requirements A good choice can result in a vastly more productive environment than a bad choice A cocktail of models is frequently used in practice Models are often combined or tailored to environment Get the best of all worlds 38 Software Process Models Summary A management tool System for organizing effort among workers Forces planning and seeing consequences Splits work into smaller, tractable units Supports feedback and accurate timescales Limitations of these models: Can lead to artificial design constraints Risk of overemphasizing process over results Models only approximate actual practices 39 Requirements Engineering The process of establishing the services that a customer requires from a system Includes the constraints under which it operates and is developed Goal: Determine what the client need Not necessarily what the client wants Resulting requirements may be a basis for a contract A stakeholder is a person or organization who is affected by the system in some way and so who has a legitimate interest End users, system managers, system owners, external stakeholders 40 Functional and Non-Functional Requirements. Functional requirements Statements of services the system should provide How the system should react to particular inputs How the system should behave in particular situations Non-functional requirements Constraints on the services or functions offered by the system Constraints on performance (timing, space), usability, security, dependability, scalability, development, operation, environment, ethics, ‚Ä¶ 41 Examples of Functional Requirements 42 A user shall be able to search the appointments lists for all clinics. The system shall generate each day, for each clinic, a list of patients who are expected to attend appointments that day. Each staff member using the system shall be uniquely identified by his or her 8-digit employee number. Good Requirements Good requirements should be: Complete Include descriptions of all facilities required Consistent There should be no conflicts or contradictions in the descriptions In practice, because of system and environmental complexity, it is impossible to produce a complete and consistent requirements document 43 Examples of Non-functional Requirements 44 The system shall be available to all clinics during normal working hours (Mon-Fri, 08:30-17:30). Downtime within normal working hours shall not exceed five seconds in any one day. Users of the system shall authenticate themselves using their health authority identity card. The system shall implement patient privacy provisions as set out in HStan-03- 2006-priv. Metrics You should write non-functional requirements quantitatively so that they can be objectively tested Examples: Speed: processed transactions/second, user/event response time, screen refresh time Size: Mbytes Ease of use: training time, average to perform a specific task Reliability: mean time to failure, probability of unavailability, rate of failure occurrence, availability Robustness: time to restart after failure, percentage of events causing failure, probability of data corruption on failure 45 Requirements Elicitation Software engineers work with stakeholders to find out requirements Stages include requirements discovery, classification and organization, prioritization and negotiation, specification An iterative process 46 Requirements Elicitation Problems Stakeholders don‚Äôt know what they really want Stakeholders express requirements in their own terms Different stakeholders may have conflicting requirements Requirements change during the analysis process 47 Requirements Elicitation - Dos Talk to the users, or work with them, to learn how they work Ask questions throughout the process to \"dig\" for requirements Think about why users do something in your app, not just what Allow (and expect) requirements to change later 48 Requirements Elicitation ‚Äì Don‚Äôt Describe complex business logic or rules of the system Be too specific or detailed Describe the exact user interface used to implement a feature Try to think of everything ahead of time Add unnecessary features not wanted by the customers Feature creep: gradual accumulation of features over time Often has a negative overall effect on a large software project 49 Feature Creep Gradual accumulation of features over time Developers like to code them Marketers like to brag about them Users (think they) want them But too many means more bugs, more delays, less testing, ‚Ä¶ 50 Software Requirements Document An official statement of what is required of the system developers It is not a design document Should describe what the system should do rather than how it should do it Describes the problem, not the solution Should include as least the following chapters: Preface / introduction Functional requirements Non-functional requirements System evolution (anticipated future changes) 51 Good Software Requirements Document Good SRS document should be: Valid Provide the functions which best support the customer‚Äôs needs Consistent No requirements conflicts Complete All functions required by the customer included Realistic Can be implemented given the available budget and technology 52 Good Software Requirements Document Verifiable All requirements can be checked Comprehensible Requirements are properly understood Traceable Origin of each requirement is clearly stated Adaptable Requirements be changed without a large impact on other requirements 53 Stories and Use Cases User stories and use cases can assist in identifying, clarifying and organizing functional requirements Describe what the system does from a user‚Äôs perspective (as a ‚Äúblack box‚Äù) 54 User Story / Scenario A real-life example of how a system can be used for a particular task Describes a user need Written in the language of the users Easy for user to read Easy to change Often leave out a lot of details 55 User Story Example 56 A user realizes he mis-capitalized a word everywhere in his document, so he tells the word processor to search for all occurrences of it and replace them with the corrected word. Use Case A structured form of a user story Describes a complete interaction between the software and users (or other systems) Includes identification of user roles (actors) More formal Less easy to understand for end users Harder to change User stories are more popular in agile development processes 57 Use Cases A list of actions or event steps defining the interactions between an actor and a system to achieve a goal An actor is a role played by a user or another system that interacts with the system A stakeholder 58 Use Cases A person using a system may be represented as different actors E.g. a librarian playing the role of a reader when lending a book or the role a librarian when adding a new book to the library catalog A use case is always initiated by an actor A use case is complete Don‚Äôt divide a use case into smaller use cases that implement each other 59 Use Case Parts Precondition: a description of the starting situation A description of the normal flow of events Alternative paths (variations / exceptions): a description of what can go wrong Variations capture the less common interactions Exceptions capture things that prevent the actor from achieving his goal Postcondition: a description of the state when the scenario finishes 60 Use Case Example 61 Name: Search and replace Goal: All occurrences of a search term are replaced with replacement text Actors: regular user Preconditions: A document is loaded and being edited Description: 1. The user indicates that the software is to perform a search-and-replace in the document. 2. The software responds by requesting the search term and the replacement text. 3. The user inputs the search term and replacement text and indicates that all occurrences are to be replaced. 4. The software replaces all occurrences of the search term with the replacement text. Use Case Example 62 Postconditions: All occurrences of the search term have been replaced with the replacement text. Variations: 1. In Step 3, the user indicates that only the first occurrence is to be replaced. In this case, the software finds the first occurrence of the search term in the document being edited and replaces it with the replacement text. The postcondition state is identical, except only the first occurrence is replaced, and the replacement text is highlighted. 2. In Step 3, the user indicates that the software is only to search and not replace, and does not specify replacement text. In this case, the software highlights the first occurrence of the search term and the use case ends. 3. The user may decide to abort the search-and-replace operation at any time during Steps 1, 2, or 3. In this case, the software returns to the precondition state. Use Case Example 63 Exceptions: 1. In case of a system failure at any time during Steps 1, 2, or 3, the software returns to the precondition state. System Modeling The process of developing abstract models of a system Each model presents a different view of the system Helps to understand the functionality of the system Usually means representing a system using some kind of graphical notation The de facto standard: the Unified Modeling Language (UML) 64 UML A graphical modeling language that provides a way to visualize the design of a system Unification of the graphical modeling languages of Booch, Jacobson and Rumbaugh A standard since 1997 Can be used to document an existing system Can be used to generate a skeleton of a system implementation 65 UML Diagrams Two different views of a system model: Static (structure) view: emphasizes the static structure of the system using objects, attributes, operations and relationships Dynamic (behavior) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects 66 UML Diagrams 67 Example Use of UML Diagrams 68 Domain expert Use Case Diagram Actor A Use Case 1 Use Case 2 Use Case 3 Actor B Activity Diagram [yes] Actor A Actor B Class Diagram GrpFile read( ) open( ) create( ) fillFile( ) rep Repository name : char * = 0 readDoc( ) readFile( ) (from Persistence) FileMgr fetchDoc( ) sortByName( ) DocumentList add( ) delete( ) Document name : int docid : int numField : int get( ) open( ) close( ) read( ) sortFileList( ) create( ) fillDocument( ) fList 1 FileList add( ) delete( ) 1 File read( ) read() fill the code.. State Transition Diagram Openning Writing Reading Closing add file [ numberOffile==MAX ] / flag OFF add file close file close file Component Diagram Document Repository FileList FileManager GraphicFile File Communication Diagram user : ¬ª√ß¬ø√´√Ä√ö mainWnd : MainWnd fileMgr : FileMgr repository : Repository document : Document gFile : GrpFile 9: sortByName ( ) L 1: Doc view request ( ) 2: fetchDoc( ) 5: readDoc ( ) 7: readFile ( ) 3: create ( ) 6: fillDocument ( ) 4: create ( ) 8: fillFile ( ) Sequence Diagram user mainWnd fileMgr : FileMgr repositorydocument : Document gFile 1: Doc view request ( ) 2: fetchDoc( ) 3: create ( ) 4: create ( ) 5: readDoc ( ) 6: fillDocument ( ) 7: readFile ( ) 8: fillFile ( ) 9: sortByName ( ) √Ü¬Ø√Å¬§¬π¬Æ¬º¬ø¬° ¬¥√´√á√ë ¬∫¬∏¬±√¢¬∏¬¶ ¬ª√ß¬ø√´√Ä√ö¬∞¬° ¬ø√§√É¬ª√á√ë¬¥√ô. √à√Ä√è¬∞√º¬∏¬Æ√Ä√ö¬¥√Ç √Ä√ê¬æ√Æ¬ø√Ç ¬π¬Æ¬º√Ä√á √Å¬§¬∫¬∏¬∏¬¶ √á√ò¬¥√ß ¬π¬Æ¬º ¬∞¬¥√É¬º¬ø¬° ¬º¬≥√Å¬§√Ä¬ª ¬ø√§√É¬ª√á√ë¬¥√ô. √à¬∏√© ¬∞¬¥√É¬º¬¥√Ç √Ä√ê¬æ√Æ¬µ√©√Ä√é ¬∞¬¥√É¬º¬µ√©¬ø¬° ¬¥√´√á√ò √Ä√å¬∏¬ß¬∫¬∞¬∑√é √Å¬§¬∑√Ñ√Ä¬ª ¬Ω√É√Ñ√ë √à¬∏√©¬ø¬° ¬∫¬∏¬ø¬©√Å√ò¬¥√ô. Model space Deployment Diagram Window95 ¬π¬Æ¬º¬∞√º¬∏¬Æ √Ö¬¨¬∂√≥√Ä√å¬æ√∞√Ü¬Æ.EXE Windows NT ¬π¬Æ¬º¬∞√º¬∏¬Æ ¬ø¬£√Å√∏.EXE Windows NT Windows95 Solaris √Ä√Ä¬ø√´¬º¬π√∂.EXE Alpha UNIX IBM Mainframe ¬µ¬•√Ä√å√Ö¬∏¬∫¬£√Ä√å¬Ω¬∫¬º¬π√∂ Windows95 ¬π¬Æ¬º¬∞√º¬∏¬Æ ¬æ√ñ√á√É¬∏¬¥ ¬∫√ê¬ª√™ √à¬Ø¬∞√¶√Ä√á √á√è¬µ√•¬ø√æ¬æ√Æ¬π√ó ¬≥√ó√Ü¬Æ¬ø√∑√Ä¬∏¬∑√é√Ä√á √Å¬§¬∫¬∏ ¬Ω√É¬Ω¬∫√Ö√õ ¬ø¬¨¬∞√° ¬∏√∞¬µ¬® - √Ä¬©¬µ¬µ¬ø√¨ 95 : √Ö¬¨¬∂√≥√Ä√å¬æ√∞√Ü¬Æ - √Ä¬©¬µ¬µ¬ø√¨ NT: √Ä√Ä¬ø√´¬º¬π√∂ - √Ä¬Ø¬¥√ê¬Ω¬∫ ¬∏√ì¬Ω√Ö: √Ä√Ä¬ø√´ ¬º¬π√∂ ¬π√ó ¬µ¬•√Ä√å√Ö¬∏ ¬º¬π√∂, √Ö√´¬Ω√Ö ¬º¬π√∂ - IBM ¬∏√û√Ä√é√á√Å¬∑¬π√Ä√ì: ¬µ¬•√Ä√å√Ö¬∏ ¬º¬π√∂, √Ö√´¬Ω√Ö ¬º¬π√∂ Forward engineering (code generation) and reverse engineering Source code edit, compile, debug, link Executable System UML Diagrams 69 Use Case Diagram Shows the actors, use cases, and the relationships between them Which actors carry out which use cases Which use cases include other use cases A system is presented as a box An actor is presented as a stick figure 70 Use Case Diagram Actor generalization factors out common actor behavior The descendant actor can use all the use cases that have been defined for its ancestor 71 Use Case Diagram A use case is represented as an ellipsis Must be connected to at least one actor with a communication association Except for specialized / extending use cases 72 Use Case Relationships Include relationship When a number of use cases have common behavior, this behavior can be modeled in a single use case that is used by the other use cases Included use case must be complete 73 Use Case Relationships Generalization relationship Used when a number of use cases have some subtasks in common, but each one has something different about it The generalized and specialized use cases must share the same goal A specialized use case may capture an alternative scenario of the generalized use case The generalized use case must be complete 74 Use Case Relationships Extend relationship Similar to generalization relationship but the extended use case must explicitly declare its extension points 75 Use Case Diagram Example 76 Class Identification The library contains books and journals. It may have several copies of any given book. Books and journals have titles and a call-number. Each copy has a copy-number. For each book we record the author. Some of the books are on \"reserve\" and can only be checked-out for 3 hours, but all other books can be borrowed as a regular loan (for a three-week period). Members of the library can normally borrow up to six items at a time, but staff members can borrow up to ten items. Members of staff can borrow journals, but not regular members. The system must keep track of when books and journals are borrowed and returned. A librarian might want find out what items have been borrowed by a given member, and which copies of an item have been checked out and by whom. 77 Class Identification The library contains books and journals. It may have several copies of any given book. Books and journals have titles and a call-number. Each copy has a copy-number. For each book we record the author. Some of the books are on \"reserve\" and can only be checked-out for 3 hours, but all other books can be borrowed as a regular loan (for a three-week period). Members of the library can normally borrow up to six items at a time, but staff members can borrow up to ten items. Members of staff can borrow journals, but not regular members. The system must keep track of when books and journals are borrowed and returned. A librarian might want find out what items have been borrowed by a given member, and which copies of an item have been checked out and by whom. 78 Class Identification Relations between classes: Book is an item Journal is an item Copy is a copy of a book Copy has a copy number Book and journals have a title Book and journals have a call-number Book has an author Regular member is a library member Staff member is a library member 79 Class Identification The library contains books and journals. It may have several copies of any given book. Books and journals have titles and a call-number. Each copy has a copy-number. For each book we record the author. Some of the books are on \"reserve\" and can only be checked-out for 3 hours, but all other books can be borrowed as a regular loan (for a three-week period). Members of the library can normally borrow up to six items at a time, but staff members can borrow up to ten items. Members of staff can borrow journals, but not regular members. The system must keep track of when books and journals are borrowed and returned. A librarian might want find out what items have been borrowed by a given member, and which copies of an item have been checked out and by whom. 80 Class Identification The library contains books and journals. It may have several copies of any given book. Books and journals have titles and a call-number. Each copy has a copy-number. For each book we record the author. Some of the books are on \"reserve\" and can only be checked-out for 3 hours, but all other books can be borrowed as a regular loan (for a three-week period). Members of the library can normally borrow up to six items at a time, but staff members can borrow up to ten items. Members of staff can borrow journals, but not regular members. The system must keep track of when books and journals are borrowed and returned. A librarian might want find out what items have been borrowed by a given member, and which copies of an item have been checked out and by whom. 81 Class Identification Summary Nouns are possible classes Verbs are possible method Is a relation may indicate subtyping Has a relation may indicate composition 82 UML Diagrams 83 Sequence Diagram The most common interaction diagram An interaction diagram describes how groups of objects collaborate in some behavior Shows the sequence of interactions that take place during a particular use case Emphasizes the time ordering of messages 84 Sequence Diagram Example 85 Fragments A fragment is a box that encloses a portion of the interaction in a sequence diagram A fragment operator indicates the type of fragment For example: ref ‚Äì An interaction defined elsewhere in the model loop ‚Äì Loop until the guard condition is evaluated to false alt ‚Äì Execute interaction depending on which guard evaluates to true opt ‚Äì Execute the interaction only if the guard condition evaluates to true 86 Sequence Diagram Example 87 UML Diagrams 8888 Communication Diagram Semantically equivalent to a sequence diagram Can convert one diagram to the other without losing any information Emphasizes the organization of the objects that participate in an interaction Allows free placement of objects and allows to draw links to show how objects connect Better for visualizing object relationships Better for visualizing patterns of collaboration But does not show explicitly the sequence of messages Worse in visualizing the overall flow 89 Communication Diagram Example 90 UML Diagrams 91 State Machine Diagram Models the behavior of the system in response to external and internal events Shows system states as nodes and events as arcs between these nodes When an event occurs, the system moves from one state to another Similar to state machines you have all seen in the ‚ÄúDigital Systems‚Äù course 92 State Machine Diagram Example 93 UML Diagrams 94 Activity Diagram Shows the flow of control from activity to activity A flowchart Can be used to describe procedural logic or a work flow 95 Activity Diagram Example 96 Another Activity Diagram Example 97 UML Diagrams 98 Class Diagram The most widely used UML diagram Shows the classes in a system and the static relationships that exist among them Shows the properties and operations of a class Shows the constraints that apply to the way objects are connected 99 Class Example 100 Class Properties Syntax visibility name: type multiplicity = default-value {property} Visibility: + public, - private, # protected, ~ package Multiplicity Indication of how many objects may fill the property Examples: 1, 0..1, 1..10, * Property examples: {readOnly} ‚Äì may not be modified {ordered} ‚Äì objects in the data structure are stored in order {unique} ‚Äì no two objects in the data structure are the same Static properties are underlined 101 Class Operations Syntax visibility name (parameter list): return-type {property} Parameter syntax: direction name: type = default-value where direction is one of: in (the default), out, inout Property example: {query} ‚Äì an observer operation Static operations are underlined, and abstract operations are italicized 102 Association An association relationship between two classes indicates that Objects at one end of an association recognize objects at the other end Objects at one end of an association may send messages to (call methods of) objects at the other end 103 Association Even when bidirectional navigability seems required, unidirectional navigability may work Preferred due to lower coupling 104 Aggregation and Composition Strong forms of association Represent a is-a-part-of relationship E.g., a car has an engine and wheels as its parts Composition is stronger The whole is the sole owner of its parts Any instance of the part should be a component of only one whole Multiplicity of the whole side must be zero or one The lifetime of the part is dependent upon the whole The whole must manage the creation and destruction of its parts 105 Aggregation and Composition Aggregation Composition 106 Generalization Represents an is-a-king-of relationship Derived class inherits attributes, operations, and associations of the base class 107 Realization Used to show a class implementing operations specified by an interface 108 Compact Notation for Interfaces Ball and socket notion / ‚Äúlollipop‚Äù notation 109 Dependency A dependency exists between two classes if changes to the definition of one class may cause changes to the other E.g., one class mentions another as a parameter to an operation Weakest direct relationship between two classes Can add an appropriate keyword, for example: <<create>> - Source creates instances of the target <<use>> - Source requires the target for its implementation In software design, we try to minimize dependencies More on this later in the course ‚Ä¶ 110 Dependency Not a transitive relationship GUI does not depend on Die This may look in the code like this: 111 class Die { public void roll() { ‚Ä¶ } } class Player { public void takeTurn(Die die) { die.roll(); ‚Ä¶ } } Notes and Comments Can be linked with a dashed line to the element it is commenting 112 Class Diagram Example 113 UML Diagrams 114 Component Diagram A component is an encapsulated, reusable and replaceable part of the software Can do the same as a class Can have similar properties, operations and relationships But usually has bigger responsibility than a class 115 Component Diagram 116 UML Diagrams 117 UML Pitfalls Be careful about drawing UML diagrams without thoroughly understanding your system Be careful that the meaning of your diagram is what you intended UML is a language with quite a rigorous syntax and accepted semantics 118 UML Pitfalls Diagram fever: Don‚Äôt draw too many diagrams or too many details in each diagram The trick is to get the correct granularity Arrow happiness: Don‚Äôt draw arrows (associations) everywhere in your diagrams without much regard for the meaning of a given arrow 119 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #12: Agile Software Development Partially based on slides of Software Engineering 10th ed. by Ian Sommerville Rapid Software Development Rapid development and delivery is now often the most important requirement for software systems Businesses operate in a fast-changing environment Impossible to produce a set of stable software requirements Software has to evolve quickly to reflect changing business needs Plan-driven development does not meet these business needs Agile development methods aim to radically reduce the delivery time for working software systems Emerged in the late 1990s 2 Plan-driven vs. Agile Development Plan-driven development Separate development stages Outputs to be produced at each of these stages Planned in advance Incremental development is possible, but iterations occur within activities Agile development Specification, design, implementation and testing are interleaved Outputs from the development process are decided through a process of negotiation during the software development process 3 Plan-driven vs. Agile Development 4 Agile Methods Aims of agile methods: Reduce overheads in the software process Be able to respond quickly to changing requirements without excessive rework Based on an iterative approach to software development Deliver working software quickly and evolve it quickly to meet changing requirements 5 Agile Development Develop a series of versions/increments Program specification, design and implementation are interleaved Stakeholders involved in specification and evaluation Frequent delivery of new versions for evaluation Extensive tool support (e.g., automated testing tools) used to support development Minimal documentation Focus on working code 6 Agile Manifesto Signed by 17 software developers in 2001 7 Agile Manifesto 1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable software. 2. Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage. 3. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale. 4. Businesspeople and developers must work together daily throughout the project. 5. Build projects around motivated individuals. Give them the environment and support their need, and trust them to get the job done. 6. The most efficient and effective method of conveying information to and within a development team is face-to-face conversation. 8 Agile Manifesto 7. Working software is the primary measure of progress. 8. Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely. 9. Continuous attention to technical excellence and good design enhances agility. 10. Simplicity - the art of maximizing the amount of work not done - is essential. 11. The best architectures, requirements, and designs emerge from self- organizing teams. 12. At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly. 9 Extreme Programming A very influential agile method, developed in the late 1990s, that introduced a range of agile development techniques Takes an ‚Äòextreme‚Äô approach to iterative development New versions may be built several times per day Increments are delivered to customers every 2 weeks All tests must be run for every build and the build is only accepted if tests run successfully 10 Extreme Programming Practices Incremental planning Requirements are recorded on story cards Stories to be included in a release are determined by the time available and their relative priority Small releases The minimal useful set of functionality that provides business value is developed first Frequent releases that incrementally add functionality to the first release Simple design Enough design is carried out to meet the current requirements and no more 11 Extreme Programming Practices Test-first development Write tests before implementation Refactoring Refactor the code continuously As soon as possible code improvements are found Keeps the code simple and maintainable Pair programming Developers work in pairs Checking each other‚Äôs work and providing the support to always do a good job 12 Extreme Programming Practices Collective ownership Developers work on all areas of the system Anyone can change anything Continuous integration As soon as the work on a task is complete, it is integrated into the whole system After any such integration, all the unit tests in the system must pass Sustainable pace Large amounts of overtime are not acceptable Reduce code quality and medium-term productivity 13 Extreme Programming Practices On-site customer A representative of the end-user of the system is available full time for the use of the development team Customer is a member of the development team 14 Influential XP Practices Extreme programming is not easy to integrate with management practice in most organizations Consequently, while agile development uses practices from XP, the method as originally defined is not widely used Key practices User stories for specification Test-first development Pair programming Refactoring 15 Pair Programming Programmers working in pairs, developing code together Pairs are created dynamically All team members work with each other during the development process Spreads knowledge across the team Reduces the overall risks to a project when team members leave Serves as an informal review process Each line of code is looked at by more than one person Encourages refactoring Not necessarily inefficient 16 Refactoring Refactoring: improving a piece of software's internal structure without altering its external behavior Incurs a short-term overhead to reap long-term benefits A long-term investment in overall system quality 17 Why Refactor? Why fix a part of your system that isn't broken? Each part of your system's code has 3 purposes: Execute its functionality Allow change Communicate well to developers who read it If the code does not do these, it is broken Refactoring improves software's design Make it more extensible, flexible, understandable, performant, ‚Ä¶ 18 When to Refactor? Best done continuously as part of the process Hard to do well late in a project Refactor when you identify code ‚Äúsmells‚Äù Duplicate code, dead code Poor encapsulation Poor abstraction Too little cohesion, too much coupling Design is unnecessarily general or too specific ‚Ä¶ 19 Low-level Refactoring Names: Renaming (methods, variables) Naming \"magic\" constants Procedures: Extracting code into a method Extracting common functionality (including duplicate code) into a module/method/etc. Changing method signatures Reordering: Splitting a method to improve cohesion and readability Putting statements that semantically belong together near each other 20 IDE Support for Low-level Refactoring 21 High-level Refactoring Deep implementation and design changes Refactoring to design patterns Exchanging risky language idioms with safer alternatives Performance optimization ‚Ä¶ Compared to low-level refactoring, high-level is: Not as well-supported by tools Much more important! 22 How to Refactor? 1. Write unit tests that verify the code's external correctness They should pass on the current poorly designed code Having unit tests helps make sure any refactor doesn't break existing behavior (regressions) 2. Analyze the code to decide the risk and benefit of refactoring If it is too risky, not enough time remains, or the refactor will not produce enough benefit to the project, don't do it 3. Refactor the code Some tests may break; fix the bugs 23 How to Refactor? 4. Code review the changes 5. Check in your refactored code Keep each refactoring small; refactor one unit at a time Helps isolate new bugs and regressions Your check-in should contain only your refactor, not other changes 24 Barriers to Refactoring ‚ÄúI don‚Äôt have time‚Äù Refactoring incurs an up-front cost Some developers don't want to do it Most managers don't like it, because they lose time and gain ‚Äúnothing‚Äù (no new features) However ‚Ä¶ Clean code is more conducive to rapid development Estimates put return-of-investment at >500% for well-done code Finishing refactoring increases programmer morale Developers prefer working in a ‚Äúclean house‚Äù 25 Barriers to Refactoring Many small companies and startups skip refactoring ‚ÄúWe're too small to need it!‚Äù ‚ÄúWe can't afford it!‚Äù Reality: Refactoring is an investment in quality of the company's product and code base, often their prime assets Many startups are using the most cutting-edge technologies, which evolve rapidly; so should the code If a key team member leaves (common in startups) ‚Ä¶ If a new team member joins (also common) ‚Ä¶ 26 Agile Project Management The standard approach to project management is plan-driven Agile project management requires a different approach Adapted to incremental development and the practices used in agile methods 27 Scrum Scrum is an agile method that focuses on managing iterative development rather than specific agile practices Phases in Scrum: Initial phase: Outline planning Establish the general objectives for the project Design the software architecture A series of sprint cycles Each cycle develops an increment of the system Closure phase: Wraps up the project Complete required documentation Assess lessons learned from the project 28 Scrum Sprint Cycle 29 Scrum Sprint Cycle Sprints are fixed length, normally 2‚Äì4 weeks The starting point for planning is the product backlog List of work to be done on the project Selection from the product backlog of features and functionality to be developed during the sprint involves all project team who work with the customer During the sprint, the team is isolated from the customer and the organization All communications channeled through the Scrum master Protect the development team from external distractions 30 Scrum Sprint Cycle At the end of the sprint, the work done is reviewed and presented to stakeholders Scrum master is a facilitator Arranges daily meetings Tracks the backlog of work to be done Records decisions Measures progress against the backlog Communicates with customers and management outside of the team 31 Scrum Sprint Cycle The whole team attends short daily meetings (Scrums) All team members share information Their progress since the last meeting Problems that have arisen What is planned for the following day Everyone on the team knows what is going on If problems arise, can re-plan short-term work to cope with them 32 Scrum Benefits The product is broken down into a set of manageable and understandable chunks Unstable requirements do not hold up progress The whole team have visibility of everything Team communication is improved Customers see on-time delivery of increments 33 Scaling Agile Methods Agile methods have proved to be successful for small and medium sized projects that can be developed by a small co- located team Scaling up agile methods: Larger, longer projects Multiple development teams May work in different locations Important to maintain agile fundamentals Flexible planning, frequent system releases, continuous integration, test-driven development, good team communications 34 Scaling Agile Methods Agile methods are most appropriate for new software development Yet the majority of software costs in large companies come from maintaining their existing software systems Agile development is somewhat ‚Äúinformal‚Äù Incompatible with the legal approach to contract definition that is commonly used in large companies 35 Agile and Plan-driven Methods Most modern software projects include a mixture of plan-driven and agile processes Deciding on the balance depends on many factors: System issues System size, type, expected lifetime, subjection to external regulations, ‚Ä¶ People and teams Team organization, supporting tools, ‚Ä¶ Organizational issues Organization culture, customer availability, ‚Ä¶ 36 Object Oriented Programming and Design Yair Moshe Winter, 2020/1 #14: Object Oriented Design Heuristics Modular Design A module is a unit in a software system Class, ADT, package, layer, ‚Ä¶ Modular design is the heart of software design What modules What are their specifications How they interact Each module respects other modules‚Äô abstraction barriers and enforces its own 2 Ideal of Modular Software Decomposable Can be broken down into modules to reduce complexity and allow teamwork Composable Can produce software from reusable modules assembled in various combinations Understandable One module can be examined, reasoned about, and developed in isolation 3 Ideal of Modular Software Continuity A small change in the requirements should affect a small number of modules Isolation An error in one module should be as contained as possible 4 Cohesion and Coupling Cohesion ‚Äì How well parts of a component fit and work together Form something that is self-contained, independent, and with a single, well-defined purpose Coupling ‚Äì How much dependency there is between components Want to understand each component without much understanding of the others 5 General Design Goals Goals: Decrease coupling, increase cohesion 6 high coupling low cohesion low coupling high cohesion Cohesion Design objective: separation of concerns - a module should represent a single concept Each module should provide a single abstraction 7 Cohesion for Methods Methods should do one thing well Compute a value but let client decide what to do with it Observe or mutate, don‚Äôt do both Don‚Äôt print as a side effect of some other operation Having a method do multiple, not-necessarily-related things limits future possible uses ‚ÄúFlag‚Äù variables are often a symptom of poor method cohesion Often mean the method is doing multiple things 8 Cohesion for ADTs An ADT with high cohesion has a relatively small number of operations, with highly related functionality, and does not do too much work Cohesion is increased if The functionalities embedded in an ADT, accessed through its methods, have much in common Methods carry out a small number of related activities 9 Levels of Cohesion (Worst to Best) Coincidental cohesion Completely unrelated operations Example: utility class Logical cohesion A set of related operations, one of which is used by a calling module Example: A class that performs all input and output Temporal cohesion A set of operations related in time Example: updateSystemTime, refreshScreen, initAllVariables 10 Levels of Cohesion (Worst to Best) Procedural cohesion A set of operations related by the sequence of steps to be followed by the product Example: openFile, readFirstRecordFromFile, formatRecordToString, showRecordInGUI Communicational cohesion Like procedural cohesion but performed on the same data Example: readPartNumber, updatePartNumberInDatabase Functional cohesion Performs exactly one operation or achieves a single goal Example: CalculationsUpdater 11 Levels of Cohesion (Worst to Best) Informational cohesion Like functional cohesion but performed on the same data structure Example: LinkedList 12 Cohesion for ADTs Code smell: Disjoint field set A subset of methods that uses only a subset of fields Indicating those fields and methods should be moved to their own class 13 Single-Responsibility Principle Encapsulate each changeable design decision in a separate module A class should have only one reason to change The Single-Responsibility Principle offers guidance on how to decompose our program into cohesive modules Code smell: Divergent change Over time, multiple, unrelated, changes are applied to a class May suggest that the class has multiple reasons to be changed Harder to detect due to the time perspective 14 SRP Example Two reasons to change: book management, disk I/O 15 class Book { public String getTitle() { ‚Ä¶ } public String getAuthor() { ‚Ä¶ } public void turnPage() { ‚Ä¶ } public int getCurrentPage() { ‚Ä¶ } public void saveToFile(String filename) { ‚Ä¶ } } SRP Example Better: 16 class Book { public String getTitle() { ‚Ä¶ } public String getAuthor() { ‚Ä¶ } public void turnPage() { ‚Ä¶ } public int getCurrentPage() { ‚Ä¶ } } class FileIO { public FileIO(String filename) { ‚Ä¶ } public void save(Book b) { ‚Ä¶ } } Coupling How modules are dependent on one another Statically (in the code) Dynamically (at run-time) Do we need to understand one to understand the other? Coupling leads to complexity and confusion A change in one module may cause a ripple effect of changes in other modules Ideally, split design into parts that don't interact much 17 Levels of Coupling (Worst to Best) Content coupling One module directly references the contents of the other Example: A module refers to local data of another module Common coupling Two modules have access to the same global data Example: a global variable Control coupling One module explicitly controls the logic of another module Example: a control switch is passed as an argument 18 Levels of Coupling (Worst to Best) Stamp coupling A data structure is passed as an argument, but the called module operates on only some of the individual components of that data structure Example: Passing an entire employeeRecord to a module in order to compute the employee‚Äôs salary Data coupling Every argument is either a simple argument or a data structure in which all elements are used by the called module 19 Coupling An anti-pattern is a known bad way of doing things Anti-pattern: Object orgy - Failing to properly encapsulate objects permitting unrestricted access to their internals Another anti-pattern: God class 20 God Classes A god class gathers much of the data or functionality of a system Poor cohesion ‚Äì Little thought about why all the elements are placed together Reduces coupling but only by collapsing multiple modules into one Replaces dependences between modules with dependences within a module Violates the single responsibility principle 21 God Classes Be suspicious of a class whose name contains Driver, Manager, System, Subsystem Classes should not contain more objects than a developer can fit in his or her short-term memory Usually six God class example: PokerGame class that manages all the players, cards representing the card deck, all bets and money, does the logic and performs computer AI strategies 22 Law of Demeter An object should know as little as possible about the internal structure of other objects with which it interacts Information hiding No representation exposure Code smell: Inappropriate intimacy - One class uses the internal fields and methods of another class E.g., gui.getCurrentWindow().getCurrentPanel(). getFirstControl().getUserSelection(); 23 Law of Demeter An object should send messages only to the following: 1. Itself (this) 2. Its instance variables 3. Method's parameters 4. Any object it creates 5. Any object returned by a call to one of this' methods 6. Any objects in a collection of the above Notably absent: Objects returned by messages sent to other objects 24 Law of Demeter An object ‚Äútalk only to its neighbors‚Äù 25 More Classes Ideals Completeness: Should every class present a complete interface? Good advice for public libraries For other code, better to avoid unnecessary work Can leave TODOs for what you want to add later Or have methods that throw RuntimeException(‚Äúnot yet implemented‚Äù) Consistency: In names, param/returns, ordering, and behavior 26 Completeness Include important methods to make a class easy to use Counterexamples: A mutable collection with add but no remove A Tool object with a setHighlighted method to select it, but no setUnhighlighted method to deselect it Also: Objects that have a natural ordering should implement Comparable Objects that might have duplicates should implement equals (and therefore hashCode) Most objects should implement toString 27 Completeness But don‚Äôt include everything you can possibly think of If you include it, you‚Äôre stuck with it forever (even if almost nobody ever uses it) Don‚Äôt include compound operations YAGNI - You Are Not Going to Need It KISS - Keep it simple, stupid Tricky balancing act: include what‚Äôs useful, but don‚Äôt make things overly complicated You can always add it later if you really need it Except for public libraries, better to wait if you can 28 Completeness 29 Albert Einstein ‚ÄúEverything should be made as simple as possible, but not simpler.‚Äù Consistency A module should have consistent names, parameters in the same order, and consistent behavior Counterexamples: String.length(), array.length, collection.size() 30 setFirst(int index, String value) setLast(String value, int index) Open-Closed Principle Software modules should be open for extension, but closed for modification Add features by adding new classes or reusing existing ones in new ways Avoid modifying existing ones Changing existing behavior can introduce bugs Related: Refer for the most general type that provides the needed operations Code to interfaces, not to classes E.g., accept a List parameter, not ArrayList or LinkedList 31 Open-Closed Principle Example: polymorphism 32 Open-Closed Principle Code smell: Unexploited encapsulation - A switch statement that chooses which flavor of some logic to run based on the ‚Äúkind‚Äù of the object May use instanceOf or getClass() Adding a new kind requires finding all those switch statements and adding a case to each one Can be replaced by invoking a polymorphic method on that object 33 Proliferation of Classes Too many classes that are too small in size/scope Often have only data and get/set methods Or only methods, no real data Makes the system hard to use, debug, maintain Anti-pattern: Poltergeists - Objects whose sole purpose is to pass information to another object 34 Proliferation of Classes Be sure the abstractions that you model are classes and not roles objects play Is Mother or Father a class or are they the roles that certain Person objects play? Depends if they have different behavior Do not turn an operation into a class Be suspicious of any class whose name is a verb, especially those that have only one piece of meaningful behavior Be suspicious of people who say \"I need a class that does ‚Ä¶\" 35 Agent Classes Agent class is a class that acts as a middle-man to help two or more other classes communicate Example: Farmer class to link Cow and Milk classes Example: Librarian class to link Book and Shelf classes Agent classes are often placed in the analysis model of an application During design time, many agents are found to be irrelevant and should be removed What defines whether an agent is relevant? A relevant agent must have some other behavior beyond simply being a middle-man; it must have some useful purpose of its own as well 36 SOLID Design principles promoted by Robert C. Martin Single responsibility principle Open/closed principle Liskov substitution principle Interface segregation principle Dependency inversion principle 37 Interface Segregation Principle No client should be forced to depend on methods it does not use Reduces coupling Favor smaller and more specific interfaces If not, we may be forced to implement the full interface and write some dummy methods Breaks the Liskov substitution principle Called a polluted interface Anti-pattern: Interface bloat - Making an interface so powerful that it is extremely difficult to implement 38 ISP Example ‚Äì Polluted Interface 39 interface Printer { public void print(Document d); public void copy(Document d); public void fax(Document d); } class OfficeJet6978 implements Printer { // implementation of print(), copy(), fax() } class DeskJet3755 implements Printer { // implementation of print(), copy() // problem: this printer cannot fax } ISP Example ‚Äì Polluted Interface PrintManager depends on Printer but uses only PrintManager.print 40 class PrinterManager { private List<Document> documents; public void printDocuments(Printer p) { for (Document d : documents) p.print(d); } } ISP Example ‚Äì Better Solution 41 interface Printer { public void print(Document d); } interface Fax { public void fax(Document d); } interface Copier { public void copy(Document d); } interface MultiFunctionMachine extends Printer, Copier, Fax { } ISP Example ‚Äì Better Solution 42 class OfficeJet6978 implements MultiFunctionMachine { // implementation of print(), copy(), fax() } class DeskJet3755 implements Printer, Copier { // implementation of print(), copy() } Dependency Inversion Principle A na√Øve design: Implement low-level modules, then high-level modules that use them Seems natural since high-level modules are defined in terms of low-level modules Easy to write new high-level modules 43 Dependency Inversion Principle What if now we want MyApp to send e-mail notifications on some events? High-level modules use directly and depend heavily on the low-level modules Problem: Difficult to change low-level modules 44 Dependency Inversion Principle Solution: Introduce an abstraction layer between the low and high level modules 45 Dependency Inversion Principle 1. High-level modules should not depend on low-level modules. Both should depend on abstractions. 2. Abstractions should not depend on details. Details should depend on abstractions. Reduces coupling between high-level and the low-level modules 46 SOLID Design principles promoted by Robert C. Martin Single responsibility principle Open/closed principle Liskov substitution principle Interface segregation principle Dependency inversion principle 47 GRASP General responsibility assignment software patterns (or principles) stated by Craig Larman Guidelines for assigning responsibility to classes and objects in object-oriented design Responsibility is defined as Knowing ‚Äì state Doing ‚Äì sending messages, instantiating other objects Controller, creator, indirection, information expert, high cohesion, low coupling, polymorphism, protected variations, pure fabrication 48 Information Expert What is a general principle of assigning responsibilities to objects? Assign a responsibility to the information expert - the class that contains the information needed to fulfill the responsibility Keep related data and behavior in one place Only one class should be responsible for maintaining a set of data, even if that data is used by many other classes Leads to low coupling and high cohesion 49 Information Expert Example Assume we need to get all the videos of a VideoStore Since the VideoStore class knows about all the videos, we will assign this responsibility to VideoStore VideoStore is the information expert 50 Information Expert Counterexample: A class with lots of accessors, not a lot of methods that actually do work Relies on other classes to get the data and process it externally 51 Creator Who creates an object? Assign class B the responsibility to create an instance of class A if one of the following is true (the more the better): B contains or is composed of A B records A B closely uses A B has the initializing data that will be passed to A when it is created Thus, B is an information expert with respect to creating A 52 Indirection How can we avoid direct coupling between modules? Assign the responsibility to an intermediate object to mediate between other modules so that they are not directly coupled The intermediary creates the indirection Examples: Dependency inversion principle Adapter, Fa√ßade, Observer design patterns 53 Protected Variations How to design modules so that variations in these modules do not have an undesirable impact on other modules? Identify points of predicted variation and create a stable interface around them Similar to open‚Äêclosed principle or the concept of information hiding May be implemented as polymorphism or interfaces 54 Pure Fabrication What object should have the responsibility when you do not want to violate high cohesion and low coupling, but solutions offered by Expert (for example) are not appropriate? Assign a highly cohesive set of responsibilities to an artificial or convenience class that does not represent a problem domain concept A class made up to support high cohesion, low coupling, and reuse Examples: Log class responsible for logging information Adapter, Strategy design patterns 55 Object Oriented Programming and Design #15: Design Patterns Partially based on slides of Univ. of Washington CSE 331, Univ. Of Waterloo CS 247 Yair Moshe Winter, 2020/1 What is a Design Pattern? A standard solution to a common programming problem A design or implementation structure that achieves a particular purpose A high-level programming idiom A technique for making code more flexible Reduce coupling among program components Shorthand description of a software design Well-known terminology improves communication/documentation 2 Example 1: Iterator Problem: To access all members of a collection, must perform a specialized traversal for each data structure Makes clients strongly coupled to that collection Solution: The implementation performs traversals, does bookkeeping Results are communicated to clients via a standard interface (e.g., hasNext(), next()) 3 Example 2: Observer Problem: Other code needs to be called each time state changes but we would like the component to be reusable For example, in GUI Can‚Äôt hard-code calls to everything that needs to be called Solution: Object maintains a list of observers with a known interface Calls a method on each observer when state changes 4 Why Design Patterns? Intended to capture common solutions / idioms, name them, make them easy to use to guide design For high-level designs, not specific ‚Äúcoding tricks‚Äù They increase your vocabulary and your intellectual toolset 5 Why (Not) Design Patterns? Introducing new abstractions to your program has a cost It makes the code more complicated It takes time Do not overuse them Consider them to solve reuse/modularity problems that arise as your program evolves 6 Origin of Design Patterns The ‚ÄúGang of Four‚Äù (GoF) Gamma, Helm, Johnson, Vlissides 7 Design Patterns Categories Creational Patterns are about the object creation process Factory Method, Abstract Factory, Singleton, Builder, Prototype, ‚Ä¶ Structural Patterns are about how objects/classes can be combined Adapter, Bridge, Composite, Decorator, Fa√ßade, Flyweight, Proxy, ‚Ä¶ Behavioral Patterns are about communication among objects Command, Interpreter, Iterator, Mediator, Observer, State, Strategy, Chain of Responsibility, Visitor, Template Method, Memento, ‚Ä¶ 8 Describing a Design Pattern A pattern has a recognized name Why might you want this? What design goals are achieved? How might you achieve this? How to leverage language constructs to enforce the design 9 Design Patterns Categories Creational Patterns are about the object creation process Factory Method, Abstract Factory, Singleton, Builder, Prototype, ‚Ä¶ Structural Patterns are about how objects/classes can be combined Adapter, Bridge, Composite, Decorator, Fa√ßade, Flyweight, Proxy, ‚Ä¶ Behavioral Patterns are about communication among objects Command, Interpreter, Iterator, Mediator, Observer, State, Strategy, Chain of Responsibility, Visitor, Template Method, Memento, ‚Ä¶ 10 Creational Patterns Constructors are inflexible 1. Can't create a subtype of the class they belong to 2. Can‚Äôt reuse an existing object Patterns for how to create new objects Factory Method, Abstract Factory, Builder, Prototype, ‚Ä¶ Patterns for reusing objects Singleton, ‚Ä¶ 11 Singleton For some class C, guarantee that at run-time there is exactly one (globally visible) instance of C E.g., RandomNumberGenerator, KeyboardReader, PrinterController, FileSystem An object with fields / methods ‚Äúlike public static fields / methods‚Äù but a constructor decide their values E.g., have main create KeyboardReader but rest of the code can just assume it exists 12 Singleton vs Static Methods Why not use a class with static methods? No state Cannot pass it to a method Cannot use inheritance, implement an interface, use polymorphism Cannot delay instantiation or specify creation logic 13 class Screen { public static void printMessage(String message) { ‚Ä¶ } public static void changeColor(Color c) { ‚Ä¶ } } Singleton Implementation Restrict the instantiation of a class to one object Prevent clients from explicitly creating instances of the class The class controls its instantiation Enforce this by hiding the constructors of the class Keep the constructors private / protected Add a private static member that refers to the sole instance of the class Define a public static operation that returns the sole instance of the class 14 Singleton: Eager Initialization 15 class Screen { private final static Screen instance = new Screen(); private Screen() { ‚Ä¶ } public static Screen getInstance() { return instance; } public void printMessage(String message) { ‚Ä¶ } public void changeColor(Color c) { ‚Ä¶ } } Using Singleton 16 Screen s = Screen.getInstance(); s.changeColor(Color.BLUE); s.printMessage(‚ÄúHello Singleton‚Äú); Singleton: Lazy Initialization 17 class Screen { private static Screen instance; private Screen() { ‚Ä¶ } public static Screen getInstance() { if (instance == null) instance = new Screen(); return instance; } public void printMessage(String message) { ‚Ä¶ } public void changeColor(Color c) { ‚Ä¶ } } Eager vs. Lazy Initialization Eager initialization The instance is created during class loading in the JVM Object might be loaded even if it is not used Can‚Äôt pass parameters Lazy initialization The instance is created when the static method is first invoked 18 Singleton Constructor Making the constructors private or protected prevents clients from creating instances of the class private constructor Prohibit inheritance protected constructor Allow inheritance but descendant classes and classes in the same package can make instances of the class May break the Singleton by creating more than one instance 19 Singleton Drawbacks Provide global access to the instance Essentially a global variable But does not pollute the global namespace and permits lazy initialization Hide dependencies Not possible to call constructor directly so may have to call an init method Singleton lifecycle is global Opposes the principle that entities should exist in the smallest possible context 20 Singleton Drawbacks Violate the single responsibility principle Singletons control their own creation and lifecycle Promote tight coupling Couple clients to the exact type of the singleton object Singleton is one of the simplest designer patterns As such, it is very popular It is commonly misused as way to wrap global variables Considered an anti-pattern 21 Motivation for Factories Clients use the supertype (Matrix) but still call SparseMatrix or DenseMatrix constructor Must decide concrete implementation somewhere Might want to make the decision in one place Don‚Äôt want to change code to use a different constructor Factory methods put this decision behind an abstraction 22 interface Matrix { ‚Ä¶ } class SparseMatrix implements Matrix { ‚Ä¶ } class DenseMatrix implements Matrix { ‚Ä¶ } Factory Method Now clients call createMatrix instead of a particular constructor createMatrix might take some parameters or do some computations to decide what kind of matrix to make Advantage: To switch the implementation, change only one place 23 class MatrixFactory { public static Matrix createMatrix() { return new SparseMatrix(); } } Factory Method 24 Example: Bicycle Race Suppose there are different types of races Each race needs its own type of bicycle 25 class Race { public Race() { Bicycle bike1 = new Bicycle(); Bicycle bike2 = new Bicycle(); ‚Ä¶ } ‚Ä¶ } Example: Bicycle Race 26 class TourDeFrance extends Race { public TourDeFrance() { Bicycle bike1 = new RoadBicycle(); Bicycle bike2 = new RoadBicycle(); ‚Ä¶ } ‚Ä¶ } Example: Bicycle Race Problem: Have to reimplement the constructor in every Race subclass just to use a different subclass of Bicycle 27 class Cyclocross extends Race { public Cyclocross() { Bicycle bike1 = new MountainBicycle(); Bicycle bike2 = new MountainBicycle(); ‚Ä¶ } ‚Ä¶ } Example: Bicycle Race Solution: Use a factory method to avoid dependence on specific new kind of bicycle in the constructor Let the subclass decide by overriding createBicycle 28 class Race { public Bicycle createBicycle() { return new Bicycle(); } public Race() { Bicycle bike1 = createBicycle(); Bicycle bike2 = createBicycle(); ‚Ä¶ } ‚Ä¶ } Example: Bicycle Race 29 class TourDeFrance extends Race { public Bicycle createBicycle() { return new RoadBicycle(); } } class Cyclocross extends Race { public Bicycle createBicycle() { return new MountainBicycle(); } } Factory Method 30 A More Modular Factory A more modular solution will separate object creation and its configuration The location of configuration is often different than that of instantiation We will favor composition over inheritance 31 Abstract Factory Let‚Äôs move the factory method into a separate class so it‚Äôs part of a factory object Factory objects encapsulate factory method(s) Advantages: No risks of calling a subclass method from a constructor Can group related factory methods together repairBicycle, createSpareWheel, ‚Ä¶ Can pass factories around at runtime Choose a factory at runtime Use different factories in different objects (e.g., races) 32 Abstract Factory 33 class BicycleFactory { public Bicycle createBicycle() { return new Bicycle(); } } class RoadBicycleFactory extends BicycleFactory { public Bicycle createBicycle() { return new RoadBicycle(); } } class MountainBicycleFactory extends BicycleFactory { public Bicycle createBicycle() { return new MountainBicycle(); } } Using Abstract Factory 34 class Race { private BicycleFactory bfactory; public Race(BicycleFactory bfactory) { this.bfactory = bfactory; Bicycle bike1 = bfactory.createBicycle(); Bicycle bike2 = bfactory.createBicycle(); ‚Ä¶ } public Race() { this(new BicycleFactory()); } ‚Ä¶ } Using Abstract Factory 35 class TourDeFrance extends Race { public TourDeFrance() { super(new RoadBicycleFactory()); } } class Cyclocross extends Race { public Cyclocross() { super(new MountainBicycleFactory()); } } Abstract Factory for Object Families Abstract Factory provides an interface for creating families of related objects without specifying concrete classes Can enforce that a family of related product objects should be used together 36 Abstract Factory 37 Prototype Pattern Every object is itself a factory Each class contains a clone method that creates a copy of the object Avoid the cost of creating a new object using the new keyword Useful for objects that are created via a process Example: java.awt.geom.AffineTransform Create by a sequence of calls to translate, scale, and rotate Easiest to make a similar one by copying and changing 38 Prototype Pattern Example CodeSnippet is the Prototype Subtypes will implement the clone method to produce new objects clone is a Factory Method that returns a copy of this 39 interface CodeSnippet { public CodeSnippet clone(); public String getName(); public void execute(); } Prototype Pattern Example 40 class BetaCode implements CodeSnippet { private String name = \"BetaVersion\"; public CodeSnippet clone() { return new BetaCode(); } public String getName() { return name; } public void execute() { System.out.println(name + \": does something\"); } } Prototype Pattern Example 41 class ReleaseCode implements CodeSnippet { private String name = ‚ÄúReleaseCandidate\"; public CodeSnippet clone() { return new ReleaseCode(); } public String getName() { return name; } public void execute() { System.out.println(name + \": does real work\"); } } Prototype Pattern Example 42 class Software { private static List<CodeSnippet> snippets = new ArrayList<>(); public static void addSnippet(CodeSnippet p) { snippets.add(p); } public static CodeSnippet createSnippet(String name) { for (CodeSnippet s : snippets) { if (s.getName().equals(name)) return (CodeSnippet)s.clone(); } throw new IllegalArgumentException(name + \": doesn't exist\"); } } Prototype Pattern Example Software is a ‚Äúregistry‚Äù that maintains a cache of prototypical objects Should be first populated with prototype objects Then client uses createSnippet instead of the new operator 43 Prototype Pattern Example 44 public class PrototypeTest { public static void main(String[] args) { if (args.length == 0) throw new IllegalArgumentException( \"Run again with arguments of command string.\"); // initialize Software.addSnippet(new BetaCode()); Software.addSnippet(new ReleaseCode()); // add code snippets by cloning and execute them List<CodeSnippet> software = new ArrayList<>(); for (String codeName : args) software.add(Software.createSnippet(codeName)); for (CodeSnippet code : software) code.execute(); } } Creational Patterns Wrap-up Factory Method Call a method to create the object Method can do any computation and return any subtype Abstract Factory Bundles factory methods in a separate object Can create families of related objects Prototype Every object is a factory, can create more objects like itself Call clone to get a new object of same subtype as receiver 45 Creational Patterns Wrap-up Often designs start out using Factory Method and evolve toward Abstract Factory, Prototype or Builder Factory Method is simpler Evolves as the designer discovers where more flexibility is needed 46 Design Patterns Categories Creational Patterns are about the object creation process Factory Method, Abstract Factory, Singleton, Builder, Prototype, ‚Ä¶ Structural Patterns are about how objects/classes can be combined Adapter, Bridge, Composite, Decorator, Fa√ßade, Flyweight, Proxy, ‚Ä¶ Behavioral Patterns are about communication among objects Command, Interpreter, Iterator, Mediator, Observer, State, Strategy, Chain of Responsibility, Visitor, Template Method, Memento, ‚Ä¶ 47 Structural Patterns: Wrappers Wrappers are a thin layer over an encapsulated object that may Modify the interface Extend behavior Restrict access Wrappers can serve as an alternative to subtyping Terminology: Also called composition or delegation The wrapped or encapsulated object is called the delegate 48 Structural Patterns: Wrappers Wrapper can change the interface or functionality of the encapsulated object The encapsulated object does most of the work 49 Pattern Functionality Interface (from client perspective) Adapter same different Decorator different same Proxy same same Adapter Design Pattern Real life example: Adapter to go from Israeli to US power plugs Both interfaces do the same thing But they have slightly different interface expectations And in software: Translate between incompatible interfaces 50 Adapter Design Pattern Change an interface without changing functionality Rename a method Convert units Implement a method in terms of another Example: Angles passed in radians vs. degrees Example: Use ‚Äúold‚Äù method names for legacy code 51 Adapter Example: Rectangles Our code is using this Rectangle interface: But we want to use a library that has this class: 52 interface Rectangle { // grow or shrink this by the given factor public void scale(float factor); // move to the left or right public void translate(float x, float y); } class JRectangle { public void scaleWidth(float factor) { ‚Ä¶ } public void scaleHeight(float factor) { ‚Ä¶ } public void shift(float y, float x) { ‚Ä¶ } } Adapter Example: Rectangles Create an adapter that delegates to JRectangle: 53 class RectangleAdapter implements Rectangle { private JRectangle rect; public RectangleAdapter(JRectangle rect) { this.rect = rect; } public void scale(float factor) { rect.scaleWidth(factor); rect.scaleHeight(factor); } public void translate(float x, float y) { rect.shift(y, x); } ‚Ä¶ } Object Adapter Design Pattern 54 Adapter Design Pattern This sort of thing happens a lot An \"off the shelf\" component offers compelling functionality that you would like to reuse but its interface is not compatible Unless two libraries were designed to work together, they probably won‚Äôt fit together without an adapter 55 Adapter Example: Rectangles Instead of delegation, we can also subclass from JRectangle: 56 class RectangleAdapter extends JRectangle implements Rectangle { public void scale(float factor) { scaleWidth(factor); scaleHeight(factor); } public void translate(float x, float y) { shift(y, x); } ‚Ä¶ } Class Adapter Design Pattern 57 Adapter: Delegation vs. Subclassing Subclassing Automatically gives access to all methods of superclass Shorter syntax Cannot adapt an interface Cannot adapt subtypes of the adaptee Delegation Permit ‚Äúremoval‚Äù of methods Can adapt any subtype of the adaptee Multiple wrappers can be composed 58 Quiz: Design Patterns ◊ë ◊©◊ï◊û◊ô◊©-Kahoot ◊®◊™◊ê◊ú ◊ï◊©◊ú◊íkahoot.it ◊™◊ô◊ô◊¶◊ß◊ô◊ú◊§◊ê◊ë ◊ï◊©◊û◊™◊©◊î ◊ï◊êKahoot! ◊î ◊®◊§◊°◊û ◊™◊ê ◊ï◊©◊ô◊ß◊î-PIN◊ù◊õ◊™◊ê ◊£◊™◊©◊û ◊ô◊†◊ê◊© ◊ö◊°◊û◊î ◊ú◊¢ ◊ù◊ô◊ê◊ï◊® ◊ù◊™◊ê◊© ◊ù◊© ◊©◊ô◊ß◊î◊ú ◊ù◊ô◊©◊ß◊ë◊™◊û ◊ù◊™◊ê◊©◊õ , ◊™◊ê ◊ï◊©◊ô◊ß◊î◊ù◊õ◊ú◊© ◊™◊ï◊î◊ñ◊î ◊™◊ì◊ï◊¢◊™ ◊®◊§◊°◊û ◊î◊§ ◊ù◊™◊ê◊© ◊¢◊ì◊ê ◊ô◊†◊ê ◊î◊õ◊õ 59 Decorator Design Pattern Add functionality without changing the interface: 1. Add to existing methods to do something additional Satisfying a stronger specification 2. Provide extra methods Actually, every true subtype does this In this design pattern we create decoration using delegation An alternative to Java subtyping 60 Decorator Design Pattern Allows behavior to be added to an individual object Either statically or dynamically Multiple decorators can be stacked on top of each other, each one adding a new functionality Important when there are several independent ways of extending functionality Allows combinations of extensions 61 Decorator Pattern Example 62 interface Window { // returns a rectangle bounding the window public Rectangle bounds(); // draw this on the specified screen public void draw(Screen s); ‚Ä¶ } class SimpleWindow implements Window { ‚Ä¶ } Decorator Pattern Example 63 abstract class WindowDecorator implements Window { private Window window; // the window being decorated public WindowDecorator(Window window) { this.window = window; } public Rectangle bounds() { ‚Ä¶ } public void draw(Screen s) { window.draw(s); // delegation } } Decorator Pattern Example 64 class BorderedWindow extends WindowDecorator { public BorderedWindow(Window window) { super(window); } public void draw(Screen s) { super.draw(s); // draw window border } } Decorator Pattern Example 65 class WindowWithScrollbars extends WindowDecorator { public WindowWithScrollbars(Window window) { super(window); } public void draw(Screen s) { super.draw(s); // draw scrollbars } } Decorator Pattern Example 66 // create a window with scrollbars and border Window w = new WindowWithScrollbars(new BorderderWindow(new SimpleWindow())); // draw window on screen w.draw(); Decorator Design Pattern 67 Decorator for Java I/O InputStreamReader class can only read one letter at a time BufferedReader adds additional functionality to read the stream more easily 68 BufferedReader br = new BufferedReader( new InputStreamReader(new FileInputStream(\"oopd.txt\"))); String line = br.readLine(); Decorator Design Pattern A decorator can also remove functionality without changing method signatures It does change the spec though Example: UnmodifiableList Methods like add and put throw an exception Problem: UnmodifiableList is a Java subtype, but not a true subtype of List 69 Proxy Design Pattern Same interface and functionality as the wrapped class Control access to another object Communication: manage network details when using a remote object Locking: serialize access by multiple clients Security: permit access only if proper credentials Creation: object might not yet exist (creation is expensive) Hide latency when creating object Avoid work if object is never used 70 Proxy Pattern Example 71 interface Car { public void driveTo(Point location); } class PrivateCar implements Car { public void driveTo(Point location) { ‚Ä¶ } } Proxy Pattern Example 72 class RentedCar implements Car { private Driver driver; private Car car = new PrivateCar(); public RentedCar(Driver driver) { this.driver = driver; } public void driveTo(Point location) { if (driver.getAge() <= 16) // driver is too young to drive else car.driveTo(location); } } Proxy Pattern Example 73 Car car = new RentedCar(new Driver(16)); car.driveTo(new Point(5,5)); car = new RentedCar(new Driver(25)); car.driveTo(new Point(10,10)); Proxy Design Pattern 74 Facade Design Pattern Provides a simplified interfaced to a complex system Make a module easier to use Decouples clients from the inner workings of a module A wrapper class that contains a set of members required by the client Members access the system on behalf of the client and hide the implementation details Note that it does not prevent sophisticated clients form accessing the underlying classes 75 Facade Design Pattern 76 Composite Design Pattern Permits a client to manipulate either an atomic unit or a collection of units in the same way No need to know if an object is a collection of smaller objects or not Let clients treat individual objects and compositions uniformly Good for dealing with ‚Äúpart-whole‚Äù relationships 77 Composite Design Pattern An object that can be either an individual atomic item or a hierarchical collection of many items Can be composed of individual items or other composites Recursive definition: objects that can hold themselves Often leads to a tree structure of leaves and nodes 78 Composite in Swing 79 JPanel north = new JPanel(new FlowLayout()); north.add(new JButton(\"Button 1\")); north.add(new JButton(\"Button 2\")); JPanel south = new JPanel(new BorderLayout()); south.add(new JLabel(\"Label 1\"), BorderLayout.WEST); south.add(new JLabel(\"Label 2\"), BorderLayout.EAST); JPanel overall = new JPanel(new BorderLayout()); overall.add(north, BorderLayout.NORTH); overall.add(new JButton(\"Button 3\"), BorderLayout.CENTER); overall.add(south, BorderLayout.SOUTH); JFrame frame = new JFrame(\"Composite Example\"); frame.getContentPane().add(overall); frame.pack(); frame.setVisible(true); Composite Pattern Example 80 abstract class IOEntity { private String name; public IOEntity(String name) { this.name = name; } public String getName() { return name; } public abstract void ls(); public abstract void add(IOEntity entity); public abstract void remove(IOEntity entity); public abstract IOEntity getChild(int index); } Composite Pattern Example 81 class File extends IOEntity { public File(String name) { super(name); } public void ls() { System.out.println(getName()); } public void add(IOEntity entity) { throw new UnsupportedOperationException(); } public void remove(IOEntity entity) { throw new UnsupportedOperationException(); } public IOEntity getChild(int index) { throw new UnsupportedOperationException(); } } Composite Pattern Example 82 class Directory extends IOEntity { private List<IOEntity> files = new ArrayList<>(); public Directory(String name) { super(name); } public void ls() { System.out.println(getName() + \":\"); for (IOEntity file : files) file.ls(); System.out.println(\"---\"); } public void add(IOEntity entity) { files.add(entity); } Composite Pattern Example 83 public void remove(IOEntity entity) { files.remove(entity); } public IOEntity getChild(int index) { return files.get(index); } } Composite Pattern Example 84 Directory root = new Directory(\"My Documents\"); Directory pictures = new Directory(\"My Pictures\"); pictures.add(new File(‚ÄúSelfie\")); pictures.add(new File(‚ÄúFamily\")); Directory videos = new Directory(\"My Videos\"); videos.add(new File(‚ÄúCute Cats\")); videos.add(new File(‚ÄúDespacito\")); root.add(pictures); root.add(videos); root.ls(); Composite Design Pattern 85 Composite Transparency vs. Safety Where should the child management methods be declared? In the Component class: + All components can be treated the same - Polluted interface: These methods are meaningless for leafs In the Composite class: + No polluted interface - Leafs and composites have different interfaces 86 Composite Implementation Should components maintain a reference to their parent component? Is child ordering important? What‚Äôs the best data structure to store components? Who should delete components? Not a problem in Java due to garbage collector The answers to the above questions depend on the application 87 Design Patterns Categories Creational Patterns are about the object creation process Factory Method, Abstract Factory, Singleton, Builder, Prototype, ‚Ä¶ Structural Patterns are about how objects/classes can be combined Adapter, Bridge, Composite, Decorator, Fa√ßade, Flyweight, Proxy, ‚Ä¶ Behavioral Patterns are about communication among objects Command, Interpreter, Iterator, Mediator, Observer, State, Strategy, Chain of Responsibility, Visitor, Template Method, Memento, ‚Ä¶ 88 Observer Design Pattern Example: A program to display information about stocks Stock tickers Spreadsheets Graphs Na√Øve design: polling Make a class to represent stock information Continuously asking this class for changes Problem #1: Unnecessary high system load Problem #2: Not knowing about changes immediately 89 Another Na√Øve Design 90 class Stocks { private Ticker ticker; private Spreadsheet spreadsheet; private Graph graph; private void updateViewers() { ticker.update(newPrice); spreadsheet.update(newPrice); graph.update(newPrice); } ‚Ä¶ } Problem: To add/change a viewer, must change Stocks Add a member for the viewer and edit updateViewers Observer Design Pattern 91 interface PriceObserver { public void update(PriceInfo pi); } class Ticker implements PriceObserver { public void update(PriceInfo pi) { ‚Ä¶ } ‚Ä¶ } class Spreadsheet implements PriceObserver { public void update(PriceInfo pi) { ‚Ä¶ } ‚Ä¶ } class Graph implements PriceObserver { public void update(PriceInfo pi) { ‚Ä¶ } ‚Ä¶ } Observer Design Pattern 92 class Stocks { private List<PriceObserver> observers; public void addObserver(PriceObserver observer) { observers.add(observer); } public void removeObserver(PriceObserver observer) { observers.remove(observer); } public void notifyObserver(PriceInfo i) { for (PriceObserver observer : observers) observer.update(i); } ‚Ä¶ } Observer Design Pattern Stocks not responsible for viewer creation Main passes viewers to Stocks as observers Stocks keeps list of PriceObservers, notifies them of changes 93 Observer Design Pattern 94 Ticker ticker = new Ticker(); Graph graph1 = new Graph(); Graph graph2 = new Graph(); // register observers stocks.addObserver(ticker); stocks.addObserver(graph1); stocks.addObserver(graph2); // setting stock prices will call notifyObserves and update all current // observers stocks.setStockPrices(newPrices1); // after deregistering graph2, two observes are updated stocks.removeObserver(graph2); stocks.setStockPrices(newPrices2); Observer Design Pattern 95 Push vs. Pull The example we‚Äôve just seen implements push model update method pushes information to viewers Issue: update method must pass enough information to (unknown) viewers A pull model: Give viewers access to Stocks, let them extract the data they need Push versus pull efficiency can depend on frequency of operations Also, possible to use both patterns simultaneously 96 Event-driven Programming Many applications are event-driven programs Program initializes itself, then enters an event loop Used in many software libraries For example, in almost all GUI systems Observer design pattern enables event-driven software 97 Observer Pitfalls Can cause memory leaks because it requires both explicit registration and explicit deregistration Subject holds references to the observers, keeping them alive Frequent updates may be inefficient Solution: Observer can be made responsible for starting the notify operation when it considers necessary 98 Quiz: Design Patterns ◊ë ◊©◊ï◊û◊ô◊©-Kahoot ◊®◊™◊ê◊ú ◊ï◊©◊ú◊íkahoot.it ◊™◊ô◊ô◊¶◊ß◊ô◊ú◊§◊ê◊ë ◊ï◊©◊û◊™◊©◊î ◊ï◊êKahoot! ◊î ◊®◊§◊°◊û ◊™◊ê ◊ï◊©◊ô◊ß◊î-PIN◊ù◊õ◊™◊ê ◊£◊™◊©◊û ◊ô◊†◊ê◊© ◊ö◊°◊û◊î ◊ú◊¢ ◊ù◊ô◊ê◊ï◊® ◊ù◊™◊ê◊© ◊ù◊© ◊©◊ô◊ß◊î◊ú ◊ù◊ô◊©◊ß◊ë◊™◊û ◊ù◊™◊ê◊©◊õ , ◊™◊ê ◊ï◊©◊ô◊ß◊î◊ù◊õ◊ú◊© ◊™◊ï◊î◊ñ◊î ◊™◊ì◊ï◊¢◊™ ◊®◊§◊°◊û ◊î◊§ ◊ù◊™◊ê◊© ◊¢◊ì◊ê ◊ô◊†◊ê ◊î◊õ◊õ 99 Chain of Responsibility Pattern Define a chain of receiver objects Each object either handle a request or forward it to the next receiver on the chain Handling or forwarding decision may depend on run-time conditions Client does not have to know which object handles the request Sender is decoupled from a particular receiver Number and type of receiver objects isn't known a priori and can be set dynamically Example: Exception handling 100 Chain of Responsibility Example 101 abstract class PurchasePower { private PurchasePower successor; public PurchasePower getSuccesor() { return successor; } public void setSuccessor(PurchasePower successor) { this.successor = successor; } public abstract void processRequest(PurchaseRequest request); } Chain of Responsibility Example 102 class ManagerPPower extends PurchasePower { public void processRequest(PurchaseRequest request) { if (request.getAmount() < MANAGER_ALLOWABLE) // approve request else if (getSuccesor() != null) getSuccesor().processRequest(request); } } class DirectorPPower extends PurchasePower { public void processRequest(PurchaseRequest request) { if (request.getAmount() < DIRECTOR_ALLOWABLE) // do some stuff and approve request else if (getSuccesor() != null) getSuccesor().processRequest(request); } } Chain of Responsibility Example Should make sure that every request is handled somewhere One solution: Checking at the end of the chain that the request has been handled at least once 103 class PresidentPPower extends PurchasePower { public void processRequest(PurchaseRequest request) { if (request.getAmount() < PRESIDENT_ALLOWABLE) // do even some more stuff and approve request else if (getSuccesor() != null) getSuccesor().processRequest(request); } } Chain of Responsibility Example 104 ManagerPPower manager = new ManagerPPower(); DirectorPPower director = new DirectorPPower(); PresidentPPower president = new PresidentPPower(); manager.setSuccessor(director); director.setSuccessor(president); manager.processRequest(new PurchaseRequest(50000, \"Supplies\")); Chain of Responsibility Pattern 105 Strategy Design Pattern Problem: We want to generalize behavior of one part of our app Example: Layout of components within containers Example: Ways of sorting to arrange data Example: Computer game player AI algorithms 106 Na√Øve Solutions Boolean flags or many set methods to enable various algorithms Lots of if statements to choose between algorithms Copy-paste entire classes just to change the algorithm EasyPlayer, HardPlayer 107 game.playerDifficulty(3); if (abc) mergeSort(data); else if (xyz) bubbleSort(data); Strategy Design Pattern An algorithm separated from the object that uses it, and encapsulated as its own object Each strategy implements one specific behavior One implementation of how to solve the same problem Defines a family of algorithms Separates algorithm for behavior from clients that use it Can interchange algorithm at run-time Delegates behavior instead of inheriting it Adheres to the open/closed principle 108 Strategy Pattern Example 109 interface BillingPolicy { public double getPrice(double rawPrice); } class NormalBilling implements BillingPolicy { public double getPrice(double rawPrice) { return rawPrice; } } class HappyHour implements BillingPolicy { public double getPrice(double rawPrice) { return 0.5*rawPrice; } } Strategy Pattern Example 110 class Customer { private List<Double> drinks = new ArrayList<>(); private BillingPolicy policy; public Customer(BillingPolicy policy) { this.policy = policy; } public void setPolicy(BillingPolicy policy) { this.policy = policy; } public void add(double price, int quantity) { drinks.add(policy.getPrice(price*quantity)); } ‚Ä¶ } Strategy Pattern Example 111 Customer customer = new Customer(new NormalBilling()); // normal billing customer.add(1.0, 1); // start happy hour customer.setPolicy(new HappyHour()); customer.add(1.0, 2); customer.pay(); // end happy hour customer.setPolicy(new NormalBilling()); customer.add(2.5, 1); customer.pay(); Strategy Design Pattern 112 Strategy Considerations Context object can implement a default algorithm implementation At runtime, if no strategy object, run the default code Allows optional customization points Main drawback of this pattern: Client must understand how the strategies differ Clients get exposed to implementation issues 113 Template Method Design Pattern Problem: Some classes have a similar algorithm, but it is a little different for each class Solution: Define the skeleton of an algorithm as a method in a superclass, deferring some steps to subclasses A template method: Contains parts of the overall algorithm which are invariant For variant parts, calls abstract methods Each abstract method is a primitive operation Subclasses provide concrete implementations of abstract methods 114 Template Method Design Pattern Template Method separates the invariant part of an algorithm from the parts that vary with each subclass Same steps every time but the details of some steps depend on which subclass was instantiated Implements the dependency inversion principle Instead of calling the methods from superclass in the subclasses, the methods from subclass are called in the template method from superclass 115 Template Method Example 116 abstract class OrderProcess { public abstract void select(); public abstract void payment(); public void giftWrap() { System.out.println(\"Gift wrap.\"); } public abstract void delivery(); public void process(boolean isGift) { select(); payment(); if (isGift) giftWrap(); delivery(); } } Template Method Example 117 class NetOrder extends OrderProcess { public void select() { System.out.println(\"Item added to online shopping cart.\"); } public void payment() { System.out.println(\"Online Payment through credit card.\"); } public void delivery() { System.out.println( \"Ship the item through post to delivery address.\"); } } Template Method Example 118 class StoreOrder extends OrderProcess { public void select() { System.out.println(\"Customer chooses the item from shelf.\"); } public void payment() { System.out.println( \"Payment at counter through cash or credit card.\"); } public void delivery() { System.out.println(\"Item delivered in delivery counter.\"); } } Template Method Example 119 OrderProcess netOrder = new NetOrder(); netOrder.process(true); OrderProcess storeOrder = new StoreOrder(); storeOrder.process(true); Template Method Design Pattern 120 Template Method Considerations Template Method can use hook operations Provide default behavior that subclasses can extend if necessary Often does nothing by default Must clarify which operations may be overridden (hooks) and which must be overridden Better to minimize the number of primitive operations Keeps things simple and easier to implement 121 Iterator Design Pattern A container should allow a way to traverse its elements Without exposing its internal structure Should allow different traversal methods We do not want to add all these methods to the interface for the container 122 Iterator Design Pattern Take the responsibility for traversal out of the collection and put it into a separate Iterator object Provides a way to access the elements of a container in sequential manner without exposing its underlying representation Keeps track of the current object in the container and can compute the succeeding object in the traversal Provides a uniform interface for traversing the container is different ways This is very commonly used design pattern We have been using it quite a lot 123 Iterator Design Pattern 124 interface Iterator { // returns true iff the iteration has more elements public boolean hasNext(); // returns the next element in the iteration public Object next(); } interface Container { public Iterator getIterator(); ‚Ä¶ } Iterator Design Pattern 125 class NameRepository implements Container { private String names[] = { \"Robert\", \"John\", \"Julie\", \"Lora\" }; public Iterator getIterator() { return new NameIterator(); } private class NameIterator implements Iterator { private int index; public boolean hasNext() { if (index < names.length) return true; return false; } Iterator Design Pattern 126 public Object next() { if (this.hasNext()) return names[index++]; return null; } } ‚Ä¶ } Iterator Design Pattern 127 Java Collections Iterator Java collections framework uses iterators Uses generics ListIterator extends Iterator and adds methods like nextIndex(), previous(), previousIndex() and hasPrevious() 128 Java Collections Iterator remove() may cause representation exposure default implementation throws an UnsupportedOperationException129 interface Iterator<E> { // returns true iff the iteration has more elements public boolean hasNext(); // returns the next element in the iteration public E next(); // removes from the underlying collection the last element returned // by this iterator (optional operation) public default void remove(); } Java Collections Iterator 130 interface Iterable<T> { public Iterator<T> iterator(); } interface Collection<E> extends Iterable<E> { ‚Ä¶ } Java Collections Iterator Classes implementing the Iterable interface can be traversed using a foreach loop 131 Set<String> products = new HashSet<>( Arrays.asList(\"Bread\", \"Eggs\", \"Milk\", \"Tomatoes\")); // first way to use a Java iterator Iterator<String> iter = products.iterator(); while (iter.hasNext()) System.out.println(iter.next()); // second way to use a Java iterator: using a foreach loop for (String p : products) System.out.println(p); Creational Design Patterns 132 Singleton Ensure a class has only one instance and provide a global point of access to it. Factory Method Define an interface for creating a single object, but let subclasses decide which class to instantiate. Let a class defer instantiation to subclasses. Abstract Factory Provide an interface for creating families of related or dependent objects without specifying their concrete classes. Prototype Specify the kinds of objects to create using a prototypical instance and create new objects from the skeleton of an existing object, thus boosting performance and keeping memory footprints to a minimum. Structural Design Patterns 133 Adapter Convert the interface of a class into another interface clients expect. Let classes work together that could not otherwise because of incompatible interfaces. Decorator Attach additional responsibilities to an object dynamically keeping the same interface. Provide a flexible alternative to subclassing for extending functionality. Proxy Provide a placeholder for another object to control access to it. Facade Provide a unified interface to a set of interfaces in a subsystem. Defines a higher-level interface that makes the subsystem easier to use. Composite Compose objects into tree structures to represent part-whole hierarchies. Let clients treat individual objects and compositions of objects uniformly. Behavioral Design Patterns 134 Observer Define a one-to-many dependency between objects where a state change in one object results in all its dependents being notified and updated automatically. Chain of Responsibility Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. Strategy Define a family of algorithms, encapsulate each one, and make them interchangeable. Let the algorithm vary independently from clients that use it. Template Method Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Let subclasses redefine certain steps of an algorithm without changing the algorithm's structure. Iterator Provide a way to access the elements of a collection object sequentially without exposing its underlying representation. Design Patterns Advice Worry about dependencies They make code hard to change But also worry about simplicity Don‚Äôt introduce lots of new concepts and abstractions in order to fix what is not really a problem 135 Object Oriented Programming and Design #15: Software Architecture Patterns Yair Moshe Winter, 2020/1 Partially based on slides of Software Engineering 10th ed. by Ian Sommerville Software Architecture Patterns Software architecture refers to the high-level structure of a software system Common architectures have well-known names and well-known advantages/disadvantages Architectural patterns / styles Similar to design patterns but have a broader scope 2 Software Architecture Have one at early stage! Refactoring the system architecture is usually expensive Should be at relatively high level of abstraction Strive for simplicity Reusable components should be a design goal 3 Architectural Patterns Model-View-Controller (MVC) Layered Repository Client-server Pipe and filter 4 Model-View-Controller Architecture Used when there are multiple ways to view and interact with data Separates presentation and interaction from the data Allows the data to change independently of its representation and vice versa Supports presentation of the same data in different ways Commonly used for graphical user interfaces (GUIs) 5 Model-View-Controller Architecture Three logical components: Model - Manages system data and associated operations on that data View - Manages how the data is presented to the user Tabular view, chart, etc. Multiple views of the same data are possible Controller - Manages user interaction Accepts input and converts it to command to the model or view Key presses, mouse clicks, etc. 6 MVC Example 7 Layered Architecture Organizes the system into a set of layers Each layer provides a set of services to the layer above it Supports the incremental development of sub-systems in different layers Allows replacement of entire layers as the interface is maintained When a layer interface changes, only the adjacent layer is affected 8 Layered Architecture Example 9 Repository Architecture Shared data is held in a central repository and may be accessed by all components Components do not interact directly, only through repository An efficient data sharing mechanism 10 Repository Architecture Advantages Components do not need to know of the existence of other components Changes made by one component can be propagated to all components All data can be managed consistently Disadvantages Single point of failure May be inefficient to perform all communication through the repository Distributing the repository across several computers may be difficult 11 Repository Architecture Example 12 Client-Server Architecture Distributed system model which shows how data and processing is distributed across a range of components Can be implemented on a single computer Components: Set of servers Provide specific services such as printing, data management, etc. Set of clients Call on these services Network Allows clients to access servers 13 Client-Server Architecture Advantages Servers can be distributed across a network Disadvantages Each service is a single point of failure Susceptible to denial-of-service attacks or server failure Performance may be unpredictable Depends on the network as well as the system May be management problems if servers are owned by different organizations 14 Client-Server Example 15 Pipe and Filter Architecture Functional transformations process their inputs to produce outputs Variants of this approach are very common When transformations are sequential, this is a batch sequential model Components: Filer: Processing component Carries out one type of data transformation Pipe: Data flow through it from one filter to another 16 Pipe and Filter Example 17 Architectural Patterns Model-View-Controller (MVC) Layered Repository Client-server Pipe and filter 18 Object Oriented Programming and Design #17: Course Wrap-up Yair Moshe Winter, 2020/1 What We‚Äôve Learned Abstraction and Specification Procedural, object-oriented Writing, understanding, and reasoning about code Pragmatic considerations Defensive programming Testing The software development process Requirements specification Design and implementation 2 What We‚Äôve Learned Design What makes a design good or bad Design rules of thumb Design patterns 3 Goal of this Course Teach you how to ‚Äúengineer‚Äù software Help you become better programmers Teach you how to write code of higher quality increased complexity 4 Good Luck in the Exam ‚ò∫ 5","libVersion":"0.2.2","langs":""}