{"path":".obsidian/plugins/text-extractor/cache/345bcbe72de11bc2fcf7de8c9a15c60f.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 08 Tree Indexes Part II CMU 15-445/645 (Fall 2019) U P C O M I N G D ATA B A S E E V E N T S Vertica Talk → Monday Sep 23rd @ 4:30pm → GHC 8102 2 CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A More B+Trees Additional Index Magic Tries / Radix Trees Inverted Indexes 3 CMU 15-445/645 (Fall 2019) B + T R E E : D U P L I C AT E K E Y S Approach #1: Append Record Id → Add the tuple's unique record id as part of the key to ensure that all keys are unique. → The DBMS can still use partial keys to find tuples. Approach #2: Overflow Leaf Nodes → Allow leaf nodes to spill into overflow nodes that contain the duplicate keys. → This is more complex to maintain and modify. 4 CMU 15-445/645 (Fall 2019) B + T R E E : A P P E N D R E C O R D I D 5 <5 <9 ≥9 6 7 8 9 131 3 5 9 <Key,RecordId> CMU 15-445/645 (Fall 2019) B + T R E E : A P P E N D R E C O R D I D 5 <5 <9 ≥9 6 7 8 9 131 3 5 9 Insert 6 <Key,RecordId> CMU 15-445/645 (Fall 2019) B + T R E E : A P P E N D R E C O R D I D 5 <5 <9 ≥9 6 7 8 9 131 3 5 9 <Key,RecordId> Insert <6,(Page,Slot)> CMU 15-445/645 (Fall 2019) B + T R E E : A P P E N D R E C O R D I D 5 <5 <9 ≥9 6 7 8 9 131 3 5 9 <Key,RecordId> Insert <6,(Page,Slot)> CMU 15-445/645 (Fall 2019) B + T R E E : A P P E N D R E C O R D I D 5 <5 <9 6 7 8 9 131 3 5 9 <Key,RecordId> Insert <6,(Page,Slot)> 7 8 CMU 15-445/645 (Fall 2019) B + T R E E : A P P E N D R E C O R D I D 5 <5 <9 6 7 8 9 131 3 5 9 <Key,RecordId> Insert <6,(Page,Slot)> 7 8 7 9 CMU 15-445/645 (Fall 2019) B + T R E E : A P P E N D R E C O R D I D 5 <5 <9 6 7 8 9 131 3 5 9 <Key,RecordId> Insert <6,(Page,Slot)> 7 8 7 9 6 ≥9<9 CMU 15-445/645 (Fall 2019) B + T R E E : O V E R F LO W L E A F N O D E S 6 <5 <9 ≥9 6 7 8 9 131 3 5 9 6 Insert 6 CMU 15-445/645 (Fall 2019) B + T R E E : O V E R F LO W L E A F N O D E S 6 <5 <9 ≥9 6 7 8 9 131 3 5 9 6 Insert 6 Insert 7 7 CMU 15-445/645 (Fall 2019) B + T R E E : O V E R F LO W L E A F N O D E S 6 <5 <9 ≥9 6 7 8 9 131 3 5 9 6 Insert 6 Insert 7 7 Insert 6 6 CMU 15-445/645 (Fall 2019) D E M O B+Tree vs. Hash Indexes Table Clustering 7 CMU 15-445/645 (Fall 2019) I M P L I C I T I N D E X E S Most DBMSs automatically create an index to enforce integrity constraints but not referential constraints (foreign keys). → Primary Keys → Unique Constraints 9 CREATE TABLE foo ( id SERIAL PRIMARY KEY, val1 INT NOT NULL, val2 VARCHAR(32) UNIQUE ); CREATE UNIQUE INDEX foo_pkey ON foo (id); CREATE UNIQUE INDEX foo_val2_key ON foo (val2); CMU 15-445/645 (Fall 2019) I M P L I C I T I N D E X E S Most DBMSs automatically create an index to enforce integrity constraints but not referential constraints (foreign keys). → Primary Keys → Unique Constraints 9 CREATE TABLE foo ( id SERIAL PRIMARY KEY, val1 INT NOT NULL, val2 VARCHAR(32) UNIQUE ); CREATE TABLE bar ( id INT REFERENCES foo (val1), val VARCHAR(32) ); CMU 15-445/645 (Fall 2019) I M P L I C I T I N D E X E S Most DBMSs automatically create an index to enforce integrity constraints but not referential constraints (foreign keys). → Primary Keys → Unique Constraints 9 CREATE TABLE foo ( id SERIAL PRIMARY KEY, val1 INT NOT NULL, val2 VARCHAR(32) UNIQUE ); CREATE TABLE bar ( id INT REFERENCES foo (val1), val VARCHAR(32) ); CREATE INDEX foo_val1_key ON foo (val1); CMU 15-445/645 (Fall 2019) I M P L I C I T I N D E X E S Most DBMSs automatically create an index to enforce integrity constraints but not referential constraints (foreign keys). → Primary Keys → Unique Constraints 9 CREATE TABLE foo ( id SERIAL PRIMARY KEY, val1 INT NOT NULL, val2 VARCHAR(32) UNIQUE ); CREATE TABLE bar ( id INT REFERENCES foo (val1), val VARCHAR(32) ); CREATE INDEX foo_val1_key ON foo (val1); X CMU 15-445/645 (Fall 2019) I M P L I C I T I N D E X E S Most DBMSs automatically create an index to enforce integrity constraints but not referential constraints (foreign keys). → Primary Keys → Unique Constraints 9 CREATE TABLE foo ( id SERIAL PRIMARY KEY, val1 INT NOT NULL UNIQUE, val2 VARCHAR(32) UNIQUE ); CREATE TABLE bar ( id INT REFERENCES foo (val1), val VARCHAR(32) ); CMU 15-445/645 (Fall 2019) PA R T I A L I N D E X E S Create an index on a subset of the entire table. This potentially reduces its size and the amount of overhead to maintain it. One common use case is to partition indexes by date ranges. → Create a separate index per month, year. 10 CREATE INDEX idx_foo ON foo (a, b) WHERE c = 'WuTang'; CMU 15-445/645 (Fall 2019) PA R T I A L I N D E X E S Create an index on a subset of the entire table. This potentially reduces its size and the amount of overhead to maintain it. One common use case is to partition indexes by date ranges. → Create a separate index per month, year. 10 CREATE INDEX idx_foo ON foo (a, b) WHERE c = 'WuTang'; SELECT b FROM foo WHERE a = 123 AND c = 'WuTang'; CMU 15-445/645 (Fall 2019) C O V E R I N G I N D E X E S If all the fields needed to process the query are available in an index, then the DBMS does not need to retrieve the tuple. This reduces contention on the DBMS's buffer pool resources. 11 SELECT b FROM foo WHERE a = 123; CREATE INDEX idx_foo ON foo (a, b); CMU 15-445/645 (Fall 2019) C O V E R I N G I N D E X E S If all the fields needed to process the query are available in an index, then the DBMS does not need to retrieve the tuple. This reduces contention on the DBMS's buffer pool resources. 11 SELECT b FROM foo WHERE a = 123; CREATE INDEX idx_foo ON foo (a, b); CMU 15-445/645 (Fall 2019) I N D E X I N C L U D E C O L U M N S Embed additional columns in indexes to support index-only queries. These extra columns are only stored in the leaf nodes and are not part of the search key. 12 CREATE INDEX idx_foo ON foo (a, b) INCLUDE (c); CMU 15-445/645 (Fall 2019) I N D E X I N C L U D E C O L U M N S Embed additional columns in indexes to support index-only queries. These extra columns are only stored in the leaf nodes and are not part of the search key. 12 SELECT b FROM foo WHERE a = 123 AND c = 'WuTang'; CREATE INDEX idx_foo ON foo (a, b) INCLUDE (c); CMU 15-445/645 (Fall 2019) I N D E X I N C L U D E C O L U M N S Embed additional columns in indexes to support index-only queries. These extra columns are only stored in the leaf nodes and are not part of the search key. 12 SELECT b FROM foo WHERE a = 123 AND c = 'WuTang'; CREATE INDEX idx_foo ON foo (a, b) INCLUDE (c); CMU 15-445/645 (Fall 2019) I N D E X I N C L U D E C O L U M N S Embed additional columns in indexes to support index-only queries. These extra columns are only stored in the leaf nodes and are not part of the search key. 12 SELECT b FROM foo WHERE a = 123 AND c = 'WuTang'; CREATE INDEX idx_foo ON foo (a, b) INCLUDE (c); CMU 15-445/645 (Fall 2019) F U N C T I O N A L / E X P R E S S I O N I N D E X E S An index does not need to store keys in the same way that they appear in their base table. 13 SELECT * FROM users WHERE EXTRACT(dow ⮱FROM login) = 2; CREATE INDEX idx_user_login ON users (login); CMU 15-445/645 (Fall 2019) F U N C T I O N A L / E X P R E S S I O N I N D E X E S An index does not need to store keys in the same way that they appear in their base table. 13 SELECT * FROM users WHERE EXTRACT(dow ⮱FROM login) = 2; CREATE INDEX idx_user_login ON users (login);X CMU 15-445/645 (Fall 2019) F U N C T I O N A L / E X P R E S S I O N I N D E X E S An index does not need to store keys in the same way that they appear in their base table. You can use expressions when declaring an index. 13 SELECT * FROM users WHERE EXTRACT(dow ⮱FROM login) = 2; CREATE INDEX idx_user_login ON users (login); CREATE INDEX idx_user_login ON users (EXTRACT(dow FROM login)); X CMU 15-445/645 (Fall 2019) F U N C T I O N A L / E X P R E S S I O N I N D E X E S An index does not need to store keys in the same way that they appear in their base table. You can use expressions when declaring an index. 13 SELECT * FROM users WHERE EXTRACT(dow ⮱FROM login) = 2; CREATE INDEX idx_user_login ON users (login); CREATE INDEX idx_user_login ON users (EXTRACT(dow FROM login)); X CMU 15-445/645 (Fall 2019) F U N C T I O N A L / E X P R E S S I O N I N D E X E S An index does not need to store keys in the same way that they appear in their base table. You can use expressions when declaring an index. 13 SELECT * FROM users WHERE EXTRACT(dow ⮱FROM login) = 2; CREATE INDEX idx_user_login ON users (login); CREATE INDEX idx_user_login ON users (EXTRACT(dow FROM login)); X CREATE INDEX idx_user_login ON foo (login) WHERE EXTRACT(dow FROM login) = 2; CMU 15-445/645 (Fall 2019) O B S E R VAT I O N The inner node keys in a B+Tree cannot tell you whether a key exists in the index. You must always traverse to the leaf node. This means that you could have (at least) one buffer pool page miss per level in the tree just to find out a key does not exist. 14 CMU 15-445/645 (Fall 2019) T R I E I N D E X Use a digital representation of keys to examine prefixes one- by-one instead of comparing entire key. → Also known as Digital Search Tree, Prefix Tree. 15 Keys: HELLO, HAT, HAVE L L O ¤ ¤ E ¤ H A E VT CMU 15-445/645 (Fall 2019) T R I E I N D E X Use a digital representation of keys to examine prefixes one- by-one instead of comparing entire key. → Also known as Digital Search Tree, Prefix Tree. 15 Keys: HELLO, HAT, HAVE L L O ¤ ¤ E ¤ H A E VT CMU 15-445/645 (Fall 2019) T R I E I N D E X P R O P E R T I E S Shape only depends on key space and lengths. → Does not depend on existing keys or insertion order. → Does not require rebalancing operations. All operations have O(k) complexity where k is the length of the key. → The path to a leaf node represents the key of the leaf → Keys are stored implicitly and can be reconstructed from paths. 16 CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N The span of a trie level is the number of bits that each partial key / digit represents. → If the digit exists in the corpus, then store a pointer to the next level in the trie branch. Otherwise, store null. This determines the fan-out of each node and the physical height of the tree. → n-way Trie = Fan-Out of n 17 CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie 0 ¤ 1 Ø 0 ¤ 1 Ø 0 ¤ 1 ¤ 0 ¤ 1 Ø 0 Ø 1 ¤ 0 ¤ 1 Ø 0 ¤ 1 Ø 0 Ø 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ 0 ¤ 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie 0 ¤ 1 Ø 0 ¤ 1 Ø 0 ¤ 1 ¤ 0 ¤ 1 Ø 0 Ø 1 ¤ 0 ¤ 1 Ø 0 ¤ 1 Ø 0 Ø 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ 0 ¤ 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie 0 ¤ 1 Ø 0 ¤ 1 Ø 0 ¤ 1 ¤ 0 ¤ 1 Ø 0 Ø 1 ¤ 0 ¤ 1 Ø 0 ¤ 1 Ø 0 Ø 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ 0 ¤ 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie 0 ¤ 1 Ø 0 ¤ 1 Ø 0 ¤ 1 ¤ 0 ¤ 1 Ø 0 Ø 1 ¤ 0 ¤ 1 Ø 0 ¤ 1 Ø 0 Ø 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ 0 ¤ 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie 0 ¤ 1 Ø 0 ¤ 1 Ø 0 ¤ 1 ¤ 0 ¤ 1 Ø 0 Ø 1 ¤ 0 ¤ 1 Ø 0 ¤ 1 Ø 0 Ø 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ 0 ¤ 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie 0 ¤ 1 Ø 0 ¤ 1 Ø 0 ¤ 1 ¤ 0 ¤ 1 Ø 0 Ø 1 ¤ 0 ¤ 1 Ø 0 ¤ 1 Ø 0 Ø 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ 0 ¤ 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie 0 ¤ 1 Ø 0 ¤ 1 Ø 0 ¤ 1 ¤ 0 ¤ 1 Ø 0 Ø 1 ¤ 0 ¤ 1 Ø 0 ¤ 1 Ø 0 Ø 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ 0 ¤ 1 ¤ 0 Ø 1 ¤ 0 Ø 1 ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie Repeat 10x ¤ Ø ¤ Ø ¤ ¤ ¤ Ø Ø ¤ ¤ Ø ¤ Ø Ø ¤ Ø ¤ Ø ¤ ¤ ¤ Ø ¤ Ø ¤ Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) T R I E K E Y S PA N Keys: K10,K25,K31 18 K10→ 00000000 00001010 K25→ 00000000 00011001 K31→ 00000000 00011111 1-bit Span Trie Repeat 10x ¤ Ø ¤ Ø ¤ ¤ ¤ Ø Ø ¤ ¤ Ø ¤ Ø Ø ¤ Ø ¤ Ø ¤ ¤ ¤ Ø ¤ Ø ¤ Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) R A D I X T R E E Omit all nodes with only a single child. → Also known as Patricia Tree. Can produce false positives, so the DBMS always checks the original tuple to see whether a key matches. 19 1-bit Span Radix Tree ¤ Ø ¤ Ø ¤ ¤ Ø ¤ ¤ ¤ Repeat 10x Tuple Pointer Node Pointer CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO ¤ T ¤ VE H A Insert HAIR CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO ¤ T ¤ VE H A ¤ IR Insert HAIR CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO ¤ T ¤ VE H A ¤ IR Insert HAIR Delete HAT CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO ¤ VE H A ¤ IR Insert HAIR Delete HAT CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO ¤ VE H A ¤ IR Insert HAIR Delete HAT Delete HAVE CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO H A ¤ IR Insert HAIR Delete HAT Delete HAVE CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO H A ¤ IR Insert HAIR Delete HAT Delete HAVE CMU 15-445/645 (Fall 2019) R A D I X T R E E : M O D I F I C AT I O N S 20 ¤ ELLO H A Insert HAIR Delete HAT AIR ¤ Delete HAVE CMU 15-445/645 (Fall 2019) R A D I X T R E E : B I N A R Y C O M PA R A B L E K E Y S Not all attribute types can be decomposed into binary comparable digits for a radix tree. → Unsigned Integers: Byte order must be flipped for little endian machines. → Signed Integers: Flip two’s-complement so that negative numbers are smaller than positive. → Floats: Classify into group (neg vs. pos, normalized vs. denormalized), then store as unsigned integer. → Compound: Transform each attribute separately. 21 CMU 15-445/645 (Fall 2019) R A D I X T R E E : B I N A R Y C O M PA R A B L E K E Y S 22 Hex Key: 0A 0B 0C 0D Int Key: 168496141 0A 0B 0C 0D Big Endian 0D 0C 0B 0A Little Endian 0A 0F0B 0B 1D0C ¤ ¤ ¤0D0B ¤ ¤ 8-bit Span Radix Tree CMU 15-445/645 (Fall 2019) R A D I X T R E E : B I N A R Y C O M PA R A B L E K E Y S 22 Hex Key: 0A 0B 0C 0D Int Key: 168496141 0A 0B 0C 0D Big Endian 0D 0C 0B 0A Little Endian Hex 0A 0B 1D Find 658205 0A 0F0B 0B 1D0C ¤ ¤ ¤0D0B ¤ ¤ 8-bit Span Radix Tree CMU 15-445/645 (Fall 2019) R A D I X T R E E : B I N A R Y C O M PA R A B L E K E Y S 22 Hex Key: 0A 0B 0C 0D Int Key: 168496141 0A 0B 0C 0D Big Endian 0D 0C 0B 0A Little Endian Hex 0A 0B 1D Find 658205 0A 0F0B 0B 1D0C ¤ ¤ ¤0D0B ¤ ¤ 8-bit Span Radix Tree CMU 15-445/645 (Fall 2019) O B S E R VAT I O N The tree indexes that we've discussed so far are useful for \"point\" and \"range\" queries: → Find all customers in the 15217 zip code. → Find all orders between June 2018 and September 2018. They are not good at keyword searches: → Find all Wikipedia articles that contain the word \"Pavlo\" 23 CMU 15-445/645 (Fall 2019) W I K I P E D I A E X A M P L E 24 CREATE TABLE revisions ( revID INT PRIMARY KEY, userID INT REFERENCES useracct (userID), pageID INT REFERENCES pages (pageID), content TEXT, updated DATETIME ); CREATE TABLE pages ( pageID INT PRIMARY KEY, title VARCHAR UNIQUE, latest INT ⮱REFERENCES revisions (revID), ); CREATE TABLE useracct ( userID INT PRIMARY KEY, userName VARCHAR UNIQUE, ⋮ ); CMU 15-445/645 (Fall 2019) W I K I P E D I A E X A M P L E If we create an index on the content attribute, what does that do? This doesn't help our query. Our SQL is also not correct... 25 CREATE INDEX idx_rev_cntnt ON revisions (content); SELECT pageID FROM revisions WHERE content LIKE '%Pavlo%'; CMU 15-445/645 (Fall 2019) I N V E R T E D I N D E X An inverted index stores a mapping of words to records that contain those words in the target attribute. → Sometimes called a full-text search index. → Also called a concordance in old (like really old) times. The major DBMSs support these natively. There are also specialized DBMSs. 26 CMU 15-445/645 (Fall 2019) Q U E R Y T Y P E S Phrase Searches → Find records that contain a list of words in the given order. Proximity Searches → Find records where two words occur within n words of each other. Wildcard Searches → Find records that contain words that match some pattern (e.g., regular expression). 27 CMU 15-445/645 (Fall 2019) D E S I G N D E C I S I O N S Decision #1: What To Store → The index needs to store at least the words contained in each record (separated by punctuation characters). → Can also store frequency, position, and other meta-data. Decision #2: When To Update → Maintain auxiliary data structures to \"stage\" updates and then update the index in batches. 28 CMU 15-445/645 (Fall 2019) C O N C L U S I O N B+Trees are still the way to go for tree indexes. Inverted indexes are covered in CMU 11-442. We did not discuss geo-spatial tree indexes: → Examples: R-Tree, Quad-Tree, KD-Tree → This is covered in CMU 15-826. 30 CMU 15-445/645 (Fall 2019) N E X T C L A S S How to make indexes thread-safe! 31","libVersion":"0.2.2","langs":""}