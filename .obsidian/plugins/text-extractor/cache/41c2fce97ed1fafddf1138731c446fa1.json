{"path":".obsidian/plugins/text-extractor/cache/41c2fce97ed1fafddf1138731c446fa1.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 20 Logging Schemes CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Homework #4 is due Wed Nov 13th @ 11:59pm. Project #3 is due Sun Nov 17th @ 11:59pm. Extra Credit Checkpoint is due Sun Nov 24th. 2 CMU 15-445/645 (Fall 2019)TIME Schedule M O T I VAT I O N 6 BEGIN R(A) W(A) ⋮ COMMIT Buffer Pool A=1Page A=1A=2 T1 CMU 15-445/645 (Fall 2019) C R A S H R E C O V E R Y Recovery algorithms are techniques to ensure database consistency, transaction atomicity, and durability despite failures. Recovery algorithms have two parts: → Actions during normal txn processing to ensure that the DBMS can recover from a failure. → Actions after a failure to recover the database to a state that ensures atomicity, consistency, and durability. 7 Today CMU 15-445/645 (Fall 2019) Failure Classification Buffer Pool Policies Shadow Paging Write-Ahead Log Logging Schemes Checkpoints 8 CMU 15-445/645 (Fall 2019) C R A S H R E C O V E R Y DBMS is divided into different components based on the underlying storage device. We must also classify the different types of failures that the DBMS needs to handle. 9 CMU 15-445/645 (Fall 2019) FA I L U R E C L A S S I F I C AT I O N Type #1 – Transaction Failures Type #2 – System Failures Type #3 – Storage Media Failures 11 CMU 15-445/645 (Fall 2019) T R A N S A C T I O N FA I L U R E S Logical Errors: → Transaction cannot complete due to some internal error condition (e.g., integrity constraint violation). Internal State Errors: → DBMS must terminate an active transaction due to an error condition (e.g., deadlock). 12 CMU 15-445/645 (Fall 2019) S Y S T E M FA I L U R E S Software Failure: → Problem with the DBMS implementation (e.g., uncaught divide-by-zero exception). Hardware Failure: → The computer hosting the DBMS crashes (e.g., power plug gets pulled). → Fail-stop Assumption: Non-volatile storage contents are assumed to not be corrupted by system crash. 13 CMU 15-445/645 (Fall 2019) S T O R A G E M E D I A FA I L U R E Non-Repairable Hardware Failure: → A head crash or similar disk failure destroys all or part of non-volatile storage. → Destruction is assumed to be detectable (e.g., disk controller use checksums to detect failures). No DBMS can recover from this! Database must be restored from archived version. 14 CMU 15-445/645 (Fall 2019) O B S E R VAT I O N The primary storage location of the database is on non-volatile storage, but this is much slower than volatile storage. Use volatile memory for faster access: → First copy target record into memory. → Perform the writes in memory. → Write dirty records back to disk. 15 CMU 15-445/645 (Fall 2019) O B S E R VAT I O N The DBMS needs to ensure the following guarantees: → The changes for any txn are durable once the DBMS has told somebody that it committed. → No partial changes are durable if the txn aborted. 16 CMU 15-445/645 (Fall 2019) U N D O V S . R E D O Undo: The process of removing the effects of an incomplete or aborted txn. Redo: The process of re-instating the effects of a committed txn for durability. How the DBMS supports this functionality depends on how it manages the buffer pool… 17 CMU 15-445/645 (Fall 2019) Buffer PoolTIME Schedule T1 T2 B U F F E R P O O L 18 A=1 B=9 C=7 A=1 B=9 C=7B=8 BEGIN R(A) W(A) ⋮ ABORT BEGIN R(B) W(B) COMMIT A=3 Do we force T2’s changes to be written to disk?Is T1 allowed to overwrite A even though it has not committed? What happens when we need to rollback T1? B=8A=3 CMU 15-445/645 (Fall 2019) S T E A L P O L I C Y Whether the DBMS allows an uncommitted txn to overwrite the most recent committed value of an object in non-volatile storage. STEAL: Is allowed. NO-STEAL: Is not allowed. 19 CMU 15-445/645 (Fall 2019) F O R C E P O L I C Y Whether the DBMS requires that all updates made by a txn are reflected on non-volatile storage before the txn is allowed to commit. FORCE: Is required. NO-FORCE: Is not required. 20 CMU 15-445/645 (Fall 2019) Buffer PoolTIME Schedule T1 T2 NO -S T E A L + F O R C E 21 A=1 B=9 C=7 A=1 B=9 C=7B=8 BEGIN R(A) W(A) ⋮ ABORT BEGIN R(B) W(B) COMMIT A=3 FORCE means that T2 changes must be written to disk at this point. NO-STEAL means that T1 changes cannot be written to disk yet. Now it’s trivial to rollback T1 B=8 A=1 B=8 C=7 Copy CMU 15-445/645 (Fall 2019) NO -S T E A L + F O R C E This approach is the easiest to implement: → Never have to undo changes of an aborted txn because the changes were not written to disk. → Never have to redo changes of a committed txn because all the changes are guaranteed to be written to disk at commit time (assuming atomic hardware writes). Previous example cannot support write sets that exceed the amount of physical memory available. 22 CMU 15-445/645 (Fall 2019) S H A D O W PA G I N G Maintain two separate copies of the database: → Master: Contains only changes from committed txns. → Shadow: Temporary database with changes made from uncommitted txns. Txns only make updates in the shadow copy. When a txn commits, atomically switch the shadow to become the new master. Buffer Pool Policy: NO-STEAL + FORCE 23 CMU 15-445/645 (Fall 2019) S H A D O W PA G I N G Instead of copying the entire database, the DBMS copies pages on write. Organize the database pages in a tree structure where the root is a single disk page. There are two copies of the tree, the master and shadow → The root points to the master copy. → Updates are applied to the shadow copy. 24 CMU 15-445/645 (Fall 2019) DiskMemory S H A D O W PA G I N G E X A M P L E 25 Master Page Table 1 2 3 4 DB Root Database Root CMU 15-445/645 (Fall 2019) S H A D O W PA G I N G To install the updates, overwrite the root so it points to the shadow, thereby swapping the master and shadow: → Before overwriting the root, none of the txn's updates are part of the disk-resident database → After overwriting the root, all the txn's updates are part of the disk-resident database. 26 Source: The Great Phil Bernstein CMU 15-445/645 (Fall 2019) COMMIT DiskMemory S H A D O W PA G I N G E X A M P L E 27 Master Page Table 1 2 3 4 DB Root Shadow Page Table 1 2 3 4 Read-only txns access the current master. Active modifying txn updates shadow pages. X X X X Update Database Root Update CMU 15-445/645 (Fall 2019) S H A D O W PA G I N G U N D O / R E D O Supporting rollbacks and recovery is easy. Undo: Remove the shadow pages. Leave the master and the DB root pointer alone. Redo: Not needed at all. 28 CMU 15-445/645 (Fall 2019) S H A D O W PA G I N G D I S A D VA N TA G E S Copying the entire page table is expensive: → Use a page table structured like a B+tree. → No need to copy entire tree, only need to copy paths in the tree that lead to updated leaf nodes. Commit overhead is high: → Flush every updated page, page table, and root. → Data gets fragmented. → Need garbage collection. → Only supports one writer txn at a time or txns in a batch. 29 CMU 15-445/645 (Fall 2019) S Q L I T E ( P R E - 2 0 1 0 ) When a txn modifies a page, the DBMS copies the original page to a separate journal file before overwriting master version. After restarting, if a journal file exists, then the DBMS restores it to undo changes from uncommitted txns. 30 Memory Disk Page 2Page 2 Page 1 Page 3 Page 5 Page 4 Page 6 Journal File Page 1 Page 2 Page 3Page 2' Page 3 Page 3' Page 2' CMU 15-445/645 (Fall 2019) O B S E R VAT I O N Shadowing page requires the DBMS to perform writes to random non-contiguous pages on disk. We need a way for the DBMS convert random writes into sequential writes. 31 CMU 15-445/645 (Fall 2019) W R I T E- A H E A D L O G Maintain a log file separate from data files that contains the changes that txns make to database. → Assume that the log is on stable storage. → Log contains enough information to perform the necessary undo and redo actions to restore the database. DBMS must write to disk the log file records that correspond to changes made to a database object before it can flush that object to disk. Buffer Pool Policy: STEAL + NO-FORCE 32 CMU 15-445/645 (Fall 2019) WA L P R O T O C O L The DBMS stages all a txn's log records in volatile storage (usually backed by buffer pool). All log records pertaining to an updated page are written to non-volatile storage before the page itself is over-written in non-volatile storage. A txn is not considered committed until all its log records have been written to stable storage. 33 CMU 15-445/645 (Fall 2019) WA L P R O T O C O L Write a <BEGIN> record to the log for each txn to mark its starting point. When a txn finishes, the DBMS will: → Write a <COMMIT> record on the log → Make sure that all log records are flushed before it returns an acknowledgement to application. 34 CMU 15-445/645 (Fall 2019) WA L P R O T O C O L Each log entry contains information about the change to a single object: → Transaction Id → Object Id → Before Value (UNDO) → After Value (REDO) 35 CMU 15-445/645 (Fall 2019) Buffer Pool A=1 B=5 C=7A=8TIME Schedule BEGIN W(A) W(B) ⋮ COMMIT T1 WAL Buffer WA L E X A M P L E 36 <T1 BEGIN> <T1, A, 1, 8> <T1, B, 5, 9> <T1 COMMIT> ⋮ Txn result is now safe to return to application. B=9 A=1 B=5 C=7 <T1 BEGIN> <T1, A, 1, 8> <T1, B, 5, 9> <T1 COMMIT> 1 2X X Everything we need to restore T1 is in the log! CMU 15-445/645 (Fall 2019) WA L I M P L E M E N TAT I O N When should the DBMS write log entries to disk? → When the transaction commits. → Can use group commit to batch multiple log flushes together to amortize overhead. 37 CMU 15-445/645 (Fall 2019) WAL Buffers WA L G R O U P C O M M I T 38 <T1 BEGIN> <T1, A, 1, 8> <T1, B, 5, 9> <T2 BEGIN> <T2, C, 1, 2> <T1 BEGIN> <T1, A, 1, 8> <T1, B, 5, 9> <T2 BEGIN> <T2, C, 1, 2>TIME Schedule T1 T2 BEGIN W(A) W(B) ⋮ COMMIT BEGIN W(C) W(D) ⋮ COMMIT <T2, D, 3, 4> <T2, D, 3, 4> Flush the buffer when it is full. Flush after an elapsed amount of time. CMU 15-445/645 (Fall 2019) WA L I M P L E M E N TAT I O N When should the DBMS write log entries to disk? → When the transaction commits. → Can use group commit to batch multiple log flushes together to amortize overhead. When should the DBMS write dirty records to disk? → Every time the txn executes an update? → Once when the txn commits? 39 CMU 15-445/645 (Fall 2019) B U F F E R P O O L P O L I C I E S Almost every DBMS uses NO-FORCE + STEAL 42 NO-STEAL STEAL NO-FORCE Fastest FORCE Slowest Runtime Performance NO-STEAL STEAL NO-FORCE Slowest FORCE Fastest Recovery Performance Undo + Redo No Undo + No Redo CMU 15-445/645 (Fall 2019) L O G G I N G S C H E M E S Physical Logging → Record the changes made to a specific location in the database. → Example: git diff Logical Logging → Record the high-level operations executed by txns. → Not necessarily restricted to single page. → Example: The UPDATE, DELETE, and INSERT queries invoked by a txn. 43 CMU 15-445/645 (Fall 2019) P H Y S I C A L V S . L O G I C A L L O G G I N G Logical logging requires less data written in each log record than physical logging. Difficult to implement recovery with logical logging if you have concurrent txns. → Hard to determine which parts of the database may have been modified by a query before crash. → Also takes longer to recover because you must re-execute every txn all over again. 44 CMU 15-445/645 (Fall 2019) P H Y S I O L O G I C A L L O G G I N G Hybrid approach where log records target a single page but do not specify data organization of the page. This is the most popular approach. 45 CMU 15-445/645 (Fall 2019) L O G G I N G S C H E M E S 46 UPDATE foo SET val = XYZ WHERE id = 1; Physical <T1, Table=X, Page=99, Offset=4, Before=ABC, After=XYZ> <T1, Index=X_PKEY, Page=45, Offset=9, Key=(1,Record1)> Logical <T1, Query=\"UPDATE foo SET val=XYZ WHERE id=1\"> Physiological <T1, Table=X, Page=99, ObjectId=1, Before=ABC, After=XYZ> <T1, Index=X_PKEY, IndexPage=45, Key=(1,Record1)> CMU 15-445/645 (Fall 2019) C H E C K P O I N T S The WAL will grow forever. After a crash, the DBMS has to replay the entire log which will take a long time. The DBMS periodically takes a checkpoint where it flushes all buffers out to disk. 47 CMU 15-445/645 (Fall 2019) C H E C K P O I N T S Output onto stable storage all log records currently residing in main memory. Output to the disk all modified blocks. Write a <CHECKPOINT> entry to the log and flush to stable storage. 48 CMU 15-445/645 (Fall 2019) WAL <T1 BEGIN> <T1, A, 1, 2> <T1 COMMIT> <T2 BEGIN> <T2, A, 2, 3> <T3 BEGIN> <CHECKPOINT> <T2 COMMIT> <T3, A, 3, 4> ⋮ CRASH! C H E C K P O I N T S Any txn that committed before the checkpoint is ignored (T1). T2 + T3 did not commit before the last checkpoint. → Need to redo T2 because it committed after checkpoint. → Need to undo T3 because it did not commit before the crash. 49 CMU 15-445/645 (Fall 2019) C H E C K P O I N T S C H A L L E N G E S We have to stall all txns when take a checkpoint to ensure a consistent snapshot. Scanning the log to find uncommitted txns can take a long time. Not obvious how often the DBMS should take a checkpoint… 50 CMU 15-445/645 (Fall 2019) C H E C K P O I N T S F R E Q U E N C Y Checkpointing too often causes the runtime performance to degrade. → System spends too much time flushing buffers. But waiting a long time is just as bad: → The checkpoint will be large and slow. → Makes recovery time much longer. 51 CMU 15-445/645 (Fall 2019) C O N C L U S I O N Write-Ahead Logging is (almost) always the best approach to handle loss of volatile storage. → Use incremental updates (STEAL + NO-FORCE) with checkpoints. → On recovery: undo uncommitted txns + redo committed txns. 52 CMU 15-445/645 (Fall 2019) N E X T C L A S S Recovery with ARIES. 53","libVersion":"0.2.2","langs":""}