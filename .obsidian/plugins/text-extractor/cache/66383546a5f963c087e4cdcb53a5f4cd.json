{"path":".obsidian/plugins/text-extractor/cache/66383546a5f963c087e4cdcb53a5f4cd.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 12 Query Execution Part I CMU 15-445/645 (Fall 2019) A D M I N I S T R I V I A Homework #3 is due Wed Oct 9th @ 11:59pm Mid-Term Exam is Wed Oct 16th @ 12:00pm Project #2 is due Sun Oct 20th @ 11:59pm 2 CMU 15-445/645 (Fall 2019) Q U E R Y P L A N The operators are arranged in a tree. Data flows from the leaves of the tree up towards the root. The output of the root node is the result of the query. 3 R S R.id=S.id value>100 R.id, S.value ⨝ s p SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) T O D AY ' S A G E N D A Processing Models Access Methods Expression Evaluation 4 CMU 15-445/645 (Fall 2019) P R O C E S S I N G M O D E L A DBMS's processing model defines how the system executes a query plan. → Different trade-offs for different workloads. Approach #1: Iterator Model Approach #2: Materialization Model Approach #3: Vectorized / Batch Model 5 CMU 15-445/645 (Fall 2019) I T E R AT O R M O D E L Each query plan operator implements a Next function. → On each invocation, the operator returns either a single tuple or a null marker if there are no more tuples. → The operator implements a loop that calls next on its children to retrieve their tuples and then process them. Also called Volcano or Pipeline Model. 6 CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 I T E R AT O R M O D E L 7 R S R.id=S.id value>100 R.id, S.value ⨝ s p for t in R: emit(t) for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): emit(t1⨝t2) for t in child.Next(): emit(projection(t)) for t in child.Next(): if evalPred(t): emit(t) for t in S: emit(t) Next() Next() Next() Next() Next() CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 I T E R AT O R M O D E L 7 R S R.id=S.id value>100 R.id, S.value ⨝ s p for t in R: emit(t) for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): emit(t1⨝t2) for t in child.Next(): emit(projection(t)) for t in child.Next(): if evalPred(t): emit(t) for t in S: emit(t) 1 CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 I T E R AT O R M O D E L 7 R S R.id=S.id value>100 R.id, S.value ⨝ s p for t in R: emit(t) for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): emit(t1⨝t2) for t in child.Next(): emit(projection(t)) for t in child.Next(): if evalPred(t): emit(t) for t in S: emit(t) 1 2 CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 I T E R AT O R M O D E L 7 R S R.id=S.id value>100 R.id, S.value ⨝ s p for t in R: emit(t) for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): emit(t1⨝t2) for t in child.Next(): emit(projection(t)) for t in child.Next(): if evalPred(t): emit(t) for t in S: emit(t) 1 2 3 Single Tuple CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 I T E R AT O R M O D E L 7 R S R.id=S.id value>100 R.id, S.value ⨝ s p for t in R: emit(t) for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): emit(t1⨝t2) for t in child.Next(): emit(projection(t)) for t in child.Next(): if evalPred(t): emit(t) for t in S: emit(t) 1 2 3 5 4 CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 I T E R AT O R M O D E L 7 R S R.id=S.id value>100 R.id, S.value ⨝ s p for t in R: emit(t) for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): emit(t1⨝t2) for t in child.Next(): emit(projection(t)) for t in child.Next(): if evalPred(t): emit(t) for t in S: emit(t) 1 2 3 5 4 CMU 15-445/645 (Fall 2019) I T E R AT O R M O D E L This is used in almost every DBMS. Allows for tuple pipelining. Some operators have to block until their children emit all of their tuples. → Joins, Subqueries, Order By Output control works easily with this approach. 8 CMU 15-445/645 (Fall 2019) M AT E R I A L I Z AT I O N M O D E L Each operator processes its input all at once and then emits its output all at once. → The operator \"materializes\" its output as a single result. → The DBMS can push down hints into to avoid scanning too many tuples. → Can send either a materialized row or a single column. The output can be either whole tuples (NSM) or subsets of columns (DSM) 9 CMU 15-445/645 (Fall 2019) M AT E R I A L I Z AT I O N M O D E L 10 R S R.id=S.id value>100 R.id, S.value ⨝ s p out = [ ] for t in R: out.add(t) return out out = [ ] for t1 in left.Output(): buildHashTable(t1) for t2 in right.Output(): if probe(t2): out.add(t1⨝t2) return out out = [ ] for t in child.Output(): out.add(projection(t)) return out out = [ ] for t in child.Output(): if evalPred(t): out.add(t) return out out = [ ] for t in S: out.add(t) return out 1 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) M AT E R I A L I Z AT I O N M O D E L 10 R S R.id=S.id value>100 R.id, S.value ⨝ s p out = [ ] for t in R: out.add(t) return out out = [ ] for t1 in left.Output(): buildHashTable(t1) for t2 in right.Output(): if probe(t2): out.add(t1⨝t2) return out out = [ ] for t in child.Output(): out.add(projection(t)) return out out = [ ] for t in child.Output(): if evalPred(t): out.add(t) return out out = [ ] for t in S: out.add(t) return out 1 2 3 All Tuples SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) M AT E R I A L I Z AT I O N M O D E L 10 R S R.id=S.id value>100 R.id, S.value ⨝ s p out = [ ] for t in R: out.add(t) return out out = [ ] for t1 in left.Output(): buildHashTable(t1) for t2 in right.Output(): if probe(t2): out.add(t1⨝t2) return out out = [ ] for t in child.Output(): out.add(projection(t)) return out out = [ ] for t in child.Output(): if evalPred(t): out.add(t) return out out = [ ] for t in S: out.add(t) return out 1 2 3 5 4 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) M AT E R I A L I Z AT I O N M O D E L 10 R S R.id=S.id value>100 R.id, S.value ⨝ s p out = [ ] for t in R: out.add(t) return out out = [ ] for t1 in left.Output(): buildHashTable(t1) for t2 in right.Output(): if probe(t2): out.add(t1⨝t2) return out out = [ ] for t in child.Output(): out.add(projection(t)) return out out = [ ] for t in child.Output(): if evalPred(t): out.add(t) return out out = [ ] for t in S: out.add(t) return out 1 2 3 5 4 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) M AT E R I A L I Z AT I O N M O D E L Better for OLTP workloads because queries only access a small number of tuples at a time. → Lower execution / coordination overhead. → Fewer function calls. Not good for OLAP queries with large intermediate results. 11 CMU 15-445/645 (Fall 2019) V E C T O R I Z AT I O N M O D E L Like the Iterator Model where each operator implements a Next function in this model. Each operator emits a batch of tuples instead of a single tuple. → The operator's internal loop processes multiple tuples at a time. → The size of the batch can vary based on hardware or query properties. 12 CMU 15-445/645 (Fall 2019) V E C T O R I Z AT I O N M O D E L 13 R S R.id=S.id value>100 R.id, S.value ⨝ s p out = [ ] for t in R: out.add(t) if |out|>n: emit(out) out = [ ] for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): out.add(t1⨝t2) if |out|>n: emit(out) out = [ ] for t in child.Next(): out.add(projection(t)) if |out|>n: emit(out) out = [ ] for t in child.Next(): if evalPred(t): out.add(t) if |out|>n: emit(out) 1 2 3 out = [ ] for t in S: out.add(t) if |out|>n: emit(out) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 Tuple Batch CMU 15-445/645 (Fall 2019) V E C T O R I Z AT I O N M O D E L 13 R S R.id=S.id value>100 R.id, S.value ⨝ s p out = [ ] for t in R: out.add(t) if |out|>n: emit(out) out = [ ] for t1 in left.Next(): buildHashTable(t1) for t2 in right.Next(): if probe(t2): out.add(t1⨝t2) if |out|>n: emit(out) out = [ ] for t in child.Next(): out.add(projection(t)) if |out|>n: emit(out) out = [ ] for t in child.Next(): if evalPred(t): out.add(t) if |out|>n: emit(out) 1 2 3 out = [ ] for t in S: out.add(t) if |out|>n: emit(out) 5 4 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 Tuple Batch CMU 15-445/645 (Fall 2019) V E C T O R I Z AT I O N M O D E L Ideal for OLAP queries because it greatly reduces the number of invocations per operator. Allows for operators to use vectorized (SIMD) instructions to process batches of tuples. 14 CMU 15-445/645 (Fall 2019) P L A N P R O C E S S I N G D I R E C T I O N Approach #1: Top-to-Bottom → Start with the root and \"pull\" data up from its children. → Tuples are always passed with function calls. Approach #2: Bottom-to-Top → Start with leaf nodes and push data to their parents. → Allows for tighter control of caches/registers in pipelines. 15 CMU 15-445/645 (Fall 2019) A C C E S S M E T H O D S An access method is a way that the DBMS can access the data stored in a table. → Not defined in relational algebra. Three basic approaches: → Sequential Scan → Index Scan → Multi-Index / \"Bitmap\" Scan 16 R S R.id=S.id value>100 R.id, S.value ⨝ s p SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S E Q U E N T I A L S C A N For each page in the table: → Retrieve it from the buffer pool. → Iterate over each tuple and check whether to include it. The DBMS maintains an internal cursor that tracks the last page / slot it examined. 17 for page in table.pages: for t in page.tuples: if evalPred(t): // Do Something! CMU 15-445/645 (Fall 2019) S E Q U E N T I A L S C A N : O P T I M I Z AT I O N S This is almost always the worst thing that the DBMS can do to execute a query. Sequential Scan Optimizations: → Prefetching → Buffer Pool Bypass → Parallelization → Zone Maps → Late Materialization → Heap Clustering 18 CMU 15-445/645 (Fall 2019) Z O N E M A P S Pre-computed aggregates for the attribute values in a page. DBMS checks the zone map first to decide whether it wants to access the page. 19 Zone Map val 100 400 280 1400 type MIN MAX AVG SUM 5COUNT Original Data val 100 200 300 400 400 SELECT * FROM table WHERE val > 600 CMU 15-445/645 (Fall 2019) L AT E M AT E R I A L I Z AT I O N DSM DBMSs can delay stitching together tuples until the upper parts of the query plan. 20 0 1 2 3 a b c SELECT AVG(foo.c) FROM foo JOIN bar ON foo.b = bar.b WHERE foo.a > 100 bar foo foo.b=bar.b a>100 AVG(foo.c) ⨝ s γ CMU 15-445/645 (Fall 2019) L AT E M AT E R I A L I Z AT I O N DSM DBMSs can delay stitching together tuples until the upper parts of the query plan. 20 0 1 2 3 a b c SELECT AVG(foo.c) FROM foo JOIN bar ON foo.b = bar.b WHERE foo.a > 100 bar foo foo.b=bar.b a>100 AVG(foo.c) ⨝ s γ Offsets CMU 15-445/645 (Fall 2019) L AT E M AT E R I A L I Z AT I O N DSM DBMSs can delay stitching together tuples until the upper parts of the query plan. 20 0 1 2 3 a b c SELECT AVG(foo.c) FROM foo JOIN bar ON foo.b = bar.b WHERE foo.a > 100 bar foo foo.b=bar.b a>100 AVG(foo.c) ⨝ s γ Offsets Offsets CMU 15-445/645 (Fall 2019) L AT E M AT E R I A L I Z AT I O N DSM DBMSs can delay stitching together tuples until the upper parts of the query plan. 20 0 1 2 3 a b c SELECT AVG(foo.c) FROM foo JOIN bar ON foo.b = bar.b WHERE foo.a > 100 bar foo foo.b=bar.b a>100 AVG(foo.c) ⨝ s γ Offsets Offsets Result CMU 15-445/645 (Fall 2019) H E A P C L U S T E R I N G Tuples are sorted in the heap's pages using the order specified by a clustering index. If the query accesses tuples using the clustering index's attributes, then the DBMS can jump directly to the pages that it needs. 21 101 102 103 104 Scan Direction CMU 15-445/645 (Fall 2019) I N D E X S C A N The DBMS picks an index to find the tuples that the query needs. Which index to use depends on: → What attributes the index contains → What attributes the query references → The attribute's value domains → Predicate composition → Whether the index has unique or non-unique keys 22 CMU 15-445/645 (Fall 2019) I N D E X S C A N Suppose that we a single table with 100 tuples and two indexes: → Index #1: age → Index #2: dept 23 SELECT * FROM students WHERE age < 30 AND dept = 'CS' AND country = 'US' There are 99 people under the age of 30 but only 2 people in the CS department. Scenario #1 There are 99 people in the CS department but only 2 people under the age of 30. Scenario #2 CMU 15-445/645 (Fall 2019) M U LT I - I N D E X S C A N If there are multiple indexes that the DBMS can use for a query: → Compute sets of record ids using each matching index. → Combine these sets based on the query's predicates (union vs. intersect). → Retrieve the records and apply any remaining predicates. Postgres calls this Bitmap Scan. 24 CMU 15-445/645 (Fall 2019) M U LT I - I N D E X S C A N With an index on age and an index on dept, → We can retrieve the record ids satisfying age<30 using the first, → Then retrieve the record ids satisfying dept='CS' using the second, → Take their intersection → Retrieve records and check country='US'. 25 SELECT * FROM students WHERE age < 30 AND dept = 'CS' AND country = 'US' CMU 15-445/645 (Fall 2019) M U LT I - I N D E X S C A N Set intersection can be done with bitmaps, hash tables, or Bloom filters. 26 age<30 dept='CS' record ids SELECT * FROM students WHERE age < 30 AND dept = 'CS' AND country = 'US' CMU 15-445/645 (Fall 2019) M U LT I - I N D E X S C A N Set intersection can be done with bitmaps, hash tables, or Bloom filters. 26 age<30 dept='CS' record ids record ids SELECT * FROM students WHERE age < 30 AND dept = 'CS' AND country = 'US' CMU 15-445/645 (Fall 2019) M U LT I - I N D E X S C A N Set intersection can be done with bitmaps, hash tables, or Bloom filters. 26 age<30 dept='CS' record ids record ids country='US'fetch records SELECT * FROM students WHERE age < 30 AND dept = 'CS' AND country = 'US' CMU 15-445/645 (Fall 2019) I N D E X S C A N PA G E S O R T I N G Retrieving tuples in the order that appear in an unclustered index is inefficient. The DBMS can first figure out all the tuples that it needs and then sort them based on their page id. 27 101 102 103 104 Scan Direction CMU 15-445/645 (Fall 2019) I N D E X S C A N PA G E S O R T I N G Retrieving tuples in the order that appear in an unclustered index is inefficient. The DBMS can first figure out all the tuples that it needs and then sort them based on their page id. 27 101 102 103 104 Scan Direction CMU 15-445/645 (Fall 2019) I N D E X S C A N PA G E S O R T I N G Retrieving tuples in the order that appear in an unclustered index is inefficient. The DBMS can first figure out all the tuples that it needs and then sort them based on their page id. 27 101 102 103 104 Page 102 Page 103 Page 102 Page 104 Page 104 Page 103 Page 102 Page 101 Page 104 Page 103 Page 102 Page 103 Scan Direction CMU 15-445/645 (Fall 2019) I N D E X S C A N PA G E S O R T I N G Retrieving tuples in the order that appear in an unclustered index is inefficient. The DBMS can first figure out all the tuples that it needs and then sort them based on their page id. 27 101 102 103 104 Page 102 Page 103 Page 102 Page 104 Page 104 Page 103 Page 102 Page 101 Page 104 Page 103 Page 102 Page 103 Page 102 Page 101 Page 102 Page 102 Page 103 Page 104 Page 103 Page 104 Page 101 Page 102 Page 103 Page 104 Scan Direction CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 E X P R E S S I O N E VA L U AT I O N The DBMS represents a WHERE clause as an expression tree. The nodes in the tree represent different expression types: → Comparisons (=, <, >, !=) → Conjunction (AND), Disjunction (OR) → Arithmetic Operators (+, -, *, /, %) → Constant Values → Tuple Attribute References 28 Attribute(S.id) = Attribute(R.id) AND > Attribute(value) Constant(100) CMU 15-445/645 (Fall 2019) E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 CMU 15-445/645 (Fall 2019) Execution Context E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 Current Tuple (123, 1000) Query Parameters (int:999) Table Schema S→(int:id, int:value) Attribute(S.value) Constant(1) = + Parameter(0) CMU 15-445/645 (Fall 2019) Execution Context E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 Current Tuple (123, 1000) Query Parameters (int:999) Table Schema S→(int:id, int:value) Attribute(S.value) Constant(1) = + Parameter(0) CMU 15-445/645 (Fall 2019) 1000 Execution Context E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 Current Tuple (123, 1000) Query Parameters (int:999) Table Schema S→(int:id, int:value) Attribute(S.value) Constant(1) = + Parameter(0) CMU 15-445/645 (Fall 2019) 1000 999 Execution Context E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 Current Tuple (123, 1000) Query Parameters (int:999) Table Schema S→(int:id, int:value) Attribute(S.value) Constant(1) = + Parameter(0) CMU 15-445/645 (Fall 2019) 1000 999 1 Execution Context E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 Current Tuple (123, 1000) Query Parameters (int:999) Table Schema S→(int:id, int:value) Attribute(S.value) Constant(1) = + Parameter(0) CMU 15-445/645 (Fall 2019) 1000 999 1 1000 Execution Context E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 Current Tuple (123, 1000) Query Parameters (int:999) Table Schema S→(int:id, int:value) Attribute(S.value) Constant(1) = + Parameter(0) CMU 15-445/645 (Fall 2019) 1000 999 1 true 1000 Execution Context E X P R E S S I O N E VA L U AT I O N 29 SELECT * FROM S WHERE B.value = ? + 1 Current Tuple (123, 1000) Query Parameters (int:999) Table Schema S→(int:id, int:value) Attribute(S.value) Constant(1) = + Parameter(0) CMU 15-445/645 (Fall 2019) E X P R E S S I O N E VA L U AT I O N Evaluating predicates in this manner is slow. → The DBMS traverses the tree and for each node that it visits it must figure out what the operator needs to do. Consider the predicate \"WHERE 1=1\" A better approach is to just evaluate the expression directly. → Think JIT compilation 30 Constant(1) = Constant(1) 1 = 1 CMU 15-445/645 (Fall 2019) C O N C L U S I O N The same query plan be executed in multiple ways. (Most) DBMSs will want to use an index scan as much as possible. Expression trees are flexible but slow. 31 CMU 15-445/645 (Fall 2019) N E X T C L A S S Parallel Query Execution 32","libVersion":"0.2.2","langs":""}