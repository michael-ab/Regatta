{"path":".obsidian/plugins/text-extractor/cache/b4f013b7a26c9420b8697c76c32915a9.json","text":"Intro to Database Systems 15-445/15-645 Fall 2019 Andy Pavlo Computer Science Carnegie Mellon UniversityAP 11 Join Algorithms CMU 15-445/645 (Fall 2019) W H Y D O W E N E E D T O J O I N ? We normalize tables in a relational database to avoid unnecessary repetition of information. We use the join operate to reconstruct the original tuples without any information loss. 2 CMU 15-445/645 (Fall 2019) J O I N A LG O R I T H M S We will focus on combining two tables at a time with inner equijoin algorithms. → These algorithms can be tweaked to support other joins. In general, we want the smaller table to always be the left table (\"outer table\") in the query plan. 3 CMU 15-445/645 (Fall 2019) J O I N O P E R AT O R S Decision #1: Output → What data does the join operator emit to its parent operator in the query plan tree? Decision #2: Cost Analysis Criteria → How do we determine whether one join algorithm is better than another? 4 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 R S R.id=S.id value>100 R.id, S.cdate ⨝ s p CMU 15-445/645 (Fall 2019) SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 O P E R AT O R O U T P U T For a tuple r ∈ R and a tuple s ∈ S that match on join attributes, concatenate rand s together into a new tuple. Contents can vary: → Depends on processing model → Depends on storage model → Depends on the query 5 R S R.id=S.id value>100 R.id, S.cdate ⨝ s p CMU 15-445/645 (Fall 2019) J O I N O P E R AT O R O U T P U T: D ATA Copy the values for the attributes in outer and inner tuples into a new output tuple. 6 id name 123 abc id value cdate 123 1000 10/2/2019 123 2000 10/2/2019⨝ R(id,name) S(id,value,cdate) R.id R.name S.id S.value S.cdate 123 abc 123 1000 10/2/2019 123 abc 123 2000 10/2/2019 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) J O I N O P E R AT O R O U T P U T: D ATA Copy the values for the attributes in outer and inner tuples into a new output tuple. 6 R S R.id=S.id value>100 R.id, S.cdate ⨝ s p R.id R.name S.id S.value S.cdate 123 abc 123 1000 10/2/2019 123 abc 123 2000 10/2/2019 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) J O I N O P E R AT O R O U T P U T: D ATA Copy the values for the attributes in outer and inner tuples into a new output tuple. Subsequent operators in the query plan never need to go back to the base tables to get more data. 6 R S R.id=S.id value>100 R.id, S.cdate ⨝ s p SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) O P E R AT O R O U T P U T: R E C O R D I D S Only copy the joins keys along with the record ids of the matching tuples. 7 id name 123 abc id value cdate 123 1000 10/2/2019 123 2000 10/2/2019⨝ R(id,name) S(id,value,cdate) R.id R.RID S.id S.RID 123 R.### 123 S.### 123 R.### 123 S.### SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) O P E R AT O R O U T P U T: R E C O R D I D S Only copy the joins keys along with the record ids of the matching tuples. 7 R S R.id=S.id value>100 R.id, S.cdate ⨝ s p R.id R.RID S.id S.RID 123 R.### 123 S.### 123 R.### 123 S.### SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) O P E R AT O R O U T P U T: R E C O R D I D S Only copy the joins keys along with the record ids of the matching tuples. Ideal for column stores because the DBMS does not copy data that is not need for the query. This is called late materialization. 7 R S R.id=S.id value>100 R.id, S.cdate ⨝ s p SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) I / O C O S T A N A LY S I S Assume: → M pages in table R, m tuples in R → N pages in table S, n tuples in S Cost Metric: # of IOs to compute join We will ignore output costs since that depends on the data and we cannot compute that yet. 8 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) J O I N V S C R O S S - P R O D U C T R⨝S is the most common operation and thus must be carefully optimized. R×S followed by a selection is inefficient because the cross-product is large. There are many algorithms for reducing join cost, but no algorithm works well in all scenarios. 9 CMU 15-445/645 (Fall 2019) J O I N A LG O R I T H M S Nested Loop Join → Simple / Stupid → Block → Index Sort-Merge Join Hash Join 10 CMU 15-445/645 (Fall 2019) N E S T E D LO O P J O I N 11 foreach tuple r ∈ R: foreach tuple s ∈ S: emit, if r and s match Outer Inner R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 R S ⨝ CMU 15-445/645 (Fall 2019) S T U P I D N E S T E D LO O P J O I N Why is this algorithm stupid? → For every tuple in R, it scans S once Cost: M + (m ∙ N) 12 M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) S T U P I D N E S T E D LO O P J O I N Example database: → Table R: M = 1000, m = 100,000 → Table S: N = 500, n = 40,000 Cost Analysis: → M + (m ∙ N) = 1000 + (100000 ∙ 500) = 50,001,000 IOs → At 0.1 ms/IO, Total time ≈ 1.3 hours What if smaller table (S) is used as the outer table? → N + (n ∙ M) = 500 + (40000 ∙ 1000) = 40,000,500 IOs → At 0.1 ms/IO, Total time ≈ 1.1 hours 13 4 KB pages → 6 MB CMU 15-445/645 (Fall 2019) B LO C K N E S T E D LO O P J O I N 14 foreach block BR ∈ R: foreach block BS ∈ S: foreach tuple r ∈ BR: foreach tuple s ∈ Bs: emit, if r and s match M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) B LO C K N E S T E D LO O P J O I N This algorithm performs fewer disk accesses. → For every block in R, it scans S once Cost: M + (M ∙ N ) 15 M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) B LO C K N E S T E D LO O P J O I N Which one should be the outer table? → The smaller table in terms of # of pages 16 M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) B LO C K N E S T E D LO O P J O I N Example database: → Table R: M = 1000, m = 100,000 → Table S: N = 500, n = 40,000 Cost Analysis: → M + (M ∙ N) = 1000 + (1000 ∙ 500) = 501,000 IOs → At 0.1 ms/IO, Total time ≈ 50 seconds 17 CMU 15-445/645 (Fall 2019) B LO C K N E S T E D LO O P J O I N What if we have B buffers available? → Use B-2 buffers for scanning the outer table. → Use one buffer for the inner table, one buffer for storing output. 18 M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) B LO C K N E S T E D LO O P J O I N 18 foreach B - 2 blocks bR ∈ R: foreach block bS ∈ S: foreach tuple r ∈ bR: foreach tuple s ∈ bs: emit, if r and s match M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) B LO C K N E S T E D LO O P J O I N This algorithm uses B-2 buffers for scanning R. Cost: M + ( M / (B-2) ∙ N) What if the outer relation completely fits in memory (B > M+2)? → Cost: M + N = 1000 + 500 = 1500 IOs → At 0.1ms/IO, Total time ≈ 0.15 seconds 19 CMU 15-445/645 (Fall 2019) N E S T E D LO O P J O I N Why do basic nested loop joins suck? → For each tuple in the outer table, we must do a sequential scan to check for a match in the inner table. We can avoid sequential scans by using an index to find inner table matches. → Use an existing index for the join. → Build one on the fly (hash table, B+Tree). 20 CMU 15-445/645 (Fall 2019) I N D E X N E S T E D LO O P J O I N 21 foreach tuple r ∈ R: foreach tuple s ∈ Index(ri = sj): emit, if r and s match Index(S.id) M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) I N D E X N E S T E D LO O P J O I N Assume the cost of each index probe is some constant C per tuple. Cost: M + (m ∙ C) 21 Index(S.id) M pages m tuples N pages n tuples R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 CMU 15-445/645 (Fall 2019) N E S T E D LO O P J O I N Pick the smaller table as the outer table. Buffer as much of the outer table in memory as possible. Loop over the inner table or use an index. 22 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N Phase #1: Sort → Sort both tables on the join key(s). → We can use the external merge sort algorithm that we talked about last class. Phase #2: Merge → Step through the two sorted tables with cursors and emit matching tuples. → May need to backtrack depending on the join type. 23 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 24 sort R,S on join keys cursorR ← Rsorted, cursorS ← Ssorted while cursorR and cursorS: if cursorR > cursorS: increment cursorS if cursorR < cursorS: increment cursorR elif cursorR and cursorS match: emit increment cursorS CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 600 MethodMan 200 GZA 100 Andy 300 ODB 500 RZA 700 Ghostface 200 GZA 400 Raekwon id value cdate 100 2222 10/2/2019 500 7777 10/2/2019 400 6666 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 Sort! Sort! SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 400 Raekwon 200 6666 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 400 Raekwon 200 6666 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 400 Raekwon 200 6666 10/2/2019 500 RZA 500 7777 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 400 Raekwon 200 6666 10/2/2019 500 RZA 500 7777 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 400 Raekwon 200 6666 10/2/2019 500 RZA 500 7777 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N 25 R(id,name) S(id,value,cdate) id name 100 Andy 200 GZA 200 GZA 300 ODB 400 Raekwon 500 RZA 600 MethodMan 700 Ghostface id value cdate 100 2222 10/2/2019 100 9999 10/2/2019 200 8888 10/2/2019 400 6666 10/2/2019 500 7777 10/2/2019 R.id R.name S.id S.value S.cdate 100 Andy 100 2222 10/2/2019 100 Andy 100 9999 10/2/2019 200 GZA 200 8888 10/2/2019 200 GZA 200 8888 10/2/2019 400 Raekwon 200 6666 10/2/2019 500 RZA 500 7777 10/2/2019 Output Buffer SELECT R.id, S.cdate FROM R JOIN S ON R.id = S.id WHERE S.value > 100 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N Sort Cost (R): 2M ∙ (1 + ⌈ logB-1 ⌈M / B⌉ ⌉) Sort Cost (S): 2N ∙ (1 + ⌈ logB-1 ⌈N / B⌉ ⌉) Merge Cost: (M + N) Total Cost: Sort + Merge 49 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N Example database: → Table R: M = 1000, m = 100,000 → Table S: N = 500, n = 40,000 With B=100 buffer pages, both R and S can be sorted in two passes: → Sort Cost (R) = 2000 ∙ (1 + ⌈log99 1000 /100⌉) = 4000 IOs → Sort Cost (S) = 1000 ∙ (1 + ⌈ log99 500 / 100⌉) = 2000 IOs → Merge Cost = (1000 + 500) = 1500 IOs → Total Cost = 4000 + 2000 + 1500 = 7500 IOs → At 0.1 ms/IO, Total time ≈ 0.75 seconds 50 CMU 15-445/645 (Fall 2019) S O R T- M E R G E J O I N The worst case for the merging phase is when the join attribute of all of the tuples in both relations contain the same value. Cost: (M ∙ N) + (sort cost) 28 CMU 15-445/645 (Fall 2019) W H E N I S S O R T- M E R G E J O I N U S E F U L ? One or both tables are already sorted on join key. Output must be sorted on join key. The input relations may be sorted by either by an explicit sort operator, or by scanning the relation using an index on the join key. 29 CMU 15-445/645 (Fall 2019) H A S H J O I N If tuple r ∈ R and a tuple s ∈ S satisfy the join condition, then they have the same value for the join attributes. If that value is hashed to some partition i, the R tuple must be in ri and the S tuple in si. Therefore, R tuples in ri need only to be compared with S tuples in si. 30 CMU 15-445/645 (Fall 2019) B A S I C H A S H J O I N A LG O R I T H M Phase #1: Build → Scan the outer relation and populate a hash table using the hash function h1 on the join attributes. Phase #2: Probe → Scan the inner relation and use h1 on each tuple to jump to a location in the hash table and find a matching tuple. 31 CMU 15-445/645 (Fall 2019) B A S I C H A S H J O I N A LG O R I T H M 32 build hash table HTR for R foreach tuple s ∈ S output, if h1(s) ∈ HTR ⋮ Hash Table HTRR(id,name) S(id,value,cdate) CMU 15-445/645 (Fall 2019) B A S I C H A S H J O I N A LG O R I T H M 32 build hash table HTR for R foreach tuple s ∈ S output, if h1(s) ∈ HTR h1 ⋮ Hash Table HTRR(id,name) S(id,value,cdate) CMU 15-445/645 (Fall 2019) B A S I C H A S H J O I N A LG O R I T H M 32 build hash table HTR for R foreach tuple s ∈ S output, if h1(s) ∈ HTR h1 ⋮ Hash Table HTRR(id,name) S(id,value,cdate) CMU 15-445/645 (Fall 2019) B A S I C H A S H J O I N A LG O R I T H M 32 build hash table HTR for R foreach tuple s ∈ S output, if h1(s) ∈ HTR h1 ⋮ Hash Table HTR h1 R(id,name) S(id,value,cdate) CMU 15-445/645 (Fall 2019) B A S I C H A S H J O I N A LG O R I T H M 32 build hash table HTR for R foreach tuple s ∈ S output, if h1(s) ∈ HTR h1 ⋮ Hash Table HTR h1 R(id,name) S(id,value,cdate) CMU 15-445/645 (Fall 2019) H A S H TA B L E C O N T E N T S Key: The attribute(s) that the query is joining the tables on. Value: Varies per implementation. → Depends on what the operators above the join in the query plan expect as its input. 33 CMU 15-445/645 (Fall 2019) H A S H TA B L E VA L U E S Approach #1: Full Tuple → Avoid having to retrieve the outer relation's tuple contents on a match. → Takes up more space in memory. Approach #2: Tuple Identifier → Ideal for column stores because the DBMS doesn't fetch data from disk it doesn't need. → Also better if join selectivity is low. 34 CMU 15-445/645 (Fall 2019) P R O B E P H A S E O P T I M I Z AT I O N Create a Bloom Filter during the build phase when the key is likely to not exist in the hash table. → Threads check the filter before probing the hash table. This will be faster since the filter will fit in CPU caches. → Sometimes called sideways information passing. 35 A B ⨝ CMU 15-445/645 (Fall 2019) P R O B E P H A S E O P T I M I Z AT I O N Create a Bloom Filter during the build phase when the key is likely to not exist in the hash table. → Threads check the filter before probing the hash table. This will be faster since the filter will fit in CPU caches. → Sometimes called sideways information passing. 35 A B ⨝ CMU 15-445/645 (Fall 2019) P R O B E P H A S E O P T I M I Z AT I O N Create a Bloom Filter during the build phase when the key is likely to not exist in the hash table. → Threads check the filter before probing the hash table. This will be faster since the filter will fit in CPU caches. → Sometimes called sideways information passing. 35 A B ⨝ Bloom Filter CMU 15-445/645 (Fall 2019) P R O B E P H A S E O P T I M I Z AT I O N Create a Bloom Filter during the build phase when the key is likely to not exist in the hash table. → Threads check the filter before probing the hash table. This will be faster since the filter will fit in CPU caches. → Sometimes called sideways information passing. 35 A B ⨝ Bloom Filter CMU 15-445/645 (Fall 2019) P R O B E P H A S E O P T I M I Z AT I O N Create a Bloom Filter during the build phase when the key is likely to not exist in the hash table. → Threads check the filter before probing the hash table. This will be faster since the filter will fit in CPU caches. → Sometimes called sideways information passing. 35 A B ⨝ Bloom Filter CMU 15-445/645 (Fall 2019) P R O B E P H A S E O P T I M I Z AT I O N Create a Bloom Filter during the build phase when the key is likely to not exist in the hash table. → Threads check the filter before probing the hash table. This will be faster since the filter will fit in CPU caches. → Sometimes called sideways information passing. 35 A B ⨝ Bloom Filter CMU 15-445/645 (Fall 2019) H A S H J O I N What happens if we do not have enough memory to fit the entire hash table? We do not want to let the buffer pool manager swap out the hash table pages at a random. 36 CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Hash join when tables do not fit in memory. → Build Phase: Hash both tables on the join attribute into partitions. → Probe Phase: Compares tuples in corresponding partitions for each table. Named after the GRACE database machine from Japan in the 1980s. 37 GRACE University of Tokyo CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Hash join when tables do not fit in memory. → Build Phase: Hash both tables on the join attribute into partitions. → Probe Phase: Compares tuples in corresponding partitions for each table. Named after the GRACE database machine from Japan in the 1980s. 37 GRACE University of Tokyo CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Hash join when tables do not fit in memory. → Build Phase: Hash both tables on the join attribute into partitions. → Probe Phase: Compares tuples in corresponding partitions for each table. Named after the GRACE database machine from Japan in the 1980s. 37 GRACE University of Tokyo CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Hash join when tables do not fit in memory. → Build Phase: Hash both tables on the join attribute into partitions. → Probe Phase: Compares tuples in corresponding partitions for each table. Named after the GRACE database machine from Japan in the 1980s. 37 GRACE University of Tokyo CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Hash R into (0, 1, ..., max) buckets. Hash S into the same # of buckets with the same hash function. 38 h1 ⋮ HTR h1 R(id,name) ⋮ HTS 0 1 2 max S(id,value,cdate) CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Join each pair of matching buckets between R and S. 39 h1 ⋮ HTR h1 R(id,name) ⋮ HTS 0 1 2 max S(id,value,cdate) CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Join each pair of matching buckets between R and S. 39 h1 ⋮ HTR h1 R(id,name) ⋮ HTS 0 1 2 max S(id,value,cdate) foreach tuple r ∈ bucketR,0: foreach tuple s ∈ bucketS,0: emit, if match(r, s) CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N If the buckets do not fit in memory, then use recursive partitioning to split the tables into chunks that will fit. → Build another hash table for bucketR,i using hash function h2 (with h2≠h1). → Then probe it for each tuple of the other table's bucket at that level. 40 CMU 15-445/645 (Fall 2019) R E C U R S I V E PA R T I T I O N I N G 41 h1 ⋮ R(id,name) 0 n 1 CMU 15-445/645 (Fall 2019) R E C U R S I V E PA R T I T I O N I N G 41 h1 h2 ⋮ R(id,name) 1' 1'' 1''' CMU 15-445/645 (Fall 2019) R E C U R S I V E PA R T I T I O N I N G 41 h1 h2 ⋮ R(id,name) 0 1' 1'' 1''' n CMU 15-445/645 (Fall 2019) R E C U R S I V E PA R T I T I O N I N G 41 h1 h2 ⋮ R(id,name) 0 1' 1'' 1''' n h1 0 n S(id,value,cdate) CMU 15-445/645 (Fall 2019) R E C U R S I V E PA R T I T I O N I N G 41 h1 h2 ⋮ R(id,name) 0 1' 1'' 1''' n h1 0 n 1 S(id,value,cdate) CMU 15-445/645 (Fall 2019) R E C U R S I V E PA R T I T I O N I N G 41 h1 h2 ⋮ R(id,name) 0 1' 1'' 1''' n h1 0 n h2 1''' S(id,value,cdate) CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Cost of hash join? → Assume that we have enough buffers. → Cost: 3(M + N) Partitioning Phase: → Read+Write both tables → 2(M+N) IOs Probing Phase: → Read both tables → M+N IOs 42 CMU 15-445/645 (Fall 2019) G R A C E H A S H J O I N Example database: → M = 1000, m = 100,000 → N = 500, n = 40,000 Cost Analysis: → 3 ∙ (M + N) = 3 ∙(1000 + 500) = 4,500 IOs → At 0.1 ms/IO, Total time ≈ 0.45 seconds 43 CMU 15-445/645 (Fall 2019) O B S E R VAT I O N If the DBMS knows the size of the outer table, then it can use a static hash table. → Less computational overhead for build / probe operations. If we do not know the size, then we have to use a dynamic hash table or allow for overflow pages. 44 CMU 15-445/645 (Fall 2019) J O I N A LG O R I T H M S : S U M M A R Y 45 Algorithm IO Cost Example Simple Nested Loop Join M + (m ∙ N) 1.3 hours Block Nested Loop Join M + (M ∙ N) 50 seconds Index Nested Loop Join M + (M ∙ log N) 20 seconds Sort-Merge Join M + N + (sort cost) 0.59 seconds Hash Join 3(M + N) 0.45 seconds CMU 15-445/645 (Fall 2019) C O N C L U S I O N Hashing is almost always better than sorting for operator execution. Caveats: → Sorting is better on non-uniform data. → Sorting is better when result needs to be sorted. Good DBMSs use either or both. 46 CMU 15-445/645 (Fall 2019) N E X T C L A S S Composing operators together to execute queries. 47","libVersion":"0.2.2","langs":""}