git checkout -b michael/atlit-ms3/drivers/client_mock_implementation

### Implementation of the statement request

```cpp
#include <iostream>
#include <vector>
#include <string>

class Value {
public:
    virtual ~Value() {}
    virtual void print() const = 0;
};

class StringValue : public Value {
public:
    StringValue(const std::string& value) : value_(value) {}
    void print() const override {
        std::cout << value_ << std::endl;
    }
private:
    std::string value_;
};

class IntValue : public Value {
public:
    IntValue(int value) : value_(value) {}
    void print() const override {
        std::cout << value_ << std::endl;
    }
private:
    int value_;
};

class DoubleValue : public Value {
public:
    DoubleValue(double value) : value_(value) {}
    void print() const override {
        std::cout << value_ << std::endl;
    }
private:
    double value_;
};

int main() {
    std::vector<Value*> myVector;

    myVector.push_back(new StringValue("Hello"));
    myVector.push_back(new IntValue(42));
    myVector.push_back(new DoubleValue(3.14));

    for (const auto& item : myVector) {
        item->print();
    }

    // Cleanup
    for (auto item : myVector) {
        delete item;
    }
    myVector.clear();

    return 0;
}

```

### JSON Parsing 

```cpp
#include <iostream>
#include <string>
#include "json.h"

struct Statement {
    bool hasResultSet;
    int numCols;
    std::vector<std::string> nameCols;
    std::vector<std::string> typeCols;
    std::vector<bool> nullableCols;
    int numRows;
    std::vector<std::string> values;
};

struct Result {
    std::string RC;
    std::vector<Statement> Statements;
};

void parseJson(const std::string& jsonString, Result* result) {
    json_value* root = json_parse(jsonString.c_str(), jsonString.length());

    if (root == nullptr || root->type != json_object) {
        std::cerr << "Invalid JSON format" << std::endl;
        json_value_free(root);
        return;
    }

    json_value* rcValue = json_get(root, "RC");
    if (rcValue && rcValue->type == json_string) {
        result->RC = rcValue->string_value;
    }

    json_value* statementsValue = json_get(root, "Statements");
    if (statementsValue && statementsValue->type == json_array) {
        for (json_value* statementValue = statementsValue->first_child; statementValue != nullptr;
             statementValue = statementValue->next_sibling) {
            Statement statement;
            json_value* hasResultSetValue = json_get(statementValue, "hasResultSet");
            json_value* numColsValue = json_get(statementValue, "numCols");
            json_value* nameColsValue = json_get(statementValue, "nameCols");
            json_value* typeColsValue = json_get(statementValue, "typeCols");
            json_value* nullableColsValue = json_get(statementValue, "nullableCols");
            json_value* numRowsValue = json_get(statementValue, "numRows");
            json_value* valuesValue = json_get(statementValue, "values");

            if (hasResultSetValue && hasResultSetValue->type == json_string) {
                statement.hasResultSet = (hasResultSetValue->string_value == "true");
            }
            if (numColsValue && numColsValue->type == json_integer) {
                statement.numCols = static_cast<int>(numColsValue->int_value);
            }
            if (nameColsValue && nameColsValue->type == json_array) {
                for (json_value* nameColValue = nameColsValue->first_child; nameColValue != nullptr;
                     nameColValue = nameColValue->next_sibling) {
                    if (nameColValue->type == json_string) {
                        statement.nameCols.push_back(nameColValue->string_value);
                    }
                }
            }
            if (typeColsValue && typeColsValue->type == json_array) {
                for (json_value* typeColValue = typeColsValue->first_child; typeColValue != nullptr;
                     typeColValue = typeColValue->next_sibling) {
                    if (typeColValue->type == json_string) {
                        statement.typeCols.push_back(typeColValue->string_value);
                    }
                }
            }
            if (nullableColsValue && nullableColsValue->type == json_array) {
                for (json_value* nullableColValue = nullableColsValue->first_child; nullableColValue != nullptr;
                     nullableColValue = nullableColValue->next_sibling) {
                    if (nullableColValue->type == json_string) {
                        statement.nullableCols.push_back(nullableColValue->string_value == "true");
                    }
                }
            }
            if (numRowsValue && numRowsValue->type == json_integer) {
                statement.numRows = static_cast<int>(numRowsValue->int_value);
            }
            if (valuesValue && valuesValue->type == json_array) {
                for (json_value* value = valuesValue->first_child; value != nullptr; value = value->next_sibling) {
                    if (value->type == json_string) {
                        statement.values.push_back(value->string_value);
                    }
                }
            }

            result->Statements.push_back(statement);
        }
    }

    json_value_free(root);
}

int main() {
    std::string jsonString = R"(
    {
        "RC": "kSuccess",
        "Statements": [
            {
                "hasResultSet": "true",
                "numCols": 3,
                "nameCols": ["ID", "FirstName", "WearsGlasses"],
                "typeCols": ["kInt", "kVarChar", "kBoolean"],
                "nullableCols": ["false", "true", "true"],
                "numRows": 3,
                "values": ["1", "2", "3", "John", "Bill", "Mike", "true", "true", "null"]
            },
            {
                "hasResultSet": "false",
                "numStatements": 3,
                "numAffectedRows": [15, 4, 1]
            }
        ]
    }
    )";

    Result result;
    parseJson(jsonString, &result);

    std::cout << "RC: " << result.RC << std::endl;

    for (const auto& statement : result.Statements) {
        std::cout << "hasResultSet: " << (statement.hasResultSet ? "true" : "false") << std::endl;
        std::cout << "numCols: " << statement.numCols << std::endl;

        std::cout << "nameCols: ";
        for (const auto& nameCol : statement.nameCols) {
            std::cout << nameCol << " ";
        }
        std::cout << std::endl;

        std::cout << "typeCols: ";
        for (const auto& typeCol : statement.typeCols) {
            std::cout << typeCol << " ";
        }
        std::cout << std::endl;

        std::cout << "nullableCols: ";
        for (const auto& nullableCol : statement.nullableCols) {
            std::cout << (nullableCol ? "true" : "false") << " ";
        }
        std::cout << std::endl;

        std::cout << "numRows: " << statement.numRows << std::endl;

        std::cout << "values: ";
        for (const auto& value : statement.values) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}

```